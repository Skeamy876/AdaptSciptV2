Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AND
    COMMENTS
    WHITESPACE

Grammar

Rule 0     S' -> program
Rule 1     program -> programStart
Rule 2     programStart -> INIT ( ) { statements }
Rule 3     statements -> statement
Rule 4     statements -> statements statement
Rule 5     statement -> function_calls
Rule 6     statement -> condition
Rule 7     statement -> function_declarations
Rule 8     statement -> expression
Rule 9     statement -> loops
Rule 10    statement -> RETURN expression
Rule 11    statement -> PRINT ( expression )
Rule 12    statement -> assignment
Rule 13    function_declarations -> function_declaration
Rule 14    function_declaration -> FUNC IDENTIFIER ( ) : datatype { function_body }
Rule 15    function_body -> statements
Rule 16    function_calls -> IDENTIFIER ( )
Rule 17    function_calls -> IDENTIFIER ( ) function_calls
Rule 18    function_calls -> IDENTIFIER ( parameters )
Rule 19    function_calls -> IDENTIFIER ( parameters ) function_calls
Rule 20    parameters -> parameterList
Rule 21    parameterList -> parameter
Rule 22    parameterList -> parameter , parameterList
Rule 23    parameter -> datatype IDENTIFIER
Rule 24    datatype -> INT
Rule 25    datatype -> FLOAT
Rule 26    datatype -> STRING
Rule 27    datatype -> ADAPT
Rule 28    datatype -> VOID
Rule 29    expression -> atoms
Rule 30    expression -> paren_expr
Rule 31    expression -> binary_expr
Rule 32    atoms -> INT_VALUE
Rule 33    atoms -> FLOAT_VALUE
Rule 34    atoms -> STRING_VALUE
Rule 35    atoms -> variable
Rule 36    variable -> IDENTIFIER
Rule 37    paren_expr -> ( expression )
Rule 38    binary_expr -> atoms ADD expression
Rule 39    binary_expr -> atoms SUB expression
Rule 40    binary_expr -> atoms MUL expression
Rule 41    binary_expr -> atoms DIV expression
Rule 42    binary_expr -> atoms OR expression
Rule 43    binary_expr -> atoms LE expression
Rule 44    binary_expr -> atoms GE expression
Rule 45    binary_expr -> atoms EQ expression
Rule 46    binary_expr -> atoms NE expression
Rule 47    binary_expr -> atoms GT expression
Rule 48    binary_expr -> atoms LT expression
Rule 49    binary_expr -> UNARY atoms
Rule 50    binary_expr -> atoms UNARY
Rule 51    assignment -> datatype IDENTIFIER EQUAL expression
Rule 52    assignment -> datatype IDENTIFIER EQUAL ACCEPT ( )
Rule 53    condition -> IF expression { statements }
Rule 54    condition -> IF expression { statements } ELSE { statements }
Rule 55    loops -> loop
Rule 56    loops -> loop loops
Rule 57    loop -> forLoop
Rule 58    loop -> whileLoop
Rule 59    forLoop -> FOR ( expression ; condition ; expression ) { statements }
Rule 60    whileLoop -> WHILE ( condition ) { statements }

Terminals, with rules where they appear

(                    : 2 11 14 16 17 18 19 37 52 59 60
)                    : 2 11 14 16 17 18 19 37 52 59 60
,                    : 22
:                    : 14
;                    : 59 59
ACCEPT               : 52
ADAPT                : 27
ADD                  : 38
AND                  : 
COMMENTS             : 
DIV                  : 41
ELSE                 : 54
EQ                   : 45
EQUAL                : 51 52
FLOAT                : 25
FLOAT_VALUE          : 33
FOR                  : 59
FUNC                 : 14
GE                   : 44
GT                   : 47
IDENTIFIER           : 14 16 17 18 19 23 36 51 52
IF                   : 53 54
INIT                 : 2
INT                  : 24
INT_VALUE            : 32
LE                   : 43
LT                   : 48
MUL                  : 40
NE                   : 46
OR                   : 42
PRINT                : 11
RETURN               : 10
STRING               : 26
STRING_VALUE         : 34
SUB                  : 39
UNARY                : 49 50
VOID                 : 28
WHILE                : 60
WHITESPACE           : 
error                : 
{                    : 2 14 53 54 54 59 60
}                    : 2 14 53 54 54 59 60

Nonterminals, with rules where they appear

assignment           : 12
atoms                : 29 38 39 40 41 42 43 44 45 46 47 48 49 50
binary_expr          : 31
condition            : 6 59 60
datatype             : 14 23 51 52
expression           : 8 10 11 37 38 39 40 41 42 43 44 45 46 47 48 51 53 54 59 59
forLoop              : 57
function_body        : 14
function_calls       : 5 17 19
function_declaration : 13
function_declarations : 7
loop                 : 55 56
loops                : 9 56
parameter            : 21 22
parameterList        : 20 22
parameters           : 18 19
paren_expr           : 30
program              : 0
programStart         : 1
statement            : 3 4
statements           : 2 4 15 53 54 54 59 60
variable             : 35
whileLoop            : 58

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . programStart
    (2) programStart -> . INIT ( ) { statements }

    INIT            shift and go to state 3

    program                        shift and go to state 1
    programStart                   shift and go to state 2

state 1

    (0) S' -> program .



state 2

    (1) program -> programStart .

    $end            reduce using rule 1 (program -> programStart .)


state 3

    (2) programStart -> INIT . ( ) { statements }

    (               shift and go to state 4


state 4

    (2) programStart -> INIT ( . ) { statements }

    )               shift and go to state 5


state 5

    (2) programStart -> INIT ( ) . { statements }

    {               shift and go to state 6


state 6

    (2) programStart -> INIT ( ) { . statements }
    (3) statements -> . statement
    (4) statements -> . statements statement
    (5) statement -> . function_calls
    (6) statement -> . condition
    (7) statement -> . function_declarations
    (8) statement -> . expression
    (9) statement -> . loops
    (10) statement -> . RETURN expression
    (11) statement -> . PRINT ( expression )
    (12) statement -> . assignment
    (16) function_calls -> . IDENTIFIER ( )
    (17) function_calls -> . IDENTIFIER ( ) function_calls
    (18) function_calls -> . IDENTIFIER ( parameters )
    (19) function_calls -> . IDENTIFIER ( parameters ) function_calls
    (53) condition -> . IF expression { statements }
    (54) condition -> . IF expression { statements } ELSE { statements }
    (13) function_declarations -> . function_declaration
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (55) loops -> . loop
    (56) loops -> . loop loops
    (51) assignment -> . datatype IDENTIFIER EQUAL expression
    (52) assignment -> . datatype IDENTIFIER EQUAL ACCEPT ( )
    (14) function_declaration -> . FUNC IDENTIFIER ( ) : datatype { function_body }
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (57) loop -> . forLoop
    (58) loop -> . whileLoop
    (24) datatype -> . INT
    (25) datatype -> . FLOAT
    (26) datatype -> . STRING
    (27) datatype -> . ADAPT
    (28) datatype -> . VOID
    (36) variable -> . IDENTIFIER
    (59) forLoop -> . FOR ( expression ; condition ; expression ) { statements }
    (60) whileLoop -> . WHILE ( condition ) { statements }

    RETURN          shift and go to state 15
    PRINT           shift and go to state 16
    IDENTIFIER      shift and go to state 18
    IF              shift and go to state 19
    FUNC            shift and go to state 26
    INT_VALUE       shift and go to state 27
    FLOAT_VALUE     shift and go to state 28
    STRING_VALUE    shift and go to state 29
    (               shift and go to state 7
    UNARY           shift and go to state 31
    INT             shift and go to state 34
    FLOAT           shift and go to state 35
    STRING          shift and go to state 36
    ADAPT           shift and go to state 37
    VOID            shift and go to state 38
    FOR             shift and go to state 39
    WHILE           shift and go to state 40

    statements                     shift and go to state 8
    statement                      shift and go to state 9
    function_calls                 shift and go to state 10
    condition                      shift and go to state 11
    function_declarations          shift and go to state 12
    expression                     shift and go to state 13
    loops                          shift and go to state 14
    assignment                     shift and go to state 17
    function_declaration           shift and go to state 20
    atoms                          shift and go to state 21
    paren_expr                     shift and go to state 22
    binary_expr                    shift and go to state 23
    loop                           shift and go to state 24
    datatype                       shift and go to state 25
    variable                       shift and go to state 30
    forLoop                        shift and go to state 32
    whileLoop                      shift and go to state 33

state 7

    (37) paren_expr -> ( . expression )
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (36) variable -> . IDENTIFIER

    INT_VALUE       shift and go to state 27
    FLOAT_VALUE     shift and go to state 28
    STRING_VALUE    shift and go to state 29
    (               shift and go to state 7
    UNARY           shift and go to state 31
    IDENTIFIER      shift and go to state 42

    expression                     shift and go to state 41
    atoms                          shift and go to state 21
    paren_expr                     shift and go to state 22
    binary_expr                    shift and go to state 23
    variable                       shift and go to state 30

state 8

    (2) programStart -> INIT ( ) { statements . }
    (4) statements -> statements . statement
    (5) statement -> . function_calls
    (6) statement -> . condition
    (7) statement -> . function_declarations
    (8) statement -> . expression
    (9) statement -> . loops
    (10) statement -> . RETURN expression
    (11) statement -> . PRINT ( expression )
    (12) statement -> . assignment
    (16) function_calls -> . IDENTIFIER ( )
    (17) function_calls -> . IDENTIFIER ( ) function_calls
    (18) function_calls -> . IDENTIFIER ( parameters )
    (19) function_calls -> . IDENTIFIER ( parameters ) function_calls
    (53) condition -> . IF expression { statements }
    (54) condition -> . IF expression { statements } ELSE { statements }
    (13) function_declarations -> . function_declaration
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (55) loops -> . loop
    (56) loops -> . loop loops
    (51) assignment -> . datatype IDENTIFIER EQUAL expression
    (52) assignment -> . datatype IDENTIFIER EQUAL ACCEPT ( )
    (14) function_declaration -> . FUNC IDENTIFIER ( ) : datatype { function_body }
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (57) loop -> . forLoop
    (58) loop -> . whileLoop
    (24) datatype -> . INT
    (25) datatype -> . FLOAT
    (26) datatype -> . STRING
    (27) datatype -> . ADAPT
    (28) datatype -> . VOID
    (36) variable -> . IDENTIFIER
    (59) forLoop -> . FOR ( expression ; condition ; expression ) { statements }
    (60) whileLoop -> . WHILE ( condition ) { statements }

    }               shift and go to state 43
    RETURN          shift and go to state 15
    PRINT           shift and go to state 16
    IDENTIFIER      shift and go to state 18
    IF              shift and go to state 19
    FUNC            shift and go to state 26
    INT_VALUE       shift and go to state 27
    FLOAT_VALUE     shift and go to state 28
    STRING_VALUE    shift and go to state 29
    (               shift and go to state 7
    UNARY           shift and go to state 31
    INT             shift and go to state 34
    FLOAT           shift and go to state 35
    STRING          shift and go to state 36
    ADAPT           shift and go to state 37
    VOID            shift and go to state 38
    FOR             shift and go to state 39
    WHILE           shift and go to state 40

    statement                      shift and go to state 44
    function_calls                 shift and go to state 10
    condition                      shift and go to state 11
    function_declarations          shift and go to state 12
    expression                     shift and go to state 13
    loops                          shift and go to state 14
    assignment                     shift and go to state 17
    function_declaration           shift and go to state 20
    atoms                          shift and go to state 21
    paren_expr                     shift and go to state 22
    binary_expr                    shift and go to state 23
    loop                           shift and go to state 24
    datatype                       shift and go to state 25
    variable                       shift and go to state 30
    forLoop                        shift and go to state 32
    whileLoop                      shift and go to state 33

state 9

    (3) statements -> statement .

    }               reduce using rule 3 (statements -> statement .)
    RETURN          reduce using rule 3 (statements -> statement .)
    PRINT           reduce using rule 3 (statements -> statement .)
    IDENTIFIER      reduce using rule 3 (statements -> statement .)
    IF              reduce using rule 3 (statements -> statement .)
    FUNC            reduce using rule 3 (statements -> statement .)
    INT_VALUE       reduce using rule 3 (statements -> statement .)
    FLOAT_VALUE     reduce using rule 3 (statements -> statement .)
    STRING_VALUE    reduce using rule 3 (statements -> statement .)
    (               reduce using rule 3 (statements -> statement .)
    UNARY           reduce using rule 3 (statements -> statement .)
    INT             reduce using rule 3 (statements -> statement .)
    FLOAT           reduce using rule 3 (statements -> statement .)
    STRING          reduce using rule 3 (statements -> statement .)
    ADAPT           reduce using rule 3 (statements -> statement .)
    VOID            reduce using rule 3 (statements -> statement .)
    FOR             reduce using rule 3 (statements -> statement .)
    WHILE           reduce using rule 3 (statements -> statement .)


state 10

    (5) statement -> function_calls .

    }               reduce using rule 5 (statement -> function_calls .)
    RETURN          reduce using rule 5 (statement -> function_calls .)
    PRINT           reduce using rule 5 (statement -> function_calls .)
    IDENTIFIER      reduce using rule 5 (statement -> function_calls .)
    IF              reduce using rule 5 (statement -> function_calls .)
    FUNC            reduce using rule 5 (statement -> function_calls .)
    INT_VALUE       reduce using rule 5 (statement -> function_calls .)
    FLOAT_VALUE     reduce using rule 5 (statement -> function_calls .)
    STRING_VALUE    reduce using rule 5 (statement -> function_calls .)
    (               reduce using rule 5 (statement -> function_calls .)
    UNARY           reduce using rule 5 (statement -> function_calls .)
    INT             reduce using rule 5 (statement -> function_calls .)
    FLOAT           reduce using rule 5 (statement -> function_calls .)
    STRING          reduce using rule 5 (statement -> function_calls .)
    ADAPT           reduce using rule 5 (statement -> function_calls .)
    VOID            reduce using rule 5 (statement -> function_calls .)
    FOR             reduce using rule 5 (statement -> function_calls .)
    WHILE           reduce using rule 5 (statement -> function_calls .)


state 11

    (6) statement -> condition .

    }               reduce using rule 6 (statement -> condition .)
    RETURN          reduce using rule 6 (statement -> condition .)
    PRINT           reduce using rule 6 (statement -> condition .)
    IDENTIFIER      reduce using rule 6 (statement -> condition .)
    IF              reduce using rule 6 (statement -> condition .)
    FUNC            reduce using rule 6 (statement -> condition .)
    INT_VALUE       reduce using rule 6 (statement -> condition .)
    FLOAT_VALUE     reduce using rule 6 (statement -> condition .)
    STRING_VALUE    reduce using rule 6 (statement -> condition .)
    (               reduce using rule 6 (statement -> condition .)
    UNARY           reduce using rule 6 (statement -> condition .)
    INT             reduce using rule 6 (statement -> condition .)
    FLOAT           reduce using rule 6 (statement -> condition .)
    STRING          reduce using rule 6 (statement -> condition .)
    ADAPT           reduce using rule 6 (statement -> condition .)
    VOID            reduce using rule 6 (statement -> condition .)
    FOR             reduce using rule 6 (statement -> condition .)
    WHILE           reduce using rule 6 (statement -> condition .)


state 12

    (7) statement -> function_declarations .

    }               reduce using rule 7 (statement -> function_declarations .)
    RETURN          reduce using rule 7 (statement -> function_declarations .)
    PRINT           reduce using rule 7 (statement -> function_declarations .)
    IDENTIFIER      reduce using rule 7 (statement -> function_declarations .)
    IF              reduce using rule 7 (statement -> function_declarations .)
    FUNC            reduce using rule 7 (statement -> function_declarations .)
    INT_VALUE       reduce using rule 7 (statement -> function_declarations .)
    FLOAT_VALUE     reduce using rule 7 (statement -> function_declarations .)
    STRING_VALUE    reduce using rule 7 (statement -> function_declarations .)
    (               reduce using rule 7 (statement -> function_declarations .)
    UNARY           reduce using rule 7 (statement -> function_declarations .)
    INT             reduce using rule 7 (statement -> function_declarations .)
    FLOAT           reduce using rule 7 (statement -> function_declarations .)
    STRING          reduce using rule 7 (statement -> function_declarations .)
    ADAPT           reduce using rule 7 (statement -> function_declarations .)
    VOID            reduce using rule 7 (statement -> function_declarations .)
    FOR             reduce using rule 7 (statement -> function_declarations .)
    WHILE           reduce using rule 7 (statement -> function_declarations .)


state 13

    (8) statement -> expression .

    }               reduce using rule 8 (statement -> expression .)
    RETURN          reduce using rule 8 (statement -> expression .)
    PRINT           reduce using rule 8 (statement -> expression .)
    IDENTIFIER      reduce using rule 8 (statement -> expression .)
    IF              reduce using rule 8 (statement -> expression .)
    FUNC            reduce using rule 8 (statement -> expression .)
    INT_VALUE       reduce using rule 8 (statement -> expression .)
    FLOAT_VALUE     reduce using rule 8 (statement -> expression .)
    STRING_VALUE    reduce using rule 8 (statement -> expression .)
    (               reduce using rule 8 (statement -> expression .)
    UNARY           reduce using rule 8 (statement -> expression .)
    INT             reduce using rule 8 (statement -> expression .)
    FLOAT           reduce using rule 8 (statement -> expression .)
    STRING          reduce using rule 8 (statement -> expression .)
    ADAPT           reduce using rule 8 (statement -> expression .)
    VOID            reduce using rule 8 (statement -> expression .)
    FOR             reduce using rule 8 (statement -> expression .)
    WHILE           reduce using rule 8 (statement -> expression .)


state 14

    (9) statement -> loops .

    }               reduce using rule 9 (statement -> loops .)
    RETURN          reduce using rule 9 (statement -> loops .)
    PRINT           reduce using rule 9 (statement -> loops .)
    IDENTIFIER      reduce using rule 9 (statement -> loops .)
    IF              reduce using rule 9 (statement -> loops .)
    FUNC            reduce using rule 9 (statement -> loops .)
    INT_VALUE       reduce using rule 9 (statement -> loops .)
    FLOAT_VALUE     reduce using rule 9 (statement -> loops .)
    STRING_VALUE    reduce using rule 9 (statement -> loops .)
    (               reduce using rule 9 (statement -> loops .)
    UNARY           reduce using rule 9 (statement -> loops .)
    INT             reduce using rule 9 (statement -> loops .)
    FLOAT           reduce using rule 9 (statement -> loops .)
    STRING          reduce using rule 9 (statement -> loops .)
    ADAPT           reduce using rule 9 (statement -> loops .)
    VOID            reduce using rule 9 (statement -> loops .)
    FOR             reduce using rule 9 (statement -> loops .)
    WHILE           reduce using rule 9 (statement -> loops .)


state 15

    (10) statement -> RETURN . expression
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (36) variable -> . IDENTIFIER

    INT_VALUE       shift and go to state 27
    FLOAT_VALUE     shift and go to state 28
    STRING_VALUE    shift and go to state 29
    (               shift and go to state 7
    UNARY           shift and go to state 31
    IDENTIFIER      shift and go to state 42

    expression                     shift and go to state 45
    atoms                          shift and go to state 21
    paren_expr                     shift and go to state 22
    binary_expr                    shift and go to state 23
    variable                       shift and go to state 30

state 16

    (11) statement -> PRINT . ( expression )

    (               shift and go to state 46


state 17

    (12) statement -> assignment .

    }               reduce using rule 12 (statement -> assignment .)
    RETURN          reduce using rule 12 (statement -> assignment .)
    PRINT           reduce using rule 12 (statement -> assignment .)
    IDENTIFIER      reduce using rule 12 (statement -> assignment .)
    IF              reduce using rule 12 (statement -> assignment .)
    FUNC            reduce using rule 12 (statement -> assignment .)
    INT_VALUE       reduce using rule 12 (statement -> assignment .)
    FLOAT_VALUE     reduce using rule 12 (statement -> assignment .)
    STRING_VALUE    reduce using rule 12 (statement -> assignment .)
    (               reduce using rule 12 (statement -> assignment .)
    UNARY           reduce using rule 12 (statement -> assignment .)
    INT             reduce using rule 12 (statement -> assignment .)
    FLOAT           reduce using rule 12 (statement -> assignment .)
    STRING          reduce using rule 12 (statement -> assignment .)
    ADAPT           reduce using rule 12 (statement -> assignment .)
    VOID            reduce using rule 12 (statement -> assignment .)
    FOR             reduce using rule 12 (statement -> assignment .)
    WHILE           reduce using rule 12 (statement -> assignment .)


state 18

    (16) function_calls -> IDENTIFIER . ( )
    (17) function_calls -> IDENTIFIER . ( ) function_calls
    (18) function_calls -> IDENTIFIER . ( parameters )
    (19) function_calls -> IDENTIFIER . ( parameters ) function_calls
    (36) variable -> IDENTIFIER .

  ! shift/reduce conflict for ( resolved as shift
    (               shift and go to state 47
    ADD             reduce using rule 36 (variable -> IDENTIFIER .)
    SUB             reduce using rule 36 (variable -> IDENTIFIER .)
    MUL             reduce using rule 36 (variable -> IDENTIFIER .)
    DIV             reduce using rule 36 (variable -> IDENTIFIER .)
    OR              reduce using rule 36 (variable -> IDENTIFIER .)
    LE              reduce using rule 36 (variable -> IDENTIFIER .)
    GE              reduce using rule 36 (variable -> IDENTIFIER .)
    EQ              reduce using rule 36 (variable -> IDENTIFIER .)
    NE              reduce using rule 36 (variable -> IDENTIFIER .)
    GT              reduce using rule 36 (variable -> IDENTIFIER .)
    LT              reduce using rule 36 (variable -> IDENTIFIER .)
    UNARY           reduce using rule 36 (variable -> IDENTIFIER .)
    }               reduce using rule 36 (variable -> IDENTIFIER .)
    RETURN          reduce using rule 36 (variable -> IDENTIFIER .)
    PRINT           reduce using rule 36 (variable -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 36 (variable -> IDENTIFIER .)
    IF              reduce using rule 36 (variable -> IDENTIFIER .)
    FUNC            reduce using rule 36 (variable -> IDENTIFIER .)
    INT_VALUE       reduce using rule 36 (variable -> IDENTIFIER .)
    FLOAT_VALUE     reduce using rule 36 (variable -> IDENTIFIER .)
    STRING_VALUE    reduce using rule 36 (variable -> IDENTIFIER .)
    INT             reduce using rule 36 (variable -> IDENTIFIER .)
    FLOAT           reduce using rule 36 (variable -> IDENTIFIER .)
    STRING          reduce using rule 36 (variable -> IDENTIFIER .)
    ADAPT           reduce using rule 36 (variable -> IDENTIFIER .)
    VOID            reduce using rule 36 (variable -> IDENTIFIER .)
    FOR             reduce using rule 36 (variable -> IDENTIFIER .)
    WHILE           reduce using rule 36 (variable -> IDENTIFIER .)

  ! (               [ reduce using rule 36 (variable -> IDENTIFIER .) ]


state 19

    (53) condition -> IF . expression { statements }
    (54) condition -> IF . expression { statements } ELSE { statements }
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (36) variable -> . IDENTIFIER

    INT_VALUE       shift and go to state 27
    FLOAT_VALUE     shift and go to state 28
    STRING_VALUE    shift and go to state 29
    (               shift and go to state 7
    UNARY           shift and go to state 31
    IDENTIFIER      shift and go to state 42

    expression                     shift and go to state 48
    atoms                          shift and go to state 21
    paren_expr                     shift and go to state 22
    binary_expr                    shift and go to state 23
    variable                       shift and go to state 30

state 20

    (13) function_declarations -> function_declaration .

    }               reduce using rule 13 (function_declarations -> function_declaration .)
    RETURN          reduce using rule 13 (function_declarations -> function_declaration .)
    PRINT           reduce using rule 13 (function_declarations -> function_declaration .)
    IDENTIFIER      reduce using rule 13 (function_declarations -> function_declaration .)
    IF              reduce using rule 13 (function_declarations -> function_declaration .)
    FUNC            reduce using rule 13 (function_declarations -> function_declaration .)
    INT_VALUE       reduce using rule 13 (function_declarations -> function_declaration .)
    FLOAT_VALUE     reduce using rule 13 (function_declarations -> function_declaration .)
    STRING_VALUE    reduce using rule 13 (function_declarations -> function_declaration .)
    (               reduce using rule 13 (function_declarations -> function_declaration .)
    UNARY           reduce using rule 13 (function_declarations -> function_declaration .)
    INT             reduce using rule 13 (function_declarations -> function_declaration .)
    FLOAT           reduce using rule 13 (function_declarations -> function_declaration .)
    STRING          reduce using rule 13 (function_declarations -> function_declaration .)
    ADAPT           reduce using rule 13 (function_declarations -> function_declaration .)
    VOID            reduce using rule 13 (function_declarations -> function_declaration .)
    FOR             reduce using rule 13 (function_declarations -> function_declaration .)
    WHILE           reduce using rule 13 (function_declarations -> function_declaration .)


state 21

    (29) expression -> atoms .
    (38) binary_expr -> atoms . ADD expression
    (39) binary_expr -> atoms . SUB expression
    (40) binary_expr -> atoms . MUL expression
    (41) binary_expr -> atoms . DIV expression
    (42) binary_expr -> atoms . OR expression
    (43) binary_expr -> atoms . LE expression
    (44) binary_expr -> atoms . GE expression
    (45) binary_expr -> atoms . EQ expression
    (46) binary_expr -> atoms . NE expression
    (47) binary_expr -> atoms . GT expression
    (48) binary_expr -> atoms . LT expression
    (50) binary_expr -> atoms . UNARY

  ! shift/reduce conflict for UNARY resolved as shift
    }               reduce using rule 29 (expression -> atoms .)
    RETURN          reduce using rule 29 (expression -> atoms .)
    PRINT           reduce using rule 29 (expression -> atoms .)
    IDENTIFIER      reduce using rule 29 (expression -> atoms .)
    IF              reduce using rule 29 (expression -> atoms .)
    FUNC            reduce using rule 29 (expression -> atoms .)
    INT_VALUE       reduce using rule 29 (expression -> atoms .)
    FLOAT_VALUE     reduce using rule 29 (expression -> atoms .)
    STRING_VALUE    reduce using rule 29 (expression -> atoms .)
    (               reduce using rule 29 (expression -> atoms .)
    INT             reduce using rule 29 (expression -> atoms .)
    FLOAT           reduce using rule 29 (expression -> atoms .)
    STRING          reduce using rule 29 (expression -> atoms .)
    ADAPT           reduce using rule 29 (expression -> atoms .)
    VOID            reduce using rule 29 (expression -> atoms .)
    FOR             reduce using rule 29 (expression -> atoms .)
    WHILE           reduce using rule 29 (expression -> atoms .)
    )               reduce using rule 29 (expression -> atoms .)
    {               reduce using rule 29 (expression -> atoms .)
    ;               reduce using rule 29 (expression -> atoms .)
    ADD             shift and go to state 49
    SUB             shift and go to state 50
    MUL             shift and go to state 51
    DIV             shift and go to state 52
    OR              shift and go to state 53
    LE              shift and go to state 54
    GE              shift and go to state 55
    EQ              shift and go to state 56
    NE              shift and go to state 57
    GT              shift and go to state 58
    LT              shift and go to state 59
    UNARY           shift and go to state 60

  ! UNARY           [ reduce using rule 29 (expression -> atoms .) ]


state 22

    (30) expression -> paren_expr .

    }               reduce using rule 30 (expression -> paren_expr .)
    RETURN          reduce using rule 30 (expression -> paren_expr .)
    PRINT           reduce using rule 30 (expression -> paren_expr .)
    IDENTIFIER      reduce using rule 30 (expression -> paren_expr .)
    IF              reduce using rule 30 (expression -> paren_expr .)
    FUNC            reduce using rule 30 (expression -> paren_expr .)
    INT_VALUE       reduce using rule 30 (expression -> paren_expr .)
    FLOAT_VALUE     reduce using rule 30 (expression -> paren_expr .)
    STRING_VALUE    reduce using rule 30 (expression -> paren_expr .)
    (               reduce using rule 30 (expression -> paren_expr .)
    UNARY           reduce using rule 30 (expression -> paren_expr .)
    INT             reduce using rule 30 (expression -> paren_expr .)
    FLOAT           reduce using rule 30 (expression -> paren_expr .)
    STRING          reduce using rule 30 (expression -> paren_expr .)
    ADAPT           reduce using rule 30 (expression -> paren_expr .)
    VOID            reduce using rule 30 (expression -> paren_expr .)
    FOR             reduce using rule 30 (expression -> paren_expr .)
    WHILE           reduce using rule 30 (expression -> paren_expr .)
    )               reduce using rule 30 (expression -> paren_expr .)
    {               reduce using rule 30 (expression -> paren_expr .)
    ;               reduce using rule 30 (expression -> paren_expr .)


state 23

    (31) expression -> binary_expr .

    }               reduce using rule 31 (expression -> binary_expr .)
    RETURN          reduce using rule 31 (expression -> binary_expr .)
    PRINT           reduce using rule 31 (expression -> binary_expr .)
    IDENTIFIER      reduce using rule 31 (expression -> binary_expr .)
    IF              reduce using rule 31 (expression -> binary_expr .)
    FUNC            reduce using rule 31 (expression -> binary_expr .)
    INT_VALUE       reduce using rule 31 (expression -> binary_expr .)
    FLOAT_VALUE     reduce using rule 31 (expression -> binary_expr .)
    STRING_VALUE    reduce using rule 31 (expression -> binary_expr .)
    (               reduce using rule 31 (expression -> binary_expr .)
    UNARY           reduce using rule 31 (expression -> binary_expr .)
    INT             reduce using rule 31 (expression -> binary_expr .)
    FLOAT           reduce using rule 31 (expression -> binary_expr .)
    STRING          reduce using rule 31 (expression -> binary_expr .)
    ADAPT           reduce using rule 31 (expression -> binary_expr .)
    VOID            reduce using rule 31 (expression -> binary_expr .)
    FOR             reduce using rule 31 (expression -> binary_expr .)
    WHILE           reduce using rule 31 (expression -> binary_expr .)
    )               reduce using rule 31 (expression -> binary_expr .)
    {               reduce using rule 31 (expression -> binary_expr .)
    ;               reduce using rule 31 (expression -> binary_expr .)


state 24

    (55) loops -> loop .
    (56) loops -> loop . loops
    (55) loops -> . loop
    (56) loops -> . loop loops
    (57) loop -> . forLoop
    (58) loop -> . whileLoop
    (59) forLoop -> . FOR ( expression ; condition ; expression ) { statements }
    (60) whileLoop -> . WHILE ( condition ) { statements }

  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
    }               reduce using rule 55 (loops -> loop .)
    RETURN          reduce using rule 55 (loops -> loop .)
    PRINT           reduce using rule 55 (loops -> loop .)
    IDENTIFIER      reduce using rule 55 (loops -> loop .)
    IF              reduce using rule 55 (loops -> loop .)
    FUNC            reduce using rule 55 (loops -> loop .)
    INT_VALUE       reduce using rule 55 (loops -> loop .)
    FLOAT_VALUE     reduce using rule 55 (loops -> loop .)
    STRING_VALUE    reduce using rule 55 (loops -> loop .)
    (               reduce using rule 55 (loops -> loop .)
    UNARY           reduce using rule 55 (loops -> loop .)
    INT             reduce using rule 55 (loops -> loop .)
    FLOAT           reduce using rule 55 (loops -> loop .)
    STRING          reduce using rule 55 (loops -> loop .)
    ADAPT           reduce using rule 55 (loops -> loop .)
    VOID            reduce using rule 55 (loops -> loop .)
    FOR             shift and go to state 39
    WHILE           shift and go to state 40

  ! FOR             [ reduce using rule 55 (loops -> loop .) ]
  ! WHILE           [ reduce using rule 55 (loops -> loop .) ]

    loop                           shift and go to state 24
    loops                          shift and go to state 61
    forLoop                        shift and go to state 32
    whileLoop                      shift and go to state 33

state 25

    (51) assignment -> datatype . IDENTIFIER EQUAL expression
    (52) assignment -> datatype . IDENTIFIER EQUAL ACCEPT ( )

    IDENTIFIER      shift and go to state 62


state 26

    (14) function_declaration -> FUNC . IDENTIFIER ( ) : datatype { function_body }

    IDENTIFIER      shift and go to state 63


state 27

    (32) atoms -> INT_VALUE .

    ADD             reduce using rule 32 (atoms -> INT_VALUE .)
    SUB             reduce using rule 32 (atoms -> INT_VALUE .)
    MUL             reduce using rule 32 (atoms -> INT_VALUE .)
    DIV             reduce using rule 32 (atoms -> INT_VALUE .)
    OR              reduce using rule 32 (atoms -> INT_VALUE .)
    LE              reduce using rule 32 (atoms -> INT_VALUE .)
    GE              reduce using rule 32 (atoms -> INT_VALUE .)
    EQ              reduce using rule 32 (atoms -> INT_VALUE .)
    NE              reduce using rule 32 (atoms -> INT_VALUE .)
    GT              reduce using rule 32 (atoms -> INT_VALUE .)
    LT              reduce using rule 32 (atoms -> INT_VALUE .)
    UNARY           reduce using rule 32 (atoms -> INT_VALUE .)
    }               reduce using rule 32 (atoms -> INT_VALUE .)
    RETURN          reduce using rule 32 (atoms -> INT_VALUE .)
    PRINT           reduce using rule 32 (atoms -> INT_VALUE .)
    IDENTIFIER      reduce using rule 32 (atoms -> INT_VALUE .)
    IF              reduce using rule 32 (atoms -> INT_VALUE .)
    FUNC            reduce using rule 32 (atoms -> INT_VALUE .)
    INT_VALUE       reduce using rule 32 (atoms -> INT_VALUE .)
    FLOAT_VALUE     reduce using rule 32 (atoms -> INT_VALUE .)
    STRING_VALUE    reduce using rule 32 (atoms -> INT_VALUE .)
    (               reduce using rule 32 (atoms -> INT_VALUE .)
    INT             reduce using rule 32 (atoms -> INT_VALUE .)
    FLOAT           reduce using rule 32 (atoms -> INT_VALUE .)
    STRING          reduce using rule 32 (atoms -> INT_VALUE .)
    ADAPT           reduce using rule 32 (atoms -> INT_VALUE .)
    VOID            reduce using rule 32 (atoms -> INT_VALUE .)
    FOR             reduce using rule 32 (atoms -> INT_VALUE .)
    WHILE           reduce using rule 32 (atoms -> INT_VALUE .)
    )               reduce using rule 32 (atoms -> INT_VALUE .)
    {               reduce using rule 32 (atoms -> INT_VALUE .)
    ;               reduce using rule 32 (atoms -> INT_VALUE .)


state 28

    (33) atoms -> FLOAT_VALUE .

    ADD             reduce using rule 33 (atoms -> FLOAT_VALUE .)
    SUB             reduce using rule 33 (atoms -> FLOAT_VALUE .)
    MUL             reduce using rule 33 (atoms -> FLOAT_VALUE .)
    DIV             reduce using rule 33 (atoms -> FLOAT_VALUE .)
    OR              reduce using rule 33 (atoms -> FLOAT_VALUE .)
    LE              reduce using rule 33 (atoms -> FLOAT_VALUE .)
    GE              reduce using rule 33 (atoms -> FLOAT_VALUE .)
    EQ              reduce using rule 33 (atoms -> FLOAT_VALUE .)
    NE              reduce using rule 33 (atoms -> FLOAT_VALUE .)
    GT              reduce using rule 33 (atoms -> FLOAT_VALUE .)
    LT              reduce using rule 33 (atoms -> FLOAT_VALUE .)
    UNARY           reduce using rule 33 (atoms -> FLOAT_VALUE .)
    }               reduce using rule 33 (atoms -> FLOAT_VALUE .)
    RETURN          reduce using rule 33 (atoms -> FLOAT_VALUE .)
    PRINT           reduce using rule 33 (atoms -> FLOAT_VALUE .)
    IDENTIFIER      reduce using rule 33 (atoms -> FLOAT_VALUE .)
    IF              reduce using rule 33 (atoms -> FLOAT_VALUE .)
    FUNC            reduce using rule 33 (atoms -> FLOAT_VALUE .)
    INT_VALUE       reduce using rule 33 (atoms -> FLOAT_VALUE .)
    FLOAT_VALUE     reduce using rule 33 (atoms -> FLOAT_VALUE .)
    STRING_VALUE    reduce using rule 33 (atoms -> FLOAT_VALUE .)
    (               reduce using rule 33 (atoms -> FLOAT_VALUE .)
    INT             reduce using rule 33 (atoms -> FLOAT_VALUE .)
    FLOAT           reduce using rule 33 (atoms -> FLOAT_VALUE .)
    STRING          reduce using rule 33 (atoms -> FLOAT_VALUE .)
    ADAPT           reduce using rule 33 (atoms -> FLOAT_VALUE .)
    VOID            reduce using rule 33 (atoms -> FLOAT_VALUE .)
    FOR             reduce using rule 33 (atoms -> FLOAT_VALUE .)
    WHILE           reduce using rule 33 (atoms -> FLOAT_VALUE .)
    )               reduce using rule 33 (atoms -> FLOAT_VALUE .)
    {               reduce using rule 33 (atoms -> FLOAT_VALUE .)
    ;               reduce using rule 33 (atoms -> FLOAT_VALUE .)


state 29

    (34) atoms -> STRING_VALUE .

    ADD             reduce using rule 34 (atoms -> STRING_VALUE .)
    SUB             reduce using rule 34 (atoms -> STRING_VALUE .)
    MUL             reduce using rule 34 (atoms -> STRING_VALUE .)
    DIV             reduce using rule 34 (atoms -> STRING_VALUE .)
    OR              reduce using rule 34 (atoms -> STRING_VALUE .)
    LE              reduce using rule 34 (atoms -> STRING_VALUE .)
    GE              reduce using rule 34 (atoms -> STRING_VALUE .)
    EQ              reduce using rule 34 (atoms -> STRING_VALUE .)
    NE              reduce using rule 34 (atoms -> STRING_VALUE .)
    GT              reduce using rule 34 (atoms -> STRING_VALUE .)
    LT              reduce using rule 34 (atoms -> STRING_VALUE .)
    UNARY           reduce using rule 34 (atoms -> STRING_VALUE .)
    }               reduce using rule 34 (atoms -> STRING_VALUE .)
    RETURN          reduce using rule 34 (atoms -> STRING_VALUE .)
    PRINT           reduce using rule 34 (atoms -> STRING_VALUE .)
    IDENTIFIER      reduce using rule 34 (atoms -> STRING_VALUE .)
    IF              reduce using rule 34 (atoms -> STRING_VALUE .)
    FUNC            reduce using rule 34 (atoms -> STRING_VALUE .)
    INT_VALUE       reduce using rule 34 (atoms -> STRING_VALUE .)
    FLOAT_VALUE     reduce using rule 34 (atoms -> STRING_VALUE .)
    STRING_VALUE    reduce using rule 34 (atoms -> STRING_VALUE .)
    (               reduce using rule 34 (atoms -> STRING_VALUE .)
    INT             reduce using rule 34 (atoms -> STRING_VALUE .)
    FLOAT           reduce using rule 34 (atoms -> STRING_VALUE .)
    STRING          reduce using rule 34 (atoms -> STRING_VALUE .)
    ADAPT           reduce using rule 34 (atoms -> STRING_VALUE .)
    VOID            reduce using rule 34 (atoms -> STRING_VALUE .)
    FOR             reduce using rule 34 (atoms -> STRING_VALUE .)
    WHILE           reduce using rule 34 (atoms -> STRING_VALUE .)
    )               reduce using rule 34 (atoms -> STRING_VALUE .)
    {               reduce using rule 34 (atoms -> STRING_VALUE .)
    ;               reduce using rule 34 (atoms -> STRING_VALUE .)


state 30

    (35) atoms -> variable .

    ADD             reduce using rule 35 (atoms -> variable .)
    SUB             reduce using rule 35 (atoms -> variable .)
    MUL             reduce using rule 35 (atoms -> variable .)
    DIV             reduce using rule 35 (atoms -> variable .)
    OR              reduce using rule 35 (atoms -> variable .)
    LE              reduce using rule 35 (atoms -> variable .)
    GE              reduce using rule 35 (atoms -> variable .)
    EQ              reduce using rule 35 (atoms -> variable .)
    NE              reduce using rule 35 (atoms -> variable .)
    GT              reduce using rule 35 (atoms -> variable .)
    LT              reduce using rule 35 (atoms -> variable .)
    UNARY           reduce using rule 35 (atoms -> variable .)
    }               reduce using rule 35 (atoms -> variable .)
    RETURN          reduce using rule 35 (atoms -> variable .)
    PRINT           reduce using rule 35 (atoms -> variable .)
    IDENTIFIER      reduce using rule 35 (atoms -> variable .)
    IF              reduce using rule 35 (atoms -> variable .)
    FUNC            reduce using rule 35 (atoms -> variable .)
    INT_VALUE       reduce using rule 35 (atoms -> variable .)
    FLOAT_VALUE     reduce using rule 35 (atoms -> variable .)
    STRING_VALUE    reduce using rule 35 (atoms -> variable .)
    (               reduce using rule 35 (atoms -> variable .)
    INT             reduce using rule 35 (atoms -> variable .)
    FLOAT           reduce using rule 35 (atoms -> variable .)
    STRING          reduce using rule 35 (atoms -> variable .)
    ADAPT           reduce using rule 35 (atoms -> variable .)
    VOID            reduce using rule 35 (atoms -> variable .)
    FOR             reduce using rule 35 (atoms -> variable .)
    WHILE           reduce using rule 35 (atoms -> variable .)
    )               reduce using rule 35 (atoms -> variable .)
    {               reduce using rule 35 (atoms -> variable .)
    ;               reduce using rule 35 (atoms -> variable .)


state 31

    (49) binary_expr -> UNARY . atoms
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (36) variable -> . IDENTIFIER

    INT_VALUE       shift and go to state 27
    FLOAT_VALUE     shift and go to state 28
    STRING_VALUE    shift and go to state 29
    IDENTIFIER      shift and go to state 42

    atoms                          shift and go to state 64
    variable                       shift and go to state 30

state 32

    (57) loop -> forLoop .

    FOR             reduce using rule 57 (loop -> forLoop .)
    WHILE           reduce using rule 57 (loop -> forLoop .)
    }               reduce using rule 57 (loop -> forLoop .)
    RETURN          reduce using rule 57 (loop -> forLoop .)
    PRINT           reduce using rule 57 (loop -> forLoop .)
    IDENTIFIER      reduce using rule 57 (loop -> forLoop .)
    IF              reduce using rule 57 (loop -> forLoop .)
    FUNC            reduce using rule 57 (loop -> forLoop .)
    INT_VALUE       reduce using rule 57 (loop -> forLoop .)
    FLOAT_VALUE     reduce using rule 57 (loop -> forLoop .)
    STRING_VALUE    reduce using rule 57 (loop -> forLoop .)
    (               reduce using rule 57 (loop -> forLoop .)
    UNARY           reduce using rule 57 (loop -> forLoop .)
    INT             reduce using rule 57 (loop -> forLoop .)
    FLOAT           reduce using rule 57 (loop -> forLoop .)
    STRING          reduce using rule 57 (loop -> forLoop .)
    ADAPT           reduce using rule 57 (loop -> forLoop .)
    VOID            reduce using rule 57 (loop -> forLoop .)


state 33

    (58) loop -> whileLoop .

    FOR             reduce using rule 58 (loop -> whileLoop .)
    WHILE           reduce using rule 58 (loop -> whileLoop .)
    }               reduce using rule 58 (loop -> whileLoop .)
    RETURN          reduce using rule 58 (loop -> whileLoop .)
    PRINT           reduce using rule 58 (loop -> whileLoop .)
    IDENTIFIER      reduce using rule 58 (loop -> whileLoop .)
    IF              reduce using rule 58 (loop -> whileLoop .)
    FUNC            reduce using rule 58 (loop -> whileLoop .)
    INT_VALUE       reduce using rule 58 (loop -> whileLoop .)
    FLOAT_VALUE     reduce using rule 58 (loop -> whileLoop .)
    STRING_VALUE    reduce using rule 58 (loop -> whileLoop .)
    (               reduce using rule 58 (loop -> whileLoop .)
    UNARY           reduce using rule 58 (loop -> whileLoop .)
    INT             reduce using rule 58 (loop -> whileLoop .)
    FLOAT           reduce using rule 58 (loop -> whileLoop .)
    STRING          reduce using rule 58 (loop -> whileLoop .)
    ADAPT           reduce using rule 58 (loop -> whileLoop .)
    VOID            reduce using rule 58 (loop -> whileLoop .)


state 34

    (24) datatype -> INT .

    IDENTIFIER      reduce using rule 24 (datatype -> INT .)
    {               reduce using rule 24 (datatype -> INT .)


state 35

    (25) datatype -> FLOAT .

    IDENTIFIER      reduce using rule 25 (datatype -> FLOAT .)
    {               reduce using rule 25 (datatype -> FLOAT .)


state 36

    (26) datatype -> STRING .

    IDENTIFIER      reduce using rule 26 (datatype -> STRING .)
    {               reduce using rule 26 (datatype -> STRING .)


state 37

    (27) datatype -> ADAPT .

    IDENTIFIER      reduce using rule 27 (datatype -> ADAPT .)
    {               reduce using rule 27 (datatype -> ADAPT .)


state 38

    (28) datatype -> VOID .

    IDENTIFIER      reduce using rule 28 (datatype -> VOID .)
    {               reduce using rule 28 (datatype -> VOID .)


state 39

    (59) forLoop -> FOR . ( expression ; condition ; expression ) { statements }

    (               shift and go to state 65


state 40

    (60) whileLoop -> WHILE . ( condition ) { statements }

    (               shift and go to state 66


state 41

    (37) paren_expr -> ( expression . )

    )               shift and go to state 67


state 42

    (36) variable -> IDENTIFIER .

    ADD             reduce using rule 36 (variable -> IDENTIFIER .)
    SUB             reduce using rule 36 (variable -> IDENTIFIER .)
    MUL             reduce using rule 36 (variable -> IDENTIFIER .)
    DIV             reduce using rule 36 (variable -> IDENTIFIER .)
    OR              reduce using rule 36 (variable -> IDENTIFIER .)
    LE              reduce using rule 36 (variable -> IDENTIFIER .)
    GE              reduce using rule 36 (variable -> IDENTIFIER .)
    EQ              reduce using rule 36 (variable -> IDENTIFIER .)
    NE              reduce using rule 36 (variable -> IDENTIFIER .)
    GT              reduce using rule 36 (variable -> IDENTIFIER .)
    LT              reduce using rule 36 (variable -> IDENTIFIER .)
    UNARY           reduce using rule 36 (variable -> IDENTIFIER .)
    )               reduce using rule 36 (variable -> IDENTIFIER .)
    }               reduce using rule 36 (variable -> IDENTIFIER .)
    RETURN          reduce using rule 36 (variable -> IDENTIFIER .)
    PRINT           reduce using rule 36 (variable -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 36 (variable -> IDENTIFIER .)
    IF              reduce using rule 36 (variable -> IDENTIFIER .)
    FUNC            reduce using rule 36 (variable -> IDENTIFIER .)
    INT_VALUE       reduce using rule 36 (variable -> IDENTIFIER .)
    FLOAT_VALUE     reduce using rule 36 (variable -> IDENTIFIER .)
    STRING_VALUE    reduce using rule 36 (variable -> IDENTIFIER .)
    (               reduce using rule 36 (variable -> IDENTIFIER .)
    INT             reduce using rule 36 (variable -> IDENTIFIER .)
    FLOAT           reduce using rule 36 (variable -> IDENTIFIER .)
    STRING          reduce using rule 36 (variable -> IDENTIFIER .)
    ADAPT           reduce using rule 36 (variable -> IDENTIFIER .)
    VOID            reduce using rule 36 (variable -> IDENTIFIER .)
    FOR             reduce using rule 36 (variable -> IDENTIFIER .)
    WHILE           reduce using rule 36 (variable -> IDENTIFIER .)
    {               reduce using rule 36 (variable -> IDENTIFIER .)
    ;               reduce using rule 36 (variable -> IDENTIFIER .)


state 43

    (2) programStart -> INIT ( ) { statements } .

    $end            reduce using rule 2 (programStart -> INIT ( ) { statements } .)


state 44

    (4) statements -> statements statement .

    }               reduce using rule 4 (statements -> statements statement .)
    RETURN          reduce using rule 4 (statements -> statements statement .)
    PRINT           reduce using rule 4 (statements -> statements statement .)
    IDENTIFIER      reduce using rule 4 (statements -> statements statement .)
    IF              reduce using rule 4 (statements -> statements statement .)
    FUNC            reduce using rule 4 (statements -> statements statement .)
    INT_VALUE       reduce using rule 4 (statements -> statements statement .)
    FLOAT_VALUE     reduce using rule 4 (statements -> statements statement .)
    STRING_VALUE    reduce using rule 4 (statements -> statements statement .)
    (               reduce using rule 4 (statements -> statements statement .)
    UNARY           reduce using rule 4 (statements -> statements statement .)
    INT             reduce using rule 4 (statements -> statements statement .)
    FLOAT           reduce using rule 4 (statements -> statements statement .)
    STRING          reduce using rule 4 (statements -> statements statement .)
    ADAPT           reduce using rule 4 (statements -> statements statement .)
    VOID            reduce using rule 4 (statements -> statements statement .)
    FOR             reduce using rule 4 (statements -> statements statement .)
    WHILE           reduce using rule 4 (statements -> statements statement .)


state 45

    (10) statement -> RETURN expression .

    }               reduce using rule 10 (statement -> RETURN expression .)
    RETURN          reduce using rule 10 (statement -> RETURN expression .)
    PRINT           reduce using rule 10 (statement -> RETURN expression .)
    IDENTIFIER      reduce using rule 10 (statement -> RETURN expression .)
    IF              reduce using rule 10 (statement -> RETURN expression .)
    FUNC            reduce using rule 10 (statement -> RETURN expression .)
    INT_VALUE       reduce using rule 10 (statement -> RETURN expression .)
    FLOAT_VALUE     reduce using rule 10 (statement -> RETURN expression .)
    STRING_VALUE    reduce using rule 10 (statement -> RETURN expression .)
    (               reduce using rule 10 (statement -> RETURN expression .)
    UNARY           reduce using rule 10 (statement -> RETURN expression .)
    INT             reduce using rule 10 (statement -> RETURN expression .)
    FLOAT           reduce using rule 10 (statement -> RETURN expression .)
    STRING          reduce using rule 10 (statement -> RETURN expression .)
    ADAPT           reduce using rule 10 (statement -> RETURN expression .)
    VOID            reduce using rule 10 (statement -> RETURN expression .)
    FOR             reduce using rule 10 (statement -> RETURN expression .)
    WHILE           reduce using rule 10 (statement -> RETURN expression .)


state 46

    (11) statement -> PRINT ( . expression )
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (36) variable -> . IDENTIFIER

    INT_VALUE       shift and go to state 27
    FLOAT_VALUE     shift and go to state 28
    STRING_VALUE    shift and go to state 29
    (               shift and go to state 7
    UNARY           shift and go to state 31
    IDENTIFIER      shift and go to state 42

    expression                     shift and go to state 68
    atoms                          shift and go to state 21
    paren_expr                     shift and go to state 22
    binary_expr                    shift and go to state 23
    variable                       shift and go to state 30

state 47

    (16) function_calls -> IDENTIFIER ( . )
    (17) function_calls -> IDENTIFIER ( . ) function_calls
    (18) function_calls -> IDENTIFIER ( . parameters )
    (19) function_calls -> IDENTIFIER ( . parameters ) function_calls
    (20) parameters -> . parameterList
    (21) parameterList -> . parameter
    (22) parameterList -> . parameter , parameterList
    (23) parameter -> . datatype IDENTIFIER
    (24) datatype -> . INT
    (25) datatype -> . FLOAT
    (26) datatype -> . STRING
    (27) datatype -> . ADAPT
    (28) datatype -> . VOID

    )               shift and go to state 69
    INT             shift and go to state 34
    FLOAT           shift and go to state 35
    STRING          shift and go to state 36
    ADAPT           shift and go to state 37
    VOID            shift and go to state 38

    parameters                     shift and go to state 70
    parameterList                  shift and go to state 71
    parameter                      shift and go to state 72
    datatype                       shift and go to state 73

state 48

    (53) condition -> IF expression . { statements }
    (54) condition -> IF expression . { statements } ELSE { statements }

    {               shift and go to state 74


state 49

    (38) binary_expr -> atoms ADD . expression
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (36) variable -> . IDENTIFIER

    INT_VALUE       shift and go to state 27
    FLOAT_VALUE     shift and go to state 28
    STRING_VALUE    shift and go to state 29
    (               shift and go to state 7
    UNARY           shift and go to state 31
    IDENTIFIER      shift and go to state 42

    atoms                          shift and go to state 21
    expression                     shift and go to state 75
    paren_expr                     shift and go to state 22
    binary_expr                    shift and go to state 23
    variable                       shift and go to state 30

state 50

    (39) binary_expr -> atoms SUB . expression
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (36) variable -> . IDENTIFIER

    INT_VALUE       shift and go to state 27
    FLOAT_VALUE     shift and go to state 28
    STRING_VALUE    shift and go to state 29
    (               shift and go to state 7
    UNARY           shift and go to state 31
    IDENTIFIER      shift and go to state 42

    atoms                          shift and go to state 21
    expression                     shift and go to state 76
    paren_expr                     shift and go to state 22
    binary_expr                    shift and go to state 23
    variable                       shift and go to state 30

state 51

    (40) binary_expr -> atoms MUL . expression
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (36) variable -> . IDENTIFIER

    INT_VALUE       shift and go to state 27
    FLOAT_VALUE     shift and go to state 28
    STRING_VALUE    shift and go to state 29
    (               shift and go to state 7
    UNARY           shift and go to state 31
    IDENTIFIER      shift and go to state 42

    atoms                          shift and go to state 21
    expression                     shift and go to state 77
    paren_expr                     shift and go to state 22
    binary_expr                    shift and go to state 23
    variable                       shift and go to state 30

state 52

    (41) binary_expr -> atoms DIV . expression
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (36) variable -> . IDENTIFIER

    INT_VALUE       shift and go to state 27
    FLOAT_VALUE     shift and go to state 28
    STRING_VALUE    shift and go to state 29
    (               shift and go to state 7
    UNARY           shift and go to state 31
    IDENTIFIER      shift and go to state 42

    atoms                          shift and go to state 21
    expression                     shift and go to state 78
    paren_expr                     shift and go to state 22
    binary_expr                    shift and go to state 23
    variable                       shift and go to state 30

state 53

    (42) binary_expr -> atoms OR . expression
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (36) variable -> . IDENTIFIER

    INT_VALUE       shift and go to state 27
    FLOAT_VALUE     shift and go to state 28
    STRING_VALUE    shift and go to state 29
    (               shift and go to state 7
    UNARY           shift and go to state 31
    IDENTIFIER      shift and go to state 42

    atoms                          shift and go to state 21
    expression                     shift and go to state 79
    paren_expr                     shift and go to state 22
    binary_expr                    shift and go to state 23
    variable                       shift and go to state 30

state 54

    (43) binary_expr -> atoms LE . expression
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (36) variable -> . IDENTIFIER

    INT_VALUE       shift and go to state 27
    FLOAT_VALUE     shift and go to state 28
    STRING_VALUE    shift and go to state 29
    (               shift and go to state 7
    UNARY           shift and go to state 31
    IDENTIFIER      shift and go to state 42

    atoms                          shift and go to state 21
    expression                     shift and go to state 80
    paren_expr                     shift and go to state 22
    binary_expr                    shift and go to state 23
    variable                       shift and go to state 30

state 55

    (44) binary_expr -> atoms GE . expression
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (36) variable -> . IDENTIFIER

    INT_VALUE       shift and go to state 27
    FLOAT_VALUE     shift and go to state 28
    STRING_VALUE    shift and go to state 29
    (               shift and go to state 7
    UNARY           shift and go to state 31
    IDENTIFIER      shift and go to state 42

    atoms                          shift and go to state 21
    expression                     shift and go to state 81
    paren_expr                     shift and go to state 22
    binary_expr                    shift and go to state 23
    variable                       shift and go to state 30

state 56

    (45) binary_expr -> atoms EQ . expression
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (36) variable -> . IDENTIFIER

    INT_VALUE       shift and go to state 27
    FLOAT_VALUE     shift and go to state 28
    STRING_VALUE    shift and go to state 29
    (               shift and go to state 7
    UNARY           shift and go to state 31
    IDENTIFIER      shift and go to state 42

    atoms                          shift and go to state 21
    expression                     shift and go to state 82
    paren_expr                     shift and go to state 22
    binary_expr                    shift and go to state 23
    variable                       shift and go to state 30

state 57

    (46) binary_expr -> atoms NE . expression
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (36) variable -> . IDENTIFIER

    INT_VALUE       shift and go to state 27
    FLOAT_VALUE     shift and go to state 28
    STRING_VALUE    shift and go to state 29
    (               shift and go to state 7
    UNARY           shift and go to state 31
    IDENTIFIER      shift and go to state 42

    atoms                          shift and go to state 21
    expression                     shift and go to state 83
    paren_expr                     shift and go to state 22
    binary_expr                    shift and go to state 23
    variable                       shift and go to state 30

state 58

    (47) binary_expr -> atoms GT . expression
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (36) variable -> . IDENTIFIER

    INT_VALUE       shift and go to state 27
    FLOAT_VALUE     shift and go to state 28
    STRING_VALUE    shift and go to state 29
    (               shift and go to state 7
    UNARY           shift and go to state 31
    IDENTIFIER      shift and go to state 42

    atoms                          shift and go to state 21
    expression                     shift and go to state 84
    paren_expr                     shift and go to state 22
    binary_expr                    shift and go to state 23
    variable                       shift and go to state 30

state 59

    (48) binary_expr -> atoms LT . expression
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (36) variable -> . IDENTIFIER

    INT_VALUE       shift and go to state 27
    FLOAT_VALUE     shift and go to state 28
    STRING_VALUE    shift and go to state 29
    (               shift and go to state 7
    UNARY           shift and go to state 31
    IDENTIFIER      shift and go to state 42

    atoms                          shift and go to state 21
    expression                     shift and go to state 85
    paren_expr                     shift and go to state 22
    binary_expr                    shift and go to state 23
    variable                       shift and go to state 30

state 60

    (50) binary_expr -> atoms UNARY .

    }               reduce using rule 50 (binary_expr -> atoms UNARY .)
    RETURN          reduce using rule 50 (binary_expr -> atoms UNARY .)
    PRINT           reduce using rule 50 (binary_expr -> atoms UNARY .)
    IDENTIFIER      reduce using rule 50 (binary_expr -> atoms UNARY .)
    IF              reduce using rule 50 (binary_expr -> atoms UNARY .)
    FUNC            reduce using rule 50 (binary_expr -> atoms UNARY .)
    INT_VALUE       reduce using rule 50 (binary_expr -> atoms UNARY .)
    FLOAT_VALUE     reduce using rule 50 (binary_expr -> atoms UNARY .)
    STRING_VALUE    reduce using rule 50 (binary_expr -> atoms UNARY .)
    (               reduce using rule 50 (binary_expr -> atoms UNARY .)
    UNARY           reduce using rule 50 (binary_expr -> atoms UNARY .)
    INT             reduce using rule 50 (binary_expr -> atoms UNARY .)
    FLOAT           reduce using rule 50 (binary_expr -> atoms UNARY .)
    STRING          reduce using rule 50 (binary_expr -> atoms UNARY .)
    ADAPT           reduce using rule 50 (binary_expr -> atoms UNARY .)
    VOID            reduce using rule 50 (binary_expr -> atoms UNARY .)
    FOR             reduce using rule 50 (binary_expr -> atoms UNARY .)
    WHILE           reduce using rule 50 (binary_expr -> atoms UNARY .)
    )               reduce using rule 50 (binary_expr -> atoms UNARY .)
    {               reduce using rule 50 (binary_expr -> atoms UNARY .)
    ;               reduce using rule 50 (binary_expr -> atoms UNARY .)


state 61

    (56) loops -> loop loops .

    }               reduce using rule 56 (loops -> loop loops .)
    RETURN          reduce using rule 56 (loops -> loop loops .)
    PRINT           reduce using rule 56 (loops -> loop loops .)
    IDENTIFIER      reduce using rule 56 (loops -> loop loops .)
    IF              reduce using rule 56 (loops -> loop loops .)
    FUNC            reduce using rule 56 (loops -> loop loops .)
    INT_VALUE       reduce using rule 56 (loops -> loop loops .)
    FLOAT_VALUE     reduce using rule 56 (loops -> loop loops .)
    STRING_VALUE    reduce using rule 56 (loops -> loop loops .)
    (               reduce using rule 56 (loops -> loop loops .)
    UNARY           reduce using rule 56 (loops -> loop loops .)
    INT             reduce using rule 56 (loops -> loop loops .)
    FLOAT           reduce using rule 56 (loops -> loop loops .)
    STRING          reduce using rule 56 (loops -> loop loops .)
    ADAPT           reduce using rule 56 (loops -> loop loops .)
    VOID            reduce using rule 56 (loops -> loop loops .)
    FOR             reduce using rule 56 (loops -> loop loops .)
    WHILE           reduce using rule 56 (loops -> loop loops .)


state 62

    (51) assignment -> datatype IDENTIFIER . EQUAL expression
    (52) assignment -> datatype IDENTIFIER . EQUAL ACCEPT ( )

    EQUAL           shift and go to state 86


state 63

    (14) function_declaration -> FUNC IDENTIFIER . ( ) : datatype { function_body }

    (               shift and go to state 87


state 64

    (49) binary_expr -> UNARY atoms .

    }               reduce using rule 49 (binary_expr -> UNARY atoms .)
    RETURN          reduce using rule 49 (binary_expr -> UNARY atoms .)
    PRINT           reduce using rule 49 (binary_expr -> UNARY atoms .)
    IDENTIFIER      reduce using rule 49 (binary_expr -> UNARY atoms .)
    IF              reduce using rule 49 (binary_expr -> UNARY atoms .)
    FUNC            reduce using rule 49 (binary_expr -> UNARY atoms .)
    INT_VALUE       reduce using rule 49 (binary_expr -> UNARY atoms .)
    FLOAT_VALUE     reduce using rule 49 (binary_expr -> UNARY atoms .)
    STRING_VALUE    reduce using rule 49 (binary_expr -> UNARY atoms .)
    (               reduce using rule 49 (binary_expr -> UNARY atoms .)
    UNARY           reduce using rule 49 (binary_expr -> UNARY atoms .)
    INT             reduce using rule 49 (binary_expr -> UNARY atoms .)
    FLOAT           reduce using rule 49 (binary_expr -> UNARY atoms .)
    STRING          reduce using rule 49 (binary_expr -> UNARY atoms .)
    ADAPT           reduce using rule 49 (binary_expr -> UNARY atoms .)
    VOID            reduce using rule 49 (binary_expr -> UNARY atoms .)
    FOR             reduce using rule 49 (binary_expr -> UNARY atoms .)
    WHILE           reduce using rule 49 (binary_expr -> UNARY atoms .)
    )               reduce using rule 49 (binary_expr -> UNARY atoms .)
    {               reduce using rule 49 (binary_expr -> UNARY atoms .)
    ;               reduce using rule 49 (binary_expr -> UNARY atoms .)


state 65

    (59) forLoop -> FOR ( . expression ; condition ; expression ) { statements }
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (36) variable -> . IDENTIFIER

    INT_VALUE       shift and go to state 27
    FLOAT_VALUE     shift and go to state 28
    STRING_VALUE    shift and go to state 29
    (               shift and go to state 7
    UNARY           shift and go to state 31
    IDENTIFIER      shift and go to state 42

    expression                     shift and go to state 88
    atoms                          shift and go to state 21
    paren_expr                     shift and go to state 22
    binary_expr                    shift and go to state 23
    variable                       shift and go to state 30

state 66

    (60) whileLoop -> WHILE ( . condition ) { statements }
    (53) condition -> . IF expression { statements }
    (54) condition -> . IF expression { statements } ELSE { statements }

    IF              shift and go to state 19

    condition                      shift and go to state 89

state 67

    (37) paren_expr -> ( expression ) .

    }               reduce using rule 37 (paren_expr -> ( expression ) .)
    RETURN          reduce using rule 37 (paren_expr -> ( expression ) .)
    PRINT           reduce using rule 37 (paren_expr -> ( expression ) .)
    IDENTIFIER      reduce using rule 37 (paren_expr -> ( expression ) .)
    IF              reduce using rule 37 (paren_expr -> ( expression ) .)
    FUNC            reduce using rule 37 (paren_expr -> ( expression ) .)
    INT_VALUE       reduce using rule 37 (paren_expr -> ( expression ) .)
    FLOAT_VALUE     reduce using rule 37 (paren_expr -> ( expression ) .)
    STRING_VALUE    reduce using rule 37 (paren_expr -> ( expression ) .)
    (               reduce using rule 37 (paren_expr -> ( expression ) .)
    UNARY           reduce using rule 37 (paren_expr -> ( expression ) .)
    INT             reduce using rule 37 (paren_expr -> ( expression ) .)
    FLOAT           reduce using rule 37 (paren_expr -> ( expression ) .)
    STRING          reduce using rule 37 (paren_expr -> ( expression ) .)
    ADAPT           reduce using rule 37 (paren_expr -> ( expression ) .)
    VOID            reduce using rule 37 (paren_expr -> ( expression ) .)
    FOR             reduce using rule 37 (paren_expr -> ( expression ) .)
    WHILE           reduce using rule 37 (paren_expr -> ( expression ) .)
    )               reduce using rule 37 (paren_expr -> ( expression ) .)
    {               reduce using rule 37 (paren_expr -> ( expression ) .)
    ;               reduce using rule 37 (paren_expr -> ( expression ) .)


state 68

    (11) statement -> PRINT ( expression . )

    )               shift and go to state 90


state 69

    (16) function_calls -> IDENTIFIER ( ) .
    (17) function_calls -> IDENTIFIER ( ) . function_calls
    (16) function_calls -> . IDENTIFIER ( )
    (17) function_calls -> . IDENTIFIER ( ) function_calls
    (18) function_calls -> . IDENTIFIER ( parameters )
    (19) function_calls -> . IDENTIFIER ( parameters ) function_calls

  ! shift/reduce conflict for IDENTIFIER resolved as shift
    }               reduce using rule 16 (function_calls -> IDENTIFIER ( ) .)
    RETURN          reduce using rule 16 (function_calls -> IDENTIFIER ( ) .)
    PRINT           reduce using rule 16 (function_calls -> IDENTIFIER ( ) .)
    IF              reduce using rule 16 (function_calls -> IDENTIFIER ( ) .)
    FUNC            reduce using rule 16 (function_calls -> IDENTIFIER ( ) .)
    INT_VALUE       reduce using rule 16 (function_calls -> IDENTIFIER ( ) .)
    FLOAT_VALUE     reduce using rule 16 (function_calls -> IDENTIFIER ( ) .)
    STRING_VALUE    reduce using rule 16 (function_calls -> IDENTIFIER ( ) .)
    (               reduce using rule 16 (function_calls -> IDENTIFIER ( ) .)
    UNARY           reduce using rule 16 (function_calls -> IDENTIFIER ( ) .)
    INT             reduce using rule 16 (function_calls -> IDENTIFIER ( ) .)
    FLOAT           reduce using rule 16 (function_calls -> IDENTIFIER ( ) .)
    STRING          reduce using rule 16 (function_calls -> IDENTIFIER ( ) .)
    ADAPT           reduce using rule 16 (function_calls -> IDENTIFIER ( ) .)
    VOID            reduce using rule 16 (function_calls -> IDENTIFIER ( ) .)
    FOR             reduce using rule 16 (function_calls -> IDENTIFIER ( ) .)
    WHILE           reduce using rule 16 (function_calls -> IDENTIFIER ( ) .)
    IDENTIFIER      shift and go to state 91

  ! IDENTIFIER      [ reduce using rule 16 (function_calls -> IDENTIFIER ( ) .) ]

    function_calls                 shift and go to state 92

state 70

    (18) function_calls -> IDENTIFIER ( parameters . )
    (19) function_calls -> IDENTIFIER ( parameters . ) function_calls

    )               shift and go to state 93


state 71

    (20) parameters -> parameterList .

    )               reduce using rule 20 (parameters -> parameterList .)


state 72

    (21) parameterList -> parameter .
    (22) parameterList -> parameter . , parameterList

    )               reduce using rule 21 (parameterList -> parameter .)
    ,               shift and go to state 94


state 73

    (23) parameter -> datatype . IDENTIFIER

    IDENTIFIER      shift and go to state 95


state 74

    (53) condition -> IF expression { . statements }
    (54) condition -> IF expression { . statements } ELSE { statements }
    (3) statements -> . statement
    (4) statements -> . statements statement
    (5) statement -> . function_calls
    (6) statement -> . condition
    (7) statement -> . function_declarations
    (8) statement -> . expression
    (9) statement -> . loops
    (10) statement -> . RETURN expression
    (11) statement -> . PRINT ( expression )
    (12) statement -> . assignment
    (16) function_calls -> . IDENTIFIER ( )
    (17) function_calls -> . IDENTIFIER ( ) function_calls
    (18) function_calls -> . IDENTIFIER ( parameters )
    (19) function_calls -> . IDENTIFIER ( parameters ) function_calls
    (53) condition -> . IF expression { statements }
    (54) condition -> . IF expression { statements } ELSE { statements }
    (13) function_declarations -> . function_declaration
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (55) loops -> . loop
    (56) loops -> . loop loops
    (51) assignment -> . datatype IDENTIFIER EQUAL expression
    (52) assignment -> . datatype IDENTIFIER EQUAL ACCEPT ( )
    (14) function_declaration -> . FUNC IDENTIFIER ( ) : datatype { function_body }
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (57) loop -> . forLoop
    (58) loop -> . whileLoop
    (24) datatype -> . INT
    (25) datatype -> . FLOAT
    (26) datatype -> . STRING
    (27) datatype -> . ADAPT
    (28) datatype -> . VOID
    (36) variable -> . IDENTIFIER
    (59) forLoop -> . FOR ( expression ; condition ; expression ) { statements }
    (60) whileLoop -> . WHILE ( condition ) { statements }

    RETURN          shift and go to state 15
    PRINT           shift and go to state 16
    IDENTIFIER      shift and go to state 18
    IF              shift and go to state 19
    FUNC            shift and go to state 26
    INT_VALUE       shift and go to state 27
    FLOAT_VALUE     shift and go to state 28
    STRING_VALUE    shift and go to state 29
    (               shift and go to state 7
    UNARY           shift and go to state 31
    INT             shift and go to state 34
    FLOAT           shift and go to state 35
    STRING          shift and go to state 36
    ADAPT           shift and go to state 37
    VOID            shift and go to state 38
    FOR             shift and go to state 39
    WHILE           shift and go to state 40

    expression                     shift and go to state 13
    statements                     shift and go to state 96
    statement                      shift and go to state 9
    function_calls                 shift and go to state 10
    condition                      shift and go to state 11
    function_declarations          shift and go to state 12
    loops                          shift and go to state 14
    assignment                     shift and go to state 17
    function_declaration           shift and go to state 20
    atoms                          shift and go to state 21
    paren_expr                     shift and go to state 22
    binary_expr                    shift and go to state 23
    loop                           shift and go to state 24
    datatype                       shift and go to state 25
    variable                       shift and go to state 30
    forLoop                        shift and go to state 32
    whileLoop                      shift and go to state 33

state 75

    (38) binary_expr -> atoms ADD expression .

    }               reduce using rule 38 (binary_expr -> atoms ADD expression .)
    RETURN          reduce using rule 38 (binary_expr -> atoms ADD expression .)
    PRINT           reduce using rule 38 (binary_expr -> atoms ADD expression .)
    IDENTIFIER      reduce using rule 38 (binary_expr -> atoms ADD expression .)
    IF              reduce using rule 38 (binary_expr -> atoms ADD expression .)
    FUNC            reduce using rule 38 (binary_expr -> atoms ADD expression .)
    INT_VALUE       reduce using rule 38 (binary_expr -> atoms ADD expression .)
    FLOAT_VALUE     reduce using rule 38 (binary_expr -> atoms ADD expression .)
    STRING_VALUE    reduce using rule 38 (binary_expr -> atoms ADD expression .)
    (               reduce using rule 38 (binary_expr -> atoms ADD expression .)
    UNARY           reduce using rule 38 (binary_expr -> atoms ADD expression .)
    INT             reduce using rule 38 (binary_expr -> atoms ADD expression .)
    FLOAT           reduce using rule 38 (binary_expr -> atoms ADD expression .)
    STRING          reduce using rule 38 (binary_expr -> atoms ADD expression .)
    ADAPT           reduce using rule 38 (binary_expr -> atoms ADD expression .)
    VOID            reduce using rule 38 (binary_expr -> atoms ADD expression .)
    FOR             reduce using rule 38 (binary_expr -> atoms ADD expression .)
    WHILE           reduce using rule 38 (binary_expr -> atoms ADD expression .)
    )               reduce using rule 38 (binary_expr -> atoms ADD expression .)
    {               reduce using rule 38 (binary_expr -> atoms ADD expression .)
    ;               reduce using rule 38 (binary_expr -> atoms ADD expression .)


state 76

    (39) binary_expr -> atoms SUB expression .

    }               reduce using rule 39 (binary_expr -> atoms SUB expression .)
    RETURN          reduce using rule 39 (binary_expr -> atoms SUB expression .)
    PRINT           reduce using rule 39 (binary_expr -> atoms SUB expression .)
    IDENTIFIER      reduce using rule 39 (binary_expr -> atoms SUB expression .)
    IF              reduce using rule 39 (binary_expr -> atoms SUB expression .)
    FUNC            reduce using rule 39 (binary_expr -> atoms SUB expression .)
    INT_VALUE       reduce using rule 39 (binary_expr -> atoms SUB expression .)
    FLOAT_VALUE     reduce using rule 39 (binary_expr -> atoms SUB expression .)
    STRING_VALUE    reduce using rule 39 (binary_expr -> atoms SUB expression .)
    (               reduce using rule 39 (binary_expr -> atoms SUB expression .)
    UNARY           reduce using rule 39 (binary_expr -> atoms SUB expression .)
    INT             reduce using rule 39 (binary_expr -> atoms SUB expression .)
    FLOAT           reduce using rule 39 (binary_expr -> atoms SUB expression .)
    STRING          reduce using rule 39 (binary_expr -> atoms SUB expression .)
    ADAPT           reduce using rule 39 (binary_expr -> atoms SUB expression .)
    VOID            reduce using rule 39 (binary_expr -> atoms SUB expression .)
    FOR             reduce using rule 39 (binary_expr -> atoms SUB expression .)
    WHILE           reduce using rule 39 (binary_expr -> atoms SUB expression .)
    )               reduce using rule 39 (binary_expr -> atoms SUB expression .)
    {               reduce using rule 39 (binary_expr -> atoms SUB expression .)
    ;               reduce using rule 39 (binary_expr -> atoms SUB expression .)


state 77

    (40) binary_expr -> atoms MUL expression .

    }               reduce using rule 40 (binary_expr -> atoms MUL expression .)
    RETURN          reduce using rule 40 (binary_expr -> atoms MUL expression .)
    PRINT           reduce using rule 40 (binary_expr -> atoms MUL expression .)
    IDENTIFIER      reduce using rule 40 (binary_expr -> atoms MUL expression .)
    IF              reduce using rule 40 (binary_expr -> atoms MUL expression .)
    FUNC            reduce using rule 40 (binary_expr -> atoms MUL expression .)
    INT_VALUE       reduce using rule 40 (binary_expr -> atoms MUL expression .)
    FLOAT_VALUE     reduce using rule 40 (binary_expr -> atoms MUL expression .)
    STRING_VALUE    reduce using rule 40 (binary_expr -> atoms MUL expression .)
    (               reduce using rule 40 (binary_expr -> atoms MUL expression .)
    UNARY           reduce using rule 40 (binary_expr -> atoms MUL expression .)
    INT             reduce using rule 40 (binary_expr -> atoms MUL expression .)
    FLOAT           reduce using rule 40 (binary_expr -> atoms MUL expression .)
    STRING          reduce using rule 40 (binary_expr -> atoms MUL expression .)
    ADAPT           reduce using rule 40 (binary_expr -> atoms MUL expression .)
    VOID            reduce using rule 40 (binary_expr -> atoms MUL expression .)
    FOR             reduce using rule 40 (binary_expr -> atoms MUL expression .)
    WHILE           reduce using rule 40 (binary_expr -> atoms MUL expression .)
    )               reduce using rule 40 (binary_expr -> atoms MUL expression .)
    {               reduce using rule 40 (binary_expr -> atoms MUL expression .)
    ;               reduce using rule 40 (binary_expr -> atoms MUL expression .)


state 78

    (41) binary_expr -> atoms DIV expression .

    }               reduce using rule 41 (binary_expr -> atoms DIV expression .)
    RETURN          reduce using rule 41 (binary_expr -> atoms DIV expression .)
    PRINT           reduce using rule 41 (binary_expr -> atoms DIV expression .)
    IDENTIFIER      reduce using rule 41 (binary_expr -> atoms DIV expression .)
    IF              reduce using rule 41 (binary_expr -> atoms DIV expression .)
    FUNC            reduce using rule 41 (binary_expr -> atoms DIV expression .)
    INT_VALUE       reduce using rule 41 (binary_expr -> atoms DIV expression .)
    FLOAT_VALUE     reduce using rule 41 (binary_expr -> atoms DIV expression .)
    STRING_VALUE    reduce using rule 41 (binary_expr -> atoms DIV expression .)
    (               reduce using rule 41 (binary_expr -> atoms DIV expression .)
    UNARY           reduce using rule 41 (binary_expr -> atoms DIV expression .)
    INT             reduce using rule 41 (binary_expr -> atoms DIV expression .)
    FLOAT           reduce using rule 41 (binary_expr -> atoms DIV expression .)
    STRING          reduce using rule 41 (binary_expr -> atoms DIV expression .)
    ADAPT           reduce using rule 41 (binary_expr -> atoms DIV expression .)
    VOID            reduce using rule 41 (binary_expr -> atoms DIV expression .)
    FOR             reduce using rule 41 (binary_expr -> atoms DIV expression .)
    WHILE           reduce using rule 41 (binary_expr -> atoms DIV expression .)
    )               reduce using rule 41 (binary_expr -> atoms DIV expression .)
    {               reduce using rule 41 (binary_expr -> atoms DIV expression .)
    ;               reduce using rule 41 (binary_expr -> atoms DIV expression .)


state 79

    (42) binary_expr -> atoms OR expression .

    }               reduce using rule 42 (binary_expr -> atoms OR expression .)
    RETURN          reduce using rule 42 (binary_expr -> atoms OR expression .)
    PRINT           reduce using rule 42 (binary_expr -> atoms OR expression .)
    IDENTIFIER      reduce using rule 42 (binary_expr -> atoms OR expression .)
    IF              reduce using rule 42 (binary_expr -> atoms OR expression .)
    FUNC            reduce using rule 42 (binary_expr -> atoms OR expression .)
    INT_VALUE       reduce using rule 42 (binary_expr -> atoms OR expression .)
    FLOAT_VALUE     reduce using rule 42 (binary_expr -> atoms OR expression .)
    STRING_VALUE    reduce using rule 42 (binary_expr -> atoms OR expression .)
    (               reduce using rule 42 (binary_expr -> atoms OR expression .)
    UNARY           reduce using rule 42 (binary_expr -> atoms OR expression .)
    INT             reduce using rule 42 (binary_expr -> atoms OR expression .)
    FLOAT           reduce using rule 42 (binary_expr -> atoms OR expression .)
    STRING          reduce using rule 42 (binary_expr -> atoms OR expression .)
    ADAPT           reduce using rule 42 (binary_expr -> atoms OR expression .)
    VOID            reduce using rule 42 (binary_expr -> atoms OR expression .)
    FOR             reduce using rule 42 (binary_expr -> atoms OR expression .)
    WHILE           reduce using rule 42 (binary_expr -> atoms OR expression .)
    )               reduce using rule 42 (binary_expr -> atoms OR expression .)
    {               reduce using rule 42 (binary_expr -> atoms OR expression .)
    ;               reduce using rule 42 (binary_expr -> atoms OR expression .)


state 80

    (43) binary_expr -> atoms LE expression .

    }               reduce using rule 43 (binary_expr -> atoms LE expression .)
    RETURN          reduce using rule 43 (binary_expr -> atoms LE expression .)
    PRINT           reduce using rule 43 (binary_expr -> atoms LE expression .)
    IDENTIFIER      reduce using rule 43 (binary_expr -> atoms LE expression .)
    IF              reduce using rule 43 (binary_expr -> atoms LE expression .)
    FUNC            reduce using rule 43 (binary_expr -> atoms LE expression .)
    INT_VALUE       reduce using rule 43 (binary_expr -> atoms LE expression .)
    FLOAT_VALUE     reduce using rule 43 (binary_expr -> atoms LE expression .)
    STRING_VALUE    reduce using rule 43 (binary_expr -> atoms LE expression .)
    (               reduce using rule 43 (binary_expr -> atoms LE expression .)
    UNARY           reduce using rule 43 (binary_expr -> atoms LE expression .)
    INT             reduce using rule 43 (binary_expr -> atoms LE expression .)
    FLOAT           reduce using rule 43 (binary_expr -> atoms LE expression .)
    STRING          reduce using rule 43 (binary_expr -> atoms LE expression .)
    ADAPT           reduce using rule 43 (binary_expr -> atoms LE expression .)
    VOID            reduce using rule 43 (binary_expr -> atoms LE expression .)
    FOR             reduce using rule 43 (binary_expr -> atoms LE expression .)
    WHILE           reduce using rule 43 (binary_expr -> atoms LE expression .)
    )               reduce using rule 43 (binary_expr -> atoms LE expression .)
    {               reduce using rule 43 (binary_expr -> atoms LE expression .)
    ;               reduce using rule 43 (binary_expr -> atoms LE expression .)


state 81

    (44) binary_expr -> atoms GE expression .

    }               reduce using rule 44 (binary_expr -> atoms GE expression .)
    RETURN          reduce using rule 44 (binary_expr -> atoms GE expression .)
    PRINT           reduce using rule 44 (binary_expr -> atoms GE expression .)
    IDENTIFIER      reduce using rule 44 (binary_expr -> atoms GE expression .)
    IF              reduce using rule 44 (binary_expr -> atoms GE expression .)
    FUNC            reduce using rule 44 (binary_expr -> atoms GE expression .)
    INT_VALUE       reduce using rule 44 (binary_expr -> atoms GE expression .)
    FLOAT_VALUE     reduce using rule 44 (binary_expr -> atoms GE expression .)
    STRING_VALUE    reduce using rule 44 (binary_expr -> atoms GE expression .)
    (               reduce using rule 44 (binary_expr -> atoms GE expression .)
    UNARY           reduce using rule 44 (binary_expr -> atoms GE expression .)
    INT             reduce using rule 44 (binary_expr -> atoms GE expression .)
    FLOAT           reduce using rule 44 (binary_expr -> atoms GE expression .)
    STRING          reduce using rule 44 (binary_expr -> atoms GE expression .)
    ADAPT           reduce using rule 44 (binary_expr -> atoms GE expression .)
    VOID            reduce using rule 44 (binary_expr -> atoms GE expression .)
    FOR             reduce using rule 44 (binary_expr -> atoms GE expression .)
    WHILE           reduce using rule 44 (binary_expr -> atoms GE expression .)
    )               reduce using rule 44 (binary_expr -> atoms GE expression .)
    {               reduce using rule 44 (binary_expr -> atoms GE expression .)
    ;               reduce using rule 44 (binary_expr -> atoms GE expression .)


state 82

    (45) binary_expr -> atoms EQ expression .

    }               reduce using rule 45 (binary_expr -> atoms EQ expression .)
    RETURN          reduce using rule 45 (binary_expr -> atoms EQ expression .)
    PRINT           reduce using rule 45 (binary_expr -> atoms EQ expression .)
    IDENTIFIER      reduce using rule 45 (binary_expr -> atoms EQ expression .)
    IF              reduce using rule 45 (binary_expr -> atoms EQ expression .)
    FUNC            reduce using rule 45 (binary_expr -> atoms EQ expression .)
    INT_VALUE       reduce using rule 45 (binary_expr -> atoms EQ expression .)
    FLOAT_VALUE     reduce using rule 45 (binary_expr -> atoms EQ expression .)
    STRING_VALUE    reduce using rule 45 (binary_expr -> atoms EQ expression .)
    (               reduce using rule 45 (binary_expr -> atoms EQ expression .)
    UNARY           reduce using rule 45 (binary_expr -> atoms EQ expression .)
    INT             reduce using rule 45 (binary_expr -> atoms EQ expression .)
    FLOAT           reduce using rule 45 (binary_expr -> atoms EQ expression .)
    STRING          reduce using rule 45 (binary_expr -> atoms EQ expression .)
    ADAPT           reduce using rule 45 (binary_expr -> atoms EQ expression .)
    VOID            reduce using rule 45 (binary_expr -> atoms EQ expression .)
    FOR             reduce using rule 45 (binary_expr -> atoms EQ expression .)
    WHILE           reduce using rule 45 (binary_expr -> atoms EQ expression .)
    )               reduce using rule 45 (binary_expr -> atoms EQ expression .)
    {               reduce using rule 45 (binary_expr -> atoms EQ expression .)
    ;               reduce using rule 45 (binary_expr -> atoms EQ expression .)


state 83

    (46) binary_expr -> atoms NE expression .

    }               reduce using rule 46 (binary_expr -> atoms NE expression .)
    RETURN          reduce using rule 46 (binary_expr -> atoms NE expression .)
    PRINT           reduce using rule 46 (binary_expr -> atoms NE expression .)
    IDENTIFIER      reduce using rule 46 (binary_expr -> atoms NE expression .)
    IF              reduce using rule 46 (binary_expr -> atoms NE expression .)
    FUNC            reduce using rule 46 (binary_expr -> atoms NE expression .)
    INT_VALUE       reduce using rule 46 (binary_expr -> atoms NE expression .)
    FLOAT_VALUE     reduce using rule 46 (binary_expr -> atoms NE expression .)
    STRING_VALUE    reduce using rule 46 (binary_expr -> atoms NE expression .)
    (               reduce using rule 46 (binary_expr -> atoms NE expression .)
    UNARY           reduce using rule 46 (binary_expr -> atoms NE expression .)
    INT             reduce using rule 46 (binary_expr -> atoms NE expression .)
    FLOAT           reduce using rule 46 (binary_expr -> atoms NE expression .)
    STRING          reduce using rule 46 (binary_expr -> atoms NE expression .)
    ADAPT           reduce using rule 46 (binary_expr -> atoms NE expression .)
    VOID            reduce using rule 46 (binary_expr -> atoms NE expression .)
    FOR             reduce using rule 46 (binary_expr -> atoms NE expression .)
    WHILE           reduce using rule 46 (binary_expr -> atoms NE expression .)
    )               reduce using rule 46 (binary_expr -> atoms NE expression .)
    {               reduce using rule 46 (binary_expr -> atoms NE expression .)
    ;               reduce using rule 46 (binary_expr -> atoms NE expression .)


state 84

    (47) binary_expr -> atoms GT expression .

    }               reduce using rule 47 (binary_expr -> atoms GT expression .)
    RETURN          reduce using rule 47 (binary_expr -> atoms GT expression .)
    PRINT           reduce using rule 47 (binary_expr -> atoms GT expression .)
    IDENTIFIER      reduce using rule 47 (binary_expr -> atoms GT expression .)
    IF              reduce using rule 47 (binary_expr -> atoms GT expression .)
    FUNC            reduce using rule 47 (binary_expr -> atoms GT expression .)
    INT_VALUE       reduce using rule 47 (binary_expr -> atoms GT expression .)
    FLOAT_VALUE     reduce using rule 47 (binary_expr -> atoms GT expression .)
    STRING_VALUE    reduce using rule 47 (binary_expr -> atoms GT expression .)
    (               reduce using rule 47 (binary_expr -> atoms GT expression .)
    UNARY           reduce using rule 47 (binary_expr -> atoms GT expression .)
    INT             reduce using rule 47 (binary_expr -> atoms GT expression .)
    FLOAT           reduce using rule 47 (binary_expr -> atoms GT expression .)
    STRING          reduce using rule 47 (binary_expr -> atoms GT expression .)
    ADAPT           reduce using rule 47 (binary_expr -> atoms GT expression .)
    VOID            reduce using rule 47 (binary_expr -> atoms GT expression .)
    FOR             reduce using rule 47 (binary_expr -> atoms GT expression .)
    WHILE           reduce using rule 47 (binary_expr -> atoms GT expression .)
    )               reduce using rule 47 (binary_expr -> atoms GT expression .)
    {               reduce using rule 47 (binary_expr -> atoms GT expression .)
    ;               reduce using rule 47 (binary_expr -> atoms GT expression .)


state 85

    (48) binary_expr -> atoms LT expression .

    }               reduce using rule 48 (binary_expr -> atoms LT expression .)
    RETURN          reduce using rule 48 (binary_expr -> atoms LT expression .)
    PRINT           reduce using rule 48 (binary_expr -> atoms LT expression .)
    IDENTIFIER      reduce using rule 48 (binary_expr -> atoms LT expression .)
    IF              reduce using rule 48 (binary_expr -> atoms LT expression .)
    FUNC            reduce using rule 48 (binary_expr -> atoms LT expression .)
    INT_VALUE       reduce using rule 48 (binary_expr -> atoms LT expression .)
    FLOAT_VALUE     reduce using rule 48 (binary_expr -> atoms LT expression .)
    STRING_VALUE    reduce using rule 48 (binary_expr -> atoms LT expression .)
    (               reduce using rule 48 (binary_expr -> atoms LT expression .)
    UNARY           reduce using rule 48 (binary_expr -> atoms LT expression .)
    INT             reduce using rule 48 (binary_expr -> atoms LT expression .)
    FLOAT           reduce using rule 48 (binary_expr -> atoms LT expression .)
    STRING          reduce using rule 48 (binary_expr -> atoms LT expression .)
    ADAPT           reduce using rule 48 (binary_expr -> atoms LT expression .)
    VOID            reduce using rule 48 (binary_expr -> atoms LT expression .)
    FOR             reduce using rule 48 (binary_expr -> atoms LT expression .)
    WHILE           reduce using rule 48 (binary_expr -> atoms LT expression .)
    )               reduce using rule 48 (binary_expr -> atoms LT expression .)
    {               reduce using rule 48 (binary_expr -> atoms LT expression .)
    ;               reduce using rule 48 (binary_expr -> atoms LT expression .)


state 86

    (51) assignment -> datatype IDENTIFIER EQUAL . expression
    (52) assignment -> datatype IDENTIFIER EQUAL . ACCEPT ( )
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (36) variable -> . IDENTIFIER

    ACCEPT          shift and go to state 98
    INT_VALUE       shift and go to state 27
    FLOAT_VALUE     shift and go to state 28
    STRING_VALUE    shift and go to state 29
    (               shift and go to state 7
    UNARY           shift and go to state 31
    IDENTIFIER      shift and go to state 42

    expression                     shift and go to state 97
    atoms                          shift and go to state 21
    paren_expr                     shift and go to state 22
    binary_expr                    shift and go to state 23
    variable                       shift and go to state 30

state 87

    (14) function_declaration -> FUNC IDENTIFIER ( . ) : datatype { function_body }

    )               shift and go to state 99


state 88

    (59) forLoop -> FOR ( expression . ; condition ; expression ) { statements }

    ;               shift and go to state 100


state 89

    (60) whileLoop -> WHILE ( condition . ) { statements }

    )               shift and go to state 101


state 90

    (11) statement -> PRINT ( expression ) .

    }               reduce using rule 11 (statement -> PRINT ( expression ) .)
    RETURN          reduce using rule 11 (statement -> PRINT ( expression ) .)
    PRINT           reduce using rule 11 (statement -> PRINT ( expression ) .)
    IDENTIFIER      reduce using rule 11 (statement -> PRINT ( expression ) .)
    IF              reduce using rule 11 (statement -> PRINT ( expression ) .)
    FUNC            reduce using rule 11 (statement -> PRINT ( expression ) .)
    INT_VALUE       reduce using rule 11 (statement -> PRINT ( expression ) .)
    FLOAT_VALUE     reduce using rule 11 (statement -> PRINT ( expression ) .)
    STRING_VALUE    reduce using rule 11 (statement -> PRINT ( expression ) .)
    (               reduce using rule 11 (statement -> PRINT ( expression ) .)
    UNARY           reduce using rule 11 (statement -> PRINT ( expression ) .)
    INT             reduce using rule 11 (statement -> PRINT ( expression ) .)
    FLOAT           reduce using rule 11 (statement -> PRINT ( expression ) .)
    STRING          reduce using rule 11 (statement -> PRINT ( expression ) .)
    ADAPT           reduce using rule 11 (statement -> PRINT ( expression ) .)
    VOID            reduce using rule 11 (statement -> PRINT ( expression ) .)
    FOR             reduce using rule 11 (statement -> PRINT ( expression ) .)
    WHILE           reduce using rule 11 (statement -> PRINT ( expression ) .)


state 91

    (16) function_calls -> IDENTIFIER . ( )
    (17) function_calls -> IDENTIFIER . ( ) function_calls
    (18) function_calls -> IDENTIFIER . ( parameters )
    (19) function_calls -> IDENTIFIER . ( parameters ) function_calls

    (               shift and go to state 47


state 92

    (17) function_calls -> IDENTIFIER ( ) function_calls .

    }               reduce using rule 17 (function_calls -> IDENTIFIER ( ) function_calls .)
    RETURN          reduce using rule 17 (function_calls -> IDENTIFIER ( ) function_calls .)
    PRINT           reduce using rule 17 (function_calls -> IDENTIFIER ( ) function_calls .)
    IDENTIFIER      reduce using rule 17 (function_calls -> IDENTIFIER ( ) function_calls .)
    IF              reduce using rule 17 (function_calls -> IDENTIFIER ( ) function_calls .)
    FUNC            reduce using rule 17 (function_calls -> IDENTIFIER ( ) function_calls .)
    INT_VALUE       reduce using rule 17 (function_calls -> IDENTIFIER ( ) function_calls .)
    FLOAT_VALUE     reduce using rule 17 (function_calls -> IDENTIFIER ( ) function_calls .)
    STRING_VALUE    reduce using rule 17 (function_calls -> IDENTIFIER ( ) function_calls .)
    (               reduce using rule 17 (function_calls -> IDENTIFIER ( ) function_calls .)
    UNARY           reduce using rule 17 (function_calls -> IDENTIFIER ( ) function_calls .)
    INT             reduce using rule 17 (function_calls -> IDENTIFIER ( ) function_calls .)
    FLOAT           reduce using rule 17 (function_calls -> IDENTIFIER ( ) function_calls .)
    STRING          reduce using rule 17 (function_calls -> IDENTIFIER ( ) function_calls .)
    ADAPT           reduce using rule 17 (function_calls -> IDENTIFIER ( ) function_calls .)
    VOID            reduce using rule 17 (function_calls -> IDENTIFIER ( ) function_calls .)
    FOR             reduce using rule 17 (function_calls -> IDENTIFIER ( ) function_calls .)
    WHILE           reduce using rule 17 (function_calls -> IDENTIFIER ( ) function_calls .)


state 93

    (18) function_calls -> IDENTIFIER ( parameters ) .
    (19) function_calls -> IDENTIFIER ( parameters ) . function_calls
    (16) function_calls -> . IDENTIFIER ( )
    (17) function_calls -> . IDENTIFIER ( ) function_calls
    (18) function_calls -> . IDENTIFIER ( parameters )
    (19) function_calls -> . IDENTIFIER ( parameters ) function_calls

  ! shift/reduce conflict for IDENTIFIER resolved as shift
    }               reduce using rule 18 (function_calls -> IDENTIFIER ( parameters ) .)
    RETURN          reduce using rule 18 (function_calls -> IDENTIFIER ( parameters ) .)
    PRINT           reduce using rule 18 (function_calls -> IDENTIFIER ( parameters ) .)
    IF              reduce using rule 18 (function_calls -> IDENTIFIER ( parameters ) .)
    FUNC            reduce using rule 18 (function_calls -> IDENTIFIER ( parameters ) .)
    INT_VALUE       reduce using rule 18 (function_calls -> IDENTIFIER ( parameters ) .)
    FLOAT_VALUE     reduce using rule 18 (function_calls -> IDENTIFIER ( parameters ) .)
    STRING_VALUE    reduce using rule 18 (function_calls -> IDENTIFIER ( parameters ) .)
    (               reduce using rule 18 (function_calls -> IDENTIFIER ( parameters ) .)
    UNARY           reduce using rule 18 (function_calls -> IDENTIFIER ( parameters ) .)
    INT             reduce using rule 18 (function_calls -> IDENTIFIER ( parameters ) .)
    FLOAT           reduce using rule 18 (function_calls -> IDENTIFIER ( parameters ) .)
    STRING          reduce using rule 18 (function_calls -> IDENTIFIER ( parameters ) .)
    ADAPT           reduce using rule 18 (function_calls -> IDENTIFIER ( parameters ) .)
    VOID            reduce using rule 18 (function_calls -> IDENTIFIER ( parameters ) .)
    FOR             reduce using rule 18 (function_calls -> IDENTIFIER ( parameters ) .)
    WHILE           reduce using rule 18 (function_calls -> IDENTIFIER ( parameters ) .)
    IDENTIFIER      shift and go to state 91

  ! IDENTIFIER      [ reduce using rule 18 (function_calls -> IDENTIFIER ( parameters ) .) ]

    function_calls                 shift and go to state 102

state 94

    (22) parameterList -> parameter , . parameterList
    (21) parameterList -> . parameter
    (22) parameterList -> . parameter , parameterList
    (23) parameter -> . datatype IDENTIFIER
    (24) datatype -> . INT
    (25) datatype -> . FLOAT
    (26) datatype -> . STRING
    (27) datatype -> . ADAPT
    (28) datatype -> . VOID

    INT             shift and go to state 34
    FLOAT           shift and go to state 35
    STRING          shift and go to state 36
    ADAPT           shift and go to state 37
    VOID            shift and go to state 38

    parameter                      shift and go to state 72
    parameterList                  shift and go to state 103
    datatype                       shift and go to state 73

state 95

    (23) parameter -> datatype IDENTIFIER .

    ,               reduce using rule 23 (parameter -> datatype IDENTIFIER .)
    )               reduce using rule 23 (parameter -> datatype IDENTIFIER .)


state 96

    (53) condition -> IF expression { statements . }
    (54) condition -> IF expression { statements . } ELSE { statements }
    (4) statements -> statements . statement
    (5) statement -> . function_calls
    (6) statement -> . condition
    (7) statement -> . function_declarations
    (8) statement -> . expression
    (9) statement -> . loops
    (10) statement -> . RETURN expression
    (11) statement -> . PRINT ( expression )
    (12) statement -> . assignment
    (16) function_calls -> . IDENTIFIER ( )
    (17) function_calls -> . IDENTIFIER ( ) function_calls
    (18) function_calls -> . IDENTIFIER ( parameters )
    (19) function_calls -> . IDENTIFIER ( parameters ) function_calls
    (53) condition -> . IF expression { statements }
    (54) condition -> . IF expression { statements } ELSE { statements }
    (13) function_declarations -> . function_declaration
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (55) loops -> . loop
    (56) loops -> . loop loops
    (51) assignment -> . datatype IDENTIFIER EQUAL expression
    (52) assignment -> . datatype IDENTIFIER EQUAL ACCEPT ( )
    (14) function_declaration -> . FUNC IDENTIFIER ( ) : datatype { function_body }
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (57) loop -> . forLoop
    (58) loop -> . whileLoop
    (24) datatype -> . INT
    (25) datatype -> . FLOAT
    (26) datatype -> . STRING
    (27) datatype -> . ADAPT
    (28) datatype -> . VOID
    (36) variable -> . IDENTIFIER
    (59) forLoop -> . FOR ( expression ; condition ; expression ) { statements }
    (60) whileLoop -> . WHILE ( condition ) { statements }

    }               shift and go to state 104
    RETURN          shift and go to state 15
    PRINT           shift and go to state 16
    IDENTIFIER      shift and go to state 18
    IF              shift and go to state 19
    FUNC            shift and go to state 26
    INT_VALUE       shift and go to state 27
    FLOAT_VALUE     shift and go to state 28
    STRING_VALUE    shift and go to state 29
    (               shift and go to state 7
    UNARY           shift and go to state 31
    INT             shift and go to state 34
    FLOAT           shift and go to state 35
    STRING          shift and go to state 36
    ADAPT           shift and go to state 37
    VOID            shift and go to state 38
    FOR             shift and go to state 39
    WHILE           shift and go to state 40

    expression                     shift and go to state 13
    statement                      shift and go to state 44
    function_calls                 shift and go to state 10
    condition                      shift and go to state 11
    function_declarations          shift and go to state 12
    loops                          shift and go to state 14
    assignment                     shift and go to state 17
    function_declaration           shift and go to state 20
    atoms                          shift and go to state 21
    paren_expr                     shift and go to state 22
    binary_expr                    shift and go to state 23
    loop                           shift and go to state 24
    datatype                       shift and go to state 25
    variable                       shift and go to state 30
    forLoop                        shift and go to state 32
    whileLoop                      shift and go to state 33

state 97

    (51) assignment -> datatype IDENTIFIER EQUAL expression .

    }               reduce using rule 51 (assignment -> datatype IDENTIFIER EQUAL expression .)
    RETURN          reduce using rule 51 (assignment -> datatype IDENTIFIER EQUAL expression .)
    PRINT           reduce using rule 51 (assignment -> datatype IDENTIFIER EQUAL expression .)
    IDENTIFIER      reduce using rule 51 (assignment -> datatype IDENTIFIER EQUAL expression .)
    IF              reduce using rule 51 (assignment -> datatype IDENTIFIER EQUAL expression .)
    FUNC            reduce using rule 51 (assignment -> datatype IDENTIFIER EQUAL expression .)
    INT_VALUE       reduce using rule 51 (assignment -> datatype IDENTIFIER EQUAL expression .)
    FLOAT_VALUE     reduce using rule 51 (assignment -> datatype IDENTIFIER EQUAL expression .)
    STRING_VALUE    reduce using rule 51 (assignment -> datatype IDENTIFIER EQUAL expression .)
    (               reduce using rule 51 (assignment -> datatype IDENTIFIER EQUAL expression .)
    UNARY           reduce using rule 51 (assignment -> datatype IDENTIFIER EQUAL expression .)
    INT             reduce using rule 51 (assignment -> datatype IDENTIFIER EQUAL expression .)
    FLOAT           reduce using rule 51 (assignment -> datatype IDENTIFIER EQUAL expression .)
    STRING          reduce using rule 51 (assignment -> datatype IDENTIFIER EQUAL expression .)
    ADAPT           reduce using rule 51 (assignment -> datatype IDENTIFIER EQUAL expression .)
    VOID            reduce using rule 51 (assignment -> datatype IDENTIFIER EQUAL expression .)
    FOR             reduce using rule 51 (assignment -> datatype IDENTIFIER EQUAL expression .)
    WHILE           reduce using rule 51 (assignment -> datatype IDENTIFIER EQUAL expression .)


state 98

    (52) assignment -> datatype IDENTIFIER EQUAL ACCEPT . ( )

    (               shift and go to state 105


state 99

    (14) function_declaration -> FUNC IDENTIFIER ( ) . : datatype { function_body }

    :               shift and go to state 106


state 100

    (59) forLoop -> FOR ( expression ; . condition ; expression ) { statements }
    (53) condition -> . IF expression { statements }
    (54) condition -> . IF expression { statements } ELSE { statements }

    IF              shift and go to state 19

    condition                      shift and go to state 107

state 101

    (60) whileLoop -> WHILE ( condition ) . { statements }

    {               shift and go to state 108


state 102

    (19) function_calls -> IDENTIFIER ( parameters ) function_calls .

    }               reduce using rule 19 (function_calls -> IDENTIFIER ( parameters ) function_calls .)
    RETURN          reduce using rule 19 (function_calls -> IDENTIFIER ( parameters ) function_calls .)
    PRINT           reduce using rule 19 (function_calls -> IDENTIFIER ( parameters ) function_calls .)
    IDENTIFIER      reduce using rule 19 (function_calls -> IDENTIFIER ( parameters ) function_calls .)
    IF              reduce using rule 19 (function_calls -> IDENTIFIER ( parameters ) function_calls .)
    FUNC            reduce using rule 19 (function_calls -> IDENTIFIER ( parameters ) function_calls .)
    INT_VALUE       reduce using rule 19 (function_calls -> IDENTIFIER ( parameters ) function_calls .)
    FLOAT_VALUE     reduce using rule 19 (function_calls -> IDENTIFIER ( parameters ) function_calls .)
    STRING_VALUE    reduce using rule 19 (function_calls -> IDENTIFIER ( parameters ) function_calls .)
    (               reduce using rule 19 (function_calls -> IDENTIFIER ( parameters ) function_calls .)
    UNARY           reduce using rule 19 (function_calls -> IDENTIFIER ( parameters ) function_calls .)
    INT             reduce using rule 19 (function_calls -> IDENTIFIER ( parameters ) function_calls .)
    FLOAT           reduce using rule 19 (function_calls -> IDENTIFIER ( parameters ) function_calls .)
    STRING          reduce using rule 19 (function_calls -> IDENTIFIER ( parameters ) function_calls .)
    ADAPT           reduce using rule 19 (function_calls -> IDENTIFIER ( parameters ) function_calls .)
    VOID            reduce using rule 19 (function_calls -> IDENTIFIER ( parameters ) function_calls .)
    FOR             reduce using rule 19 (function_calls -> IDENTIFIER ( parameters ) function_calls .)
    WHILE           reduce using rule 19 (function_calls -> IDENTIFIER ( parameters ) function_calls .)


state 103

    (22) parameterList -> parameter , parameterList .

    )               reduce using rule 22 (parameterList -> parameter , parameterList .)


state 104

    (53) condition -> IF expression { statements } .
    (54) condition -> IF expression { statements } . ELSE { statements }

    }               reduce using rule 53 (condition -> IF expression { statements } .)
    RETURN          reduce using rule 53 (condition -> IF expression { statements } .)
    PRINT           reduce using rule 53 (condition -> IF expression { statements } .)
    IDENTIFIER      reduce using rule 53 (condition -> IF expression { statements } .)
    IF              reduce using rule 53 (condition -> IF expression { statements } .)
    FUNC            reduce using rule 53 (condition -> IF expression { statements } .)
    INT_VALUE       reduce using rule 53 (condition -> IF expression { statements } .)
    FLOAT_VALUE     reduce using rule 53 (condition -> IF expression { statements } .)
    STRING_VALUE    reduce using rule 53 (condition -> IF expression { statements } .)
    (               reduce using rule 53 (condition -> IF expression { statements } .)
    UNARY           reduce using rule 53 (condition -> IF expression { statements } .)
    INT             reduce using rule 53 (condition -> IF expression { statements } .)
    FLOAT           reduce using rule 53 (condition -> IF expression { statements } .)
    STRING          reduce using rule 53 (condition -> IF expression { statements } .)
    ADAPT           reduce using rule 53 (condition -> IF expression { statements } .)
    VOID            reduce using rule 53 (condition -> IF expression { statements } .)
    FOR             reduce using rule 53 (condition -> IF expression { statements } .)
    WHILE           reduce using rule 53 (condition -> IF expression { statements } .)
    )               reduce using rule 53 (condition -> IF expression { statements } .)
    ;               reduce using rule 53 (condition -> IF expression { statements } .)
    ELSE            shift and go to state 109


state 105

    (52) assignment -> datatype IDENTIFIER EQUAL ACCEPT ( . )

    )               shift and go to state 110


state 106

    (14) function_declaration -> FUNC IDENTIFIER ( ) : . datatype { function_body }
    (24) datatype -> . INT
    (25) datatype -> . FLOAT
    (26) datatype -> . STRING
    (27) datatype -> . ADAPT
    (28) datatype -> . VOID

    INT             shift and go to state 34
    FLOAT           shift and go to state 35
    STRING          shift and go to state 36
    ADAPT           shift and go to state 37
    VOID            shift and go to state 38

    datatype                       shift and go to state 111

state 107

    (59) forLoop -> FOR ( expression ; condition . ; expression ) { statements }

    ;               shift and go to state 112


state 108

    (60) whileLoop -> WHILE ( condition ) { . statements }
    (3) statements -> . statement
    (4) statements -> . statements statement
    (5) statement -> . function_calls
    (6) statement -> . condition
    (7) statement -> . function_declarations
    (8) statement -> . expression
    (9) statement -> . loops
    (10) statement -> . RETURN expression
    (11) statement -> . PRINT ( expression )
    (12) statement -> . assignment
    (16) function_calls -> . IDENTIFIER ( )
    (17) function_calls -> . IDENTIFIER ( ) function_calls
    (18) function_calls -> . IDENTIFIER ( parameters )
    (19) function_calls -> . IDENTIFIER ( parameters ) function_calls
    (53) condition -> . IF expression { statements }
    (54) condition -> . IF expression { statements } ELSE { statements }
    (13) function_declarations -> . function_declaration
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (55) loops -> . loop
    (56) loops -> . loop loops
    (51) assignment -> . datatype IDENTIFIER EQUAL expression
    (52) assignment -> . datatype IDENTIFIER EQUAL ACCEPT ( )
    (14) function_declaration -> . FUNC IDENTIFIER ( ) : datatype { function_body }
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (57) loop -> . forLoop
    (58) loop -> . whileLoop
    (24) datatype -> . INT
    (25) datatype -> . FLOAT
    (26) datatype -> . STRING
    (27) datatype -> . ADAPT
    (28) datatype -> . VOID
    (36) variable -> . IDENTIFIER
    (59) forLoop -> . FOR ( expression ; condition ; expression ) { statements }
    (60) whileLoop -> . WHILE ( condition ) { statements }

    RETURN          shift and go to state 15
    PRINT           shift and go to state 16
    IDENTIFIER      shift and go to state 18
    IF              shift and go to state 19
    FUNC            shift and go to state 26
    INT_VALUE       shift and go to state 27
    FLOAT_VALUE     shift and go to state 28
    STRING_VALUE    shift and go to state 29
    (               shift and go to state 7
    UNARY           shift and go to state 31
    INT             shift and go to state 34
    FLOAT           shift and go to state 35
    STRING          shift and go to state 36
    ADAPT           shift and go to state 37
    VOID            shift and go to state 38
    FOR             shift and go to state 39
    WHILE           shift and go to state 40

    condition                      shift and go to state 11
    statements                     shift and go to state 113
    statement                      shift and go to state 9
    function_calls                 shift and go to state 10
    function_declarations          shift and go to state 12
    expression                     shift and go to state 13
    loops                          shift and go to state 14
    assignment                     shift and go to state 17
    function_declaration           shift and go to state 20
    atoms                          shift and go to state 21
    paren_expr                     shift and go to state 22
    binary_expr                    shift and go to state 23
    loop                           shift and go to state 24
    datatype                       shift and go to state 25
    variable                       shift and go to state 30
    forLoop                        shift and go to state 32
    whileLoop                      shift and go to state 33

state 109

    (54) condition -> IF expression { statements } ELSE . { statements }

    {               shift and go to state 114


state 110

    (52) assignment -> datatype IDENTIFIER EQUAL ACCEPT ( ) .

    }               reduce using rule 52 (assignment -> datatype IDENTIFIER EQUAL ACCEPT ( ) .)
    RETURN          reduce using rule 52 (assignment -> datatype IDENTIFIER EQUAL ACCEPT ( ) .)
    PRINT           reduce using rule 52 (assignment -> datatype IDENTIFIER EQUAL ACCEPT ( ) .)
    IDENTIFIER      reduce using rule 52 (assignment -> datatype IDENTIFIER EQUAL ACCEPT ( ) .)
    IF              reduce using rule 52 (assignment -> datatype IDENTIFIER EQUAL ACCEPT ( ) .)
    FUNC            reduce using rule 52 (assignment -> datatype IDENTIFIER EQUAL ACCEPT ( ) .)
    INT_VALUE       reduce using rule 52 (assignment -> datatype IDENTIFIER EQUAL ACCEPT ( ) .)
    FLOAT_VALUE     reduce using rule 52 (assignment -> datatype IDENTIFIER EQUAL ACCEPT ( ) .)
    STRING_VALUE    reduce using rule 52 (assignment -> datatype IDENTIFIER EQUAL ACCEPT ( ) .)
    (               reduce using rule 52 (assignment -> datatype IDENTIFIER EQUAL ACCEPT ( ) .)
    UNARY           reduce using rule 52 (assignment -> datatype IDENTIFIER EQUAL ACCEPT ( ) .)
    INT             reduce using rule 52 (assignment -> datatype IDENTIFIER EQUAL ACCEPT ( ) .)
    FLOAT           reduce using rule 52 (assignment -> datatype IDENTIFIER EQUAL ACCEPT ( ) .)
    STRING          reduce using rule 52 (assignment -> datatype IDENTIFIER EQUAL ACCEPT ( ) .)
    ADAPT           reduce using rule 52 (assignment -> datatype IDENTIFIER EQUAL ACCEPT ( ) .)
    VOID            reduce using rule 52 (assignment -> datatype IDENTIFIER EQUAL ACCEPT ( ) .)
    FOR             reduce using rule 52 (assignment -> datatype IDENTIFIER EQUAL ACCEPT ( ) .)
    WHILE           reduce using rule 52 (assignment -> datatype IDENTIFIER EQUAL ACCEPT ( ) .)


state 111

    (14) function_declaration -> FUNC IDENTIFIER ( ) : datatype . { function_body }

    {               shift and go to state 115


state 112

    (59) forLoop -> FOR ( expression ; condition ; . expression ) { statements }
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (36) variable -> . IDENTIFIER

    INT_VALUE       shift and go to state 27
    FLOAT_VALUE     shift and go to state 28
    STRING_VALUE    shift and go to state 29
    (               shift and go to state 7
    UNARY           shift and go to state 31
    IDENTIFIER      shift and go to state 42

    expression                     shift and go to state 116
    atoms                          shift and go to state 21
    paren_expr                     shift and go to state 22
    binary_expr                    shift and go to state 23
    variable                       shift and go to state 30

state 113

    (60) whileLoop -> WHILE ( condition ) { statements . }
    (4) statements -> statements . statement
    (5) statement -> . function_calls
    (6) statement -> . condition
    (7) statement -> . function_declarations
    (8) statement -> . expression
    (9) statement -> . loops
    (10) statement -> . RETURN expression
    (11) statement -> . PRINT ( expression )
    (12) statement -> . assignment
    (16) function_calls -> . IDENTIFIER ( )
    (17) function_calls -> . IDENTIFIER ( ) function_calls
    (18) function_calls -> . IDENTIFIER ( parameters )
    (19) function_calls -> . IDENTIFIER ( parameters ) function_calls
    (53) condition -> . IF expression { statements }
    (54) condition -> . IF expression { statements } ELSE { statements }
    (13) function_declarations -> . function_declaration
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (55) loops -> . loop
    (56) loops -> . loop loops
    (51) assignment -> . datatype IDENTIFIER EQUAL expression
    (52) assignment -> . datatype IDENTIFIER EQUAL ACCEPT ( )
    (14) function_declaration -> . FUNC IDENTIFIER ( ) : datatype { function_body }
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (57) loop -> . forLoop
    (58) loop -> . whileLoop
    (24) datatype -> . INT
    (25) datatype -> . FLOAT
    (26) datatype -> . STRING
    (27) datatype -> . ADAPT
    (28) datatype -> . VOID
    (36) variable -> . IDENTIFIER
    (59) forLoop -> . FOR ( expression ; condition ; expression ) { statements }
    (60) whileLoop -> . WHILE ( condition ) { statements }

    }               shift and go to state 117
    RETURN          shift and go to state 15
    PRINT           shift and go to state 16
    IDENTIFIER      shift and go to state 18
    IF              shift and go to state 19
    FUNC            shift and go to state 26
    INT_VALUE       shift and go to state 27
    FLOAT_VALUE     shift and go to state 28
    STRING_VALUE    shift and go to state 29
    (               shift and go to state 7
    UNARY           shift and go to state 31
    INT             shift and go to state 34
    FLOAT           shift and go to state 35
    STRING          shift and go to state 36
    ADAPT           shift and go to state 37
    VOID            shift and go to state 38
    FOR             shift and go to state 39
    WHILE           shift and go to state 40

    condition                      shift and go to state 11
    statement                      shift and go to state 44
    function_calls                 shift and go to state 10
    function_declarations          shift and go to state 12
    expression                     shift and go to state 13
    loops                          shift and go to state 14
    assignment                     shift and go to state 17
    function_declaration           shift and go to state 20
    atoms                          shift and go to state 21
    paren_expr                     shift and go to state 22
    binary_expr                    shift and go to state 23
    loop                           shift and go to state 24
    datatype                       shift and go to state 25
    variable                       shift and go to state 30
    forLoop                        shift and go to state 32
    whileLoop                      shift and go to state 33

state 114

    (54) condition -> IF expression { statements } ELSE { . statements }
    (3) statements -> . statement
    (4) statements -> . statements statement
    (5) statement -> . function_calls
    (6) statement -> . condition
    (7) statement -> . function_declarations
    (8) statement -> . expression
    (9) statement -> . loops
    (10) statement -> . RETURN expression
    (11) statement -> . PRINT ( expression )
    (12) statement -> . assignment
    (16) function_calls -> . IDENTIFIER ( )
    (17) function_calls -> . IDENTIFIER ( ) function_calls
    (18) function_calls -> . IDENTIFIER ( parameters )
    (19) function_calls -> . IDENTIFIER ( parameters ) function_calls
    (53) condition -> . IF expression { statements }
    (54) condition -> . IF expression { statements } ELSE { statements }
    (13) function_declarations -> . function_declaration
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (55) loops -> . loop
    (56) loops -> . loop loops
    (51) assignment -> . datatype IDENTIFIER EQUAL expression
    (52) assignment -> . datatype IDENTIFIER EQUAL ACCEPT ( )
    (14) function_declaration -> . FUNC IDENTIFIER ( ) : datatype { function_body }
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (57) loop -> . forLoop
    (58) loop -> . whileLoop
    (24) datatype -> . INT
    (25) datatype -> . FLOAT
    (26) datatype -> . STRING
    (27) datatype -> . ADAPT
    (28) datatype -> . VOID
    (36) variable -> . IDENTIFIER
    (59) forLoop -> . FOR ( expression ; condition ; expression ) { statements }
    (60) whileLoop -> . WHILE ( condition ) { statements }

    RETURN          shift and go to state 15
    PRINT           shift and go to state 16
    IDENTIFIER      shift and go to state 18
    IF              shift and go to state 19
    FUNC            shift and go to state 26
    INT_VALUE       shift and go to state 27
    FLOAT_VALUE     shift and go to state 28
    STRING_VALUE    shift and go to state 29
    (               shift and go to state 7
    UNARY           shift and go to state 31
    INT             shift and go to state 34
    FLOAT           shift and go to state 35
    STRING          shift and go to state 36
    ADAPT           shift and go to state 37
    VOID            shift and go to state 38
    FOR             shift and go to state 39
    WHILE           shift and go to state 40

    expression                     shift and go to state 13
    statements                     shift and go to state 118
    statement                      shift and go to state 9
    function_calls                 shift and go to state 10
    condition                      shift and go to state 11
    function_declarations          shift and go to state 12
    loops                          shift and go to state 14
    assignment                     shift and go to state 17
    function_declaration           shift and go to state 20
    atoms                          shift and go to state 21
    paren_expr                     shift and go to state 22
    binary_expr                    shift and go to state 23
    loop                           shift and go to state 24
    datatype                       shift and go to state 25
    variable                       shift and go to state 30
    forLoop                        shift and go to state 32
    whileLoop                      shift and go to state 33

state 115

    (14) function_declaration -> FUNC IDENTIFIER ( ) : datatype { . function_body }
    (15) function_body -> . statements
    (3) statements -> . statement
    (4) statements -> . statements statement
    (5) statement -> . function_calls
    (6) statement -> . condition
    (7) statement -> . function_declarations
    (8) statement -> . expression
    (9) statement -> . loops
    (10) statement -> . RETURN expression
    (11) statement -> . PRINT ( expression )
    (12) statement -> . assignment
    (16) function_calls -> . IDENTIFIER ( )
    (17) function_calls -> . IDENTIFIER ( ) function_calls
    (18) function_calls -> . IDENTIFIER ( parameters )
    (19) function_calls -> . IDENTIFIER ( parameters ) function_calls
    (53) condition -> . IF expression { statements }
    (54) condition -> . IF expression { statements } ELSE { statements }
    (13) function_declarations -> . function_declaration
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (55) loops -> . loop
    (56) loops -> . loop loops
    (51) assignment -> . datatype IDENTIFIER EQUAL expression
    (52) assignment -> . datatype IDENTIFIER EQUAL ACCEPT ( )
    (14) function_declaration -> . FUNC IDENTIFIER ( ) : datatype { function_body }
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (57) loop -> . forLoop
    (58) loop -> . whileLoop
    (24) datatype -> . INT
    (25) datatype -> . FLOAT
    (26) datatype -> . STRING
    (27) datatype -> . ADAPT
    (28) datatype -> . VOID
    (36) variable -> . IDENTIFIER
    (59) forLoop -> . FOR ( expression ; condition ; expression ) { statements }
    (60) whileLoop -> . WHILE ( condition ) { statements }

    RETURN          shift and go to state 15
    PRINT           shift and go to state 16
    IDENTIFIER      shift and go to state 18
    IF              shift and go to state 19
    FUNC            shift and go to state 26
    INT_VALUE       shift and go to state 27
    FLOAT_VALUE     shift and go to state 28
    STRING_VALUE    shift and go to state 29
    (               shift and go to state 7
    UNARY           shift and go to state 31
    INT             shift and go to state 34
    FLOAT           shift and go to state 35
    STRING          shift and go to state 36
    ADAPT           shift and go to state 37
    VOID            shift and go to state 38
    FOR             shift and go to state 39
    WHILE           shift and go to state 40

    datatype                       shift and go to state 25
    function_body                  shift and go to state 119
    statements                     shift and go to state 120
    statement                      shift and go to state 9
    function_calls                 shift and go to state 10
    condition                      shift and go to state 11
    function_declarations          shift and go to state 12
    expression                     shift and go to state 13
    loops                          shift and go to state 14
    assignment                     shift and go to state 17
    function_declaration           shift and go to state 20
    atoms                          shift and go to state 21
    paren_expr                     shift and go to state 22
    binary_expr                    shift and go to state 23
    loop                           shift and go to state 24
    variable                       shift and go to state 30
    forLoop                        shift and go to state 32
    whileLoop                      shift and go to state 33

state 116

    (59) forLoop -> FOR ( expression ; condition ; expression . ) { statements }

    )               shift and go to state 121


state 117

    (60) whileLoop -> WHILE ( condition ) { statements } .

    FOR             reduce using rule 60 (whileLoop -> WHILE ( condition ) { statements } .)
    WHILE           reduce using rule 60 (whileLoop -> WHILE ( condition ) { statements } .)
    }               reduce using rule 60 (whileLoop -> WHILE ( condition ) { statements } .)
    RETURN          reduce using rule 60 (whileLoop -> WHILE ( condition ) { statements } .)
    PRINT           reduce using rule 60 (whileLoop -> WHILE ( condition ) { statements } .)
    IDENTIFIER      reduce using rule 60 (whileLoop -> WHILE ( condition ) { statements } .)
    IF              reduce using rule 60 (whileLoop -> WHILE ( condition ) { statements } .)
    FUNC            reduce using rule 60 (whileLoop -> WHILE ( condition ) { statements } .)
    INT_VALUE       reduce using rule 60 (whileLoop -> WHILE ( condition ) { statements } .)
    FLOAT_VALUE     reduce using rule 60 (whileLoop -> WHILE ( condition ) { statements } .)
    STRING_VALUE    reduce using rule 60 (whileLoop -> WHILE ( condition ) { statements } .)
    (               reduce using rule 60 (whileLoop -> WHILE ( condition ) { statements } .)
    UNARY           reduce using rule 60 (whileLoop -> WHILE ( condition ) { statements } .)
    INT             reduce using rule 60 (whileLoop -> WHILE ( condition ) { statements } .)
    FLOAT           reduce using rule 60 (whileLoop -> WHILE ( condition ) { statements } .)
    STRING          reduce using rule 60 (whileLoop -> WHILE ( condition ) { statements } .)
    ADAPT           reduce using rule 60 (whileLoop -> WHILE ( condition ) { statements } .)
    VOID            reduce using rule 60 (whileLoop -> WHILE ( condition ) { statements } .)


state 118

    (54) condition -> IF expression { statements } ELSE { statements . }
    (4) statements -> statements . statement
    (5) statement -> . function_calls
    (6) statement -> . condition
    (7) statement -> . function_declarations
    (8) statement -> . expression
    (9) statement -> . loops
    (10) statement -> . RETURN expression
    (11) statement -> . PRINT ( expression )
    (12) statement -> . assignment
    (16) function_calls -> . IDENTIFIER ( )
    (17) function_calls -> . IDENTIFIER ( ) function_calls
    (18) function_calls -> . IDENTIFIER ( parameters )
    (19) function_calls -> . IDENTIFIER ( parameters ) function_calls
    (53) condition -> . IF expression { statements }
    (54) condition -> . IF expression { statements } ELSE { statements }
    (13) function_declarations -> . function_declaration
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (55) loops -> . loop
    (56) loops -> . loop loops
    (51) assignment -> . datatype IDENTIFIER EQUAL expression
    (52) assignment -> . datatype IDENTIFIER EQUAL ACCEPT ( )
    (14) function_declaration -> . FUNC IDENTIFIER ( ) : datatype { function_body }
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (57) loop -> . forLoop
    (58) loop -> . whileLoop
    (24) datatype -> . INT
    (25) datatype -> . FLOAT
    (26) datatype -> . STRING
    (27) datatype -> . ADAPT
    (28) datatype -> . VOID
    (36) variable -> . IDENTIFIER
    (59) forLoop -> . FOR ( expression ; condition ; expression ) { statements }
    (60) whileLoop -> . WHILE ( condition ) { statements }

    }               shift and go to state 122
    RETURN          shift and go to state 15
    PRINT           shift and go to state 16
    IDENTIFIER      shift and go to state 18
    IF              shift and go to state 19
    FUNC            shift and go to state 26
    INT_VALUE       shift and go to state 27
    FLOAT_VALUE     shift and go to state 28
    STRING_VALUE    shift and go to state 29
    (               shift and go to state 7
    UNARY           shift and go to state 31
    INT             shift and go to state 34
    FLOAT           shift and go to state 35
    STRING          shift and go to state 36
    ADAPT           shift and go to state 37
    VOID            shift and go to state 38
    FOR             shift and go to state 39
    WHILE           shift and go to state 40

    expression                     shift and go to state 13
    statement                      shift and go to state 44
    function_calls                 shift and go to state 10
    condition                      shift and go to state 11
    function_declarations          shift and go to state 12
    loops                          shift and go to state 14
    assignment                     shift and go to state 17
    function_declaration           shift and go to state 20
    atoms                          shift and go to state 21
    paren_expr                     shift and go to state 22
    binary_expr                    shift and go to state 23
    loop                           shift and go to state 24
    datatype                       shift and go to state 25
    variable                       shift and go to state 30
    forLoop                        shift and go to state 32
    whileLoop                      shift and go to state 33

state 119

    (14) function_declaration -> FUNC IDENTIFIER ( ) : datatype { function_body . }

    }               shift and go to state 123


state 120

    (15) function_body -> statements .
    (4) statements -> statements . statement
    (5) statement -> . function_calls
    (6) statement -> . condition
    (7) statement -> . function_declarations
    (8) statement -> . expression
    (9) statement -> . loops
    (10) statement -> . RETURN expression
    (11) statement -> . PRINT ( expression )
    (12) statement -> . assignment
    (16) function_calls -> . IDENTIFIER ( )
    (17) function_calls -> . IDENTIFIER ( ) function_calls
    (18) function_calls -> . IDENTIFIER ( parameters )
    (19) function_calls -> . IDENTIFIER ( parameters ) function_calls
    (53) condition -> . IF expression { statements }
    (54) condition -> . IF expression { statements } ELSE { statements }
    (13) function_declarations -> . function_declaration
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (55) loops -> . loop
    (56) loops -> . loop loops
    (51) assignment -> . datatype IDENTIFIER EQUAL expression
    (52) assignment -> . datatype IDENTIFIER EQUAL ACCEPT ( )
    (14) function_declaration -> . FUNC IDENTIFIER ( ) : datatype { function_body }
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (57) loop -> . forLoop
    (58) loop -> . whileLoop
    (24) datatype -> . INT
    (25) datatype -> . FLOAT
    (26) datatype -> . STRING
    (27) datatype -> . ADAPT
    (28) datatype -> . VOID
    (36) variable -> . IDENTIFIER
    (59) forLoop -> . FOR ( expression ; condition ; expression ) { statements }
    (60) whileLoop -> . WHILE ( condition ) { statements }

    }               reduce using rule 15 (function_body -> statements .)
    RETURN          shift and go to state 15
    PRINT           shift and go to state 16
    IDENTIFIER      shift and go to state 18
    IF              shift and go to state 19
    FUNC            shift and go to state 26
    INT_VALUE       shift and go to state 27
    FLOAT_VALUE     shift and go to state 28
    STRING_VALUE    shift and go to state 29
    (               shift and go to state 7
    UNARY           shift and go to state 31
    INT             shift and go to state 34
    FLOAT           shift and go to state 35
    STRING          shift and go to state 36
    ADAPT           shift and go to state 37
    VOID            shift and go to state 38
    FOR             shift and go to state 39
    WHILE           shift and go to state 40

    statement                      shift and go to state 44
    function_calls                 shift and go to state 10
    condition                      shift and go to state 11
    function_declarations          shift and go to state 12
    expression                     shift and go to state 13
    loops                          shift and go to state 14
    assignment                     shift and go to state 17
    function_declaration           shift and go to state 20
    atoms                          shift and go to state 21
    paren_expr                     shift and go to state 22
    binary_expr                    shift and go to state 23
    loop                           shift and go to state 24
    datatype                       shift and go to state 25
    variable                       shift and go to state 30
    forLoop                        shift and go to state 32
    whileLoop                      shift and go to state 33

state 121

    (59) forLoop -> FOR ( expression ; condition ; expression ) . { statements }

    {               shift and go to state 124


state 122

    (54) condition -> IF expression { statements } ELSE { statements } .

    }               reduce using rule 54 (condition -> IF expression { statements } ELSE { statements } .)
    RETURN          reduce using rule 54 (condition -> IF expression { statements } ELSE { statements } .)
    PRINT           reduce using rule 54 (condition -> IF expression { statements } ELSE { statements } .)
    IDENTIFIER      reduce using rule 54 (condition -> IF expression { statements } ELSE { statements } .)
    IF              reduce using rule 54 (condition -> IF expression { statements } ELSE { statements } .)
    FUNC            reduce using rule 54 (condition -> IF expression { statements } ELSE { statements } .)
    INT_VALUE       reduce using rule 54 (condition -> IF expression { statements } ELSE { statements } .)
    FLOAT_VALUE     reduce using rule 54 (condition -> IF expression { statements } ELSE { statements } .)
    STRING_VALUE    reduce using rule 54 (condition -> IF expression { statements } ELSE { statements } .)
    (               reduce using rule 54 (condition -> IF expression { statements } ELSE { statements } .)
    UNARY           reduce using rule 54 (condition -> IF expression { statements } ELSE { statements } .)
    INT             reduce using rule 54 (condition -> IF expression { statements } ELSE { statements } .)
    FLOAT           reduce using rule 54 (condition -> IF expression { statements } ELSE { statements } .)
    STRING          reduce using rule 54 (condition -> IF expression { statements } ELSE { statements } .)
    ADAPT           reduce using rule 54 (condition -> IF expression { statements } ELSE { statements } .)
    VOID            reduce using rule 54 (condition -> IF expression { statements } ELSE { statements } .)
    FOR             reduce using rule 54 (condition -> IF expression { statements } ELSE { statements } .)
    WHILE           reduce using rule 54 (condition -> IF expression { statements } ELSE { statements } .)
    )               reduce using rule 54 (condition -> IF expression { statements } ELSE { statements } .)
    ;               reduce using rule 54 (condition -> IF expression { statements } ELSE { statements } .)


state 123

    (14) function_declaration -> FUNC IDENTIFIER ( ) : datatype { function_body } .

    }               reduce using rule 14 (function_declaration -> FUNC IDENTIFIER ( ) : datatype { function_body } .)
    RETURN          reduce using rule 14 (function_declaration -> FUNC IDENTIFIER ( ) : datatype { function_body } .)
    PRINT           reduce using rule 14 (function_declaration -> FUNC IDENTIFIER ( ) : datatype { function_body } .)
    IDENTIFIER      reduce using rule 14 (function_declaration -> FUNC IDENTIFIER ( ) : datatype { function_body } .)
    IF              reduce using rule 14 (function_declaration -> FUNC IDENTIFIER ( ) : datatype { function_body } .)
    FUNC            reduce using rule 14 (function_declaration -> FUNC IDENTIFIER ( ) : datatype { function_body } .)
    INT_VALUE       reduce using rule 14 (function_declaration -> FUNC IDENTIFIER ( ) : datatype { function_body } .)
    FLOAT_VALUE     reduce using rule 14 (function_declaration -> FUNC IDENTIFIER ( ) : datatype { function_body } .)
    STRING_VALUE    reduce using rule 14 (function_declaration -> FUNC IDENTIFIER ( ) : datatype { function_body } .)
    (               reduce using rule 14 (function_declaration -> FUNC IDENTIFIER ( ) : datatype { function_body } .)
    UNARY           reduce using rule 14 (function_declaration -> FUNC IDENTIFIER ( ) : datatype { function_body } .)
    INT             reduce using rule 14 (function_declaration -> FUNC IDENTIFIER ( ) : datatype { function_body } .)
    FLOAT           reduce using rule 14 (function_declaration -> FUNC IDENTIFIER ( ) : datatype { function_body } .)
    STRING          reduce using rule 14 (function_declaration -> FUNC IDENTIFIER ( ) : datatype { function_body } .)
    ADAPT           reduce using rule 14 (function_declaration -> FUNC IDENTIFIER ( ) : datatype { function_body } .)
    VOID            reduce using rule 14 (function_declaration -> FUNC IDENTIFIER ( ) : datatype { function_body } .)
    FOR             reduce using rule 14 (function_declaration -> FUNC IDENTIFIER ( ) : datatype { function_body } .)
    WHILE           reduce using rule 14 (function_declaration -> FUNC IDENTIFIER ( ) : datatype { function_body } .)


state 124

    (59) forLoop -> FOR ( expression ; condition ; expression ) { . statements }
    (3) statements -> . statement
    (4) statements -> . statements statement
    (5) statement -> . function_calls
    (6) statement -> . condition
    (7) statement -> . function_declarations
    (8) statement -> . expression
    (9) statement -> . loops
    (10) statement -> . RETURN expression
    (11) statement -> . PRINT ( expression )
    (12) statement -> . assignment
    (16) function_calls -> . IDENTIFIER ( )
    (17) function_calls -> . IDENTIFIER ( ) function_calls
    (18) function_calls -> . IDENTIFIER ( parameters )
    (19) function_calls -> . IDENTIFIER ( parameters ) function_calls
    (53) condition -> . IF expression { statements }
    (54) condition -> . IF expression { statements } ELSE { statements }
    (13) function_declarations -> . function_declaration
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (55) loops -> . loop
    (56) loops -> . loop loops
    (51) assignment -> . datatype IDENTIFIER EQUAL expression
    (52) assignment -> . datatype IDENTIFIER EQUAL ACCEPT ( )
    (14) function_declaration -> . FUNC IDENTIFIER ( ) : datatype { function_body }
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (57) loop -> . forLoop
    (58) loop -> . whileLoop
    (24) datatype -> . INT
    (25) datatype -> . FLOAT
    (26) datatype -> . STRING
    (27) datatype -> . ADAPT
    (28) datatype -> . VOID
    (36) variable -> . IDENTIFIER
    (59) forLoop -> . FOR ( expression ; condition ; expression ) { statements }
    (60) whileLoop -> . WHILE ( condition ) { statements }

    RETURN          shift and go to state 15
    PRINT           shift and go to state 16
    IDENTIFIER      shift and go to state 18
    IF              shift and go to state 19
    FUNC            shift and go to state 26
    INT_VALUE       shift and go to state 27
    FLOAT_VALUE     shift and go to state 28
    STRING_VALUE    shift and go to state 29
    (               shift and go to state 7
    UNARY           shift and go to state 31
    INT             shift and go to state 34
    FLOAT           shift and go to state 35
    STRING          shift and go to state 36
    ADAPT           shift and go to state 37
    VOID            shift and go to state 38
    FOR             shift and go to state 39
    WHILE           shift and go to state 40

    expression                     shift and go to state 13
    condition                      shift and go to state 11
    statements                     shift and go to state 125
    statement                      shift and go to state 9
    function_calls                 shift and go to state 10
    function_declarations          shift and go to state 12
    loops                          shift and go to state 14
    assignment                     shift and go to state 17
    function_declaration           shift and go to state 20
    atoms                          shift and go to state 21
    paren_expr                     shift and go to state 22
    binary_expr                    shift and go to state 23
    loop                           shift and go to state 24
    datatype                       shift and go to state 25
    variable                       shift and go to state 30
    forLoop                        shift and go to state 32
    whileLoop                      shift and go to state 33

state 125

    (59) forLoop -> FOR ( expression ; condition ; expression ) { statements . }
    (4) statements -> statements . statement
    (5) statement -> . function_calls
    (6) statement -> . condition
    (7) statement -> . function_declarations
    (8) statement -> . expression
    (9) statement -> . loops
    (10) statement -> . RETURN expression
    (11) statement -> . PRINT ( expression )
    (12) statement -> . assignment
    (16) function_calls -> . IDENTIFIER ( )
    (17) function_calls -> . IDENTIFIER ( ) function_calls
    (18) function_calls -> . IDENTIFIER ( parameters )
    (19) function_calls -> . IDENTIFIER ( parameters ) function_calls
    (53) condition -> . IF expression { statements }
    (54) condition -> . IF expression { statements } ELSE { statements }
    (13) function_declarations -> . function_declaration
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (55) loops -> . loop
    (56) loops -> . loop loops
    (51) assignment -> . datatype IDENTIFIER EQUAL expression
    (52) assignment -> . datatype IDENTIFIER EQUAL ACCEPT ( )
    (14) function_declaration -> . FUNC IDENTIFIER ( ) : datatype { function_body }
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (57) loop -> . forLoop
    (58) loop -> . whileLoop
    (24) datatype -> . INT
    (25) datatype -> . FLOAT
    (26) datatype -> . STRING
    (27) datatype -> . ADAPT
    (28) datatype -> . VOID
    (36) variable -> . IDENTIFIER
    (59) forLoop -> . FOR ( expression ; condition ; expression ) { statements }
    (60) whileLoop -> . WHILE ( condition ) { statements }

    }               shift and go to state 126
    RETURN          shift and go to state 15
    PRINT           shift and go to state 16
    IDENTIFIER      shift and go to state 18
    IF              shift and go to state 19
    FUNC            shift and go to state 26
    INT_VALUE       shift and go to state 27
    FLOAT_VALUE     shift and go to state 28
    STRING_VALUE    shift and go to state 29
    (               shift and go to state 7
    UNARY           shift and go to state 31
    INT             shift and go to state 34
    FLOAT           shift and go to state 35
    STRING          shift and go to state 36
    ADAPT           shift and go to state 37
    VOID            shift and go to state 38
    FOR             shift and go to state 39
    WHILE           shift and go to state 40

    expression                     shift and go to state 13
    condition                      shift and go to state 11
    statement                      shift and go to state 44
    function_calls                 shift and go to state 10
    function_declarations          shift and go to state 12
    loops                          shift and go to state 14
    assignment                     shift and go to state 17
    function_declaration           shift and go to state 20
    atoms                          shift and go to state 21
    paren_expr                     shift and go to state 22
    binary_expr                    shift and go to state 23
    loop                           shift and go to state 24
    datatype                       shift and go to state 25
    variable                       shift and go to state 30
    forLoop                        shift and go to state 32
    whileLoop                      shift and go to state 33

state 126

    (59) forLoop -> FOR ( expression ; condition ; expression ) { statements } .

    FOR             reduce using rule 59 (forLoop -> FOR ( expression ; condition ; expression ) { statements } .)
    WHILE           reduce using rule 59 (forLoop -> FOR ( expression ; condition ; expression ) { statements } .)
    }               reduce using rule 59 (forLoop -> FOR ( expression ; condition ; expression ) { statements } .)
    RETURN          reduce using rule 59 (forLoop -> FOR ( expression ; condition ; expression ) { statements } .)
    PRINT           reduce using rule 59 (forLoop -> FOR ( expression ; condition ; expression ) { statements } .)
    IDENTIFIER      reduce using rule 59 (forLoop -> FOR ( expression ; condition ; expression ) { statements } .)
    IF              reduce using rule 59 (forLoop -> FOR ( expression ; condition ; expression ) { statements } .)
    FUNC            reduce using rule 59 (forLoop -> FOR ( expression ; condition ; expression ) { statements } .)
    INT_VALUE       reduce using rule 59 (forLoop -> FOR ( expression ; condition ; expression ) { statements } .)
    FLOAT_VALUE     reduce using rule 59 (forLoop -> FOR ( expression ; condition ; expression ) { statements } .)
    STRING_VALUE    reduce using rule 59 (forLoop -> FOR ( expression ; condition ; expression ) { statements } .)
    (               reduce using rule 59 (forLoop -> FOR ( expression ; condition ; expression ) { statements } .)
    UNARY           reduce using rule 59 (forLoop -> FOR ( expression ; condition ; expression ) { statements } .)
    INT             reduce using rule 59 (forLoop -> FOR ( expression ; condition ; expression ) { statements } .)
    FLOAT           reduce using rule 59 (forLoop -> FOR ( expression ; condition ; expression ) { statements } .)
    STRING          reduce using rule 59 (forLoop -> FOR ( expression ; condition ; expression ) { statements } .)
    ADAPT           reduce using rule 59 (forLoop -> FOR ( expression ; condition ; expression ) { statements } .)
    VOID            reduce using rule 59 (forLoop -> FOR ( expression ; condition ; expression ) { statements } .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ( in state 18 resolved as shift
WARNING: shift/reduce conflict for UNARY in state 21 resolved as shift
WARNING: shift/reduce conflict for FOR in state 24 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 24 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 69 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 93 resolved as shift
