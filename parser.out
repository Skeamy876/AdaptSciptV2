Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ACCEPT
    AND
    COMMENTS
    EQUAL
    WHITESPACE

Grammar

Rule 0     S' -> program
Rule 1     program -> programStart
Rule 2     programStart -> FUNC INIT ( ) { statements }
Rule 3     statements -> statement
Rule 4     statements -> statements statement
Rule 5     statement -> function_calls
Rule 6     statement -> condition
Rule 7     statement -> function_declarations
Rule 8     statement -> expression
Rule 9     statement -> loops
Rule 10    statement -> RETURN variable
Rule 11    statement -> PRINT ( variable )
Rule 12    statement -> PRINT ( STRING_VALUE )
Rule 13    function_declarations -> function_declaration
Rule 14    function_declaration -> FUNC IDENTIFIER ( ) : datatype { function_body }
Rule 15    function_body -> statements
Rule 16    function_calls -> IDENTIFIER ( )
Rule 17    function_calls -> IDENTIFIER ( ) function_calls
Rule 18    function_calls -> IDENTIFIER ( parameters )
Rule 19    function_calls -> IDENTIFIER ( parameters ) function_calls
Rule 20    parameters -> parameterList
Rule 21    parameterList -> parameter
Rule 22    parameterList -> parameter , parameterList
Rule 23    parameter -> datatype IDENTIFIER
Rule 24    datatype -> INT
Rule 25    datatype -> FLOAT
Rule 26    datatype -> STRING
Rule 27    datatype -> ADAPT
Rule 28    datatype -> VOID
Rule 29    expression -> atoms
Rule 30    expression -> paren_expr
Rule 31    expression -> binary_expr
Rule 32    atoms -> INT_VALUE
Rule 33    atoms -> FLOAT_VALUE
Rule 34    atoms -> STRING_VALUE
Rule 35    atoms -> variable
Rule 36    variable -> IDENTIFIER
Rule 37    paren_expr -> ( expression )
Rule 38    binary_expr -> atoms ADD expression
Rule 39    binary_expr -> atoms SUB expression
Rule 40    binary_expr -> atoms MUL expression
Rule 41    binary_expr -> atoms DIV expression
Rule 42    binary_expr -> atoms OR expression
Rule 43    binary_expr -> atoms LE expression
Rule 44    binary_expr -> atoms GE expression
Rule 45    binary_expr -> atoms EQ expression
Rule 46    binary_expr -> atoms NE expression
Rule 47    binary_expr -> atoms GT expression
Rule 48    binary_expr -> atoms LT expression
Rule 49    binary_expr -> UNARY atoms
Rule 50    binary_expr -> atoms UNARY
Rule 51    condition -> IF expression { statements }
Rule 52    condition -> IF expression { statements } ELSE { statements }
Rule 53    loops -> loop
Rule 54    loops -> loop loops
Rule 55    loop -> forLoop
Rule 56    loop -> whileLoop
Rule 57    forLoop -> FOR ( expression ; condition ; expression ) { statements }
Rule 58    whileLoop -> WHILE ( condition ) { statements }

Terminals, with rules where they appear

(                    : 2 11 12 14 16 17 18 19 37 57 58
)                    : 2 11 12 14 16 17 18 19 37 57 58
,                    : 22
:                    : 14
;                    : 57 57
ACCEPT               : 
ADAPT                : 27
ADD                  : 38
AND                  : 
COMMENTS             : 
DIV                  : 41
ELSE                 : 52
EQ                   : 45
EQUAL                : 
FLOAT                : 25
FLOAT_VALUE          : 33
FOR                  : 57
FUNC                 : 2 14
GE                   : 44
GT                   : 47
IDENTIFIER           : 14 16 17 18 19 23 36
IF                   : 51 52
INIT                 : 2
INT                  : 24
INT_VALUE            : 32
LE                   : 43
LT                   : 48
MUL                  : 40
NE                   : 46
OR                   : 42
PRINT                : 11 12
RETURN               : 10
STRING               : 26
STRING_VALUE         : 12 34
SUB                  : 39
UNARY                : 49 50
VOID                 : 28
WHILE                : 58
WHITESPACE           : 
error                : 
{                    : 2 14 51 52 52 57 58
}                    : 2 14 51 52 52 57 58

Nonterminals, with rules where they appear

atoms                : 29 38 39 40 41 42 43 44 45 46 47 48 49 50
binary_expr          : 31
condition            : 6 57 58
datatype             : 14 23
expression           : 8 37 38 39 40 41 42 43 44 45 46 47 48 51 52 57 57
forLoop              : 55
function_body        : 14
function_calls       : 5 17 19
function_declaration : 13
function_declarations : 7
loop                 : 53 54
loops                : 9 54
parameter            : 21 22
parameterList        : 20 22
parameters           : 18 19
paren_expr           : 30
program              : 0
programStart         : 1
statement            : 3 4
statements           : 2 4 15 51 52 52 57 58
variable             : 10 11 35
whileLoop            : 56

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . programStart
    (2) programStart -> . FUNC INIT ( ) { statements }

    FUNC            shift and go to state 3

    program                        shift and go to state 1
    programStart                   shift and go to state 2

state 1

    (0) S' -> program .



state 2

    (1) program -> programStart .

    $end            reduce using rule 1 (program -> programStart .)


state 3

    (2) programStart -> FUNC . INIT ( ) { statements }

    INIT            shift and go to state 4


state 4

    (2) programStart -> FUNC INIT . ( ) { statements }

    (               shift and go to state 5


state 5

    (2) programStart -> FUNC INIT ( . ) { statements }

    )               shift and go to state 6


state 6

    (2) programStart -> FUNC INIT ( ) . { statements }

    {               shift and go to state 7


state 7

    (2) programStart -> FUNC INIT ( ) { . statements }
    (3) statements -> . statement
    (4) statements -> . statements statement
    (5) statement -> . function_calls
    (6) statement -> . condition
    (7) statement -> . function_declarations
    (8) statement -> . expression
    (9) statement -> . loops
    (10) statement -> . RETURN variable
    (11) statement -> . PRINT ( variable )
    (12) statement -> . PRINT ( STRING_VALUE )
    (16) function_calls -> . IDENTIFIER ( )
    (17) function_calls -> . IDENTIFIER ( ) function_calls
    (18) function_calls -> . IDENTIFIER ( parameters )
    (19) function_calls -> . IDENTIFIER ( parameters ) function_calls
    (51) condition -> . IF expression { statements }
    (52) condition -> . IF expression { statements } ELSE { statements }
    (13) function_declarations -> . function_declaration
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (53) loops -> . loop
    (54) loops -> . loop loops
    (14) function_declaration -> . FUNC IDENTIFIER ( ) : datatype { function_body }
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (55) loop -> . forLoop
    (56) loop -> . whileLoop
    (36) variable -> . IDENTIFIER
    (57) forLoop -> . FOR ( expression ; condition ; expression ) { statements }
    (58) whileLoop -> . WHILE ( condition ) { statements }

    RETURN          shift and go to state 17
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 21
    IF              shift and go to state 22
    FUNC            shift and go to state 8
    INT_VALUE       shift and go to state 28
    FLOAT_VALUE     shift and go to state 29
    STRING_VALUE    shift and go to state 20
    (               shift and go to state 9
    UNARY           shift and go to state 30
    FOR             shift and go to state 33
    WHILE           shift and go to state 34

    statements                     shift and go to state 10
    statement                      shift and go to state 11
    function_calls                 shift and go to state 12
    condition                      shift and go to state 13
    function_declarations          shift and go to state 14
    expression                     shift and go to state 15
    loops                          shift and go to state 16
    variable                       shift and go to state 18
    function_declaration           shift and go to state 23
    atoms                          shift and go to state 24
    paren_expr                     shift and go to state 25
    binary_expr                    shift and go to state 26
    loop                           shift and go to state 27
    forLoop                        shift and go to state 31
    whileLoop                      shift and go to state 32

state 8

    (14) function_declaration -> FUNC . IDENTIFIER ( ) : datatype { function_body }

    IDENTIFIER      shift and go to state 35


state 9

    (37) paren_expr -> ( . expression )
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (36) variable -> . IDENTIFIER

    INT_VALUE       shift and go to state 28
    FLOAT_VALUE     shift and go to state 29
    STRING_VALUE    shift and go to state 20
    (               shift and go to state 9
    UNARY           shift and go to state 30
    IDENTIFIER      shift and go to state 37

    expression                     shift and go to state 36
    atoms                          shift and go to state 24
    paren_expr                     shift and go to state 25
    binary_expr                    shift and go to state 26
    variable                       shift and go to state 18

state 10

    (2) programStart -> FUNC INIT ( ) { statements . }
    (4) statements -> statements . statement
    (5) statement -> . function_calls
    (6) statement -> . condition
    (7) statement -> . function_declarations
    (8) statement -> . expression
    (9) statement -> . loops
    (10) statement -> . RETURN variable
    (11) statement -> . PRINT ( variable )
    (12) statement -> . PRINT ( STRING_VALUE )
    (16) function_calls -> . IDENTIFIER ( )
    (17) function_calls -> . IDENTIFIER ( ) function_calls
    (18) function_calls -> . IDENTIFIER ( parameters )
    (19) function_calls -> . IDENTIFIER ( parameters ) function_calls
    (51) condition -> . IF expression { statements }
    (52) condition -> . IF expression { statements } ELSE { statements }
    (13) function_declarations -> . function_declaration
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (53) loops -> . loop
    (54) loops -> . loop loops
    (14) function_declaration -> . FUNC IDENTIFIER ( ) : datatype { function_body }
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (55) loop -> . forLoop
    (56) loop -> . whileLoop
    (36) variable -> . IDENTIFIER
    (57) forLoop -> . FOR ( expression ; condition ; expression ) { statements }
    (58) whileLoop -> . WHILE ( condition ) { statements }

    }               shift and go to state 38
    RETURN          shift and go to state 17
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 21
    IF              shift and go to state 22
    FUNC            shift and go to state 8
    INT_VALUE       shift and go to state 28
    FLOAT_VALUE     shift and go to state 29
    STRING_VALUE    shift and go to state 20
    (               shift and go to state 9
    UNARY           shift and go to state 30
    FOR             shift and go to state 33
    WHILE           shift and go to state 34

    statement                      shift and go to state 39
    function_calls                 shift and go to state 12
    condition                      shift and go to state 13
    function_declarations          shift and go to state 14
    expression                     shift and go to state 15
    loops                          shift and go to state 16
    variable                       shift and go to state 18
    function_declaration           shift and go to state 23
    atoms                          shift and go to state 24
    paren_expr                     shift and go to state 25
    binary_expr                    shift and go to state 26
    loop                           shift and go to state 27
    forLoop                        shift and go to state 31
    whileLoop                      shift and go to state 32

state 11

    (3) statements -> statement .

    }               reduce using rule 3 (statements -> statement .)
    RETURN          reduce using rule 3 (statements -> statement .)
    PRINT           reduce using rule 3 (statements -> statement .)
    IDENTIFIER      reduce using rule 3 (statements -> statement .)
    IF              reduce using rule 3 (statements -> statement .)
    FUNC            reduce using rule 3 (statements -> statement .)
    INT_VALUE       reduce using rule 3 (statements -> statement .)
    FLOAT_VALUE     reduce using rule 3 (statements -> statement .)
    STRING_VALUE    reduce using rule 3 (statements -> statement .)
    (               reduce using rule 3 (statements -> statement .)
    UNARY           reduce using rule 3 (statements -> statement .)
    FOR             reduce using rule 3 (statements -> statement .)
    WHILE           reduce using rule 3 (statements -> statement .)


state 12

    (5) statement -> function_calls .

    }               reduce using rule 5 (statement -> function_calls .)
    RETURN          reduce using rule 5 (statement -> function_calls .)
    PRINT           reduce using rule 5 (statement -> function_calls .)
    IDENTIFIER      reduce using rule 5 (statement -> function_calls .)
    IF              reduce using rule 5 (statement -> function_calls .)
    FUNC            reduce using rule 5 (statement -> function_calls .)
    INT_VALUE       reduce using rule 5 (statement -> function_calls .)
    FLOAT_VALUE     reduce using rule 5 (statement -> function_calls .)
    STRING_VALUE    reduce using rule 5 (statement -> function_calls .)
    (               reduce using rule 5 (statement -> function_calls .)
    UNARY           reduce using rule 5 (statement -> function_calls .)
    FOR             reduce using rule 5 (statement -> function_calls .)
    WHILE           reduce using rule 5 (statement -> function_calls .)


state 13

    (6) statement -> condition .

    }               reduce using rule 6 (statement -> condition .)
    RETURN          reduce using rule 6 (statement -> condition .)
    PRINT           reduce using rule 6 (statement -> condition .)
    IDENTIFIER      reduce using rule 6 (statement -> condition .)
    IF              reduce using rule 6 (statement -> condition .)
    FUNC            reduce using rule 6 (statement -> condition .)
    INT_VALUE       reduce using rule 6 (statement -> condition .)
    FLOAT_VALUE     reduce using rule 6 (statement -> condition .)
    STRING_VALUE    reduce using rule 6 (statement -> condition .)
    (               reduce using rule 6 (statement -> condition .)
    UNARY           reduce using rule 6 (statement -> condition .)
    FOR             reduce using rule 6 (statement -> condition .)
    WHILE           reduce using rule 6 (statement -> condition .)


state 14

    (7) statement -> function_declarations .

    }               reduce using rule 7 (statement -> function_declarations .)
    RETURN          reduce using rule 7 (statement -> function_declarations .)
    PRINT           reduce using rule 7 (statement -> function_declarations .)
    IDENTIFIER      reduce using rule 7 (statement -> function_declarations .)
    IF              reduce using rule 7 (statement -> function_declarations .)
    FUNC            reduce using rule 7 (statement -> function_declarations .)
    INT_VALUE       reduce using rule 7 (statement -> function_declarations .)
    FLOAT_VALUE     reduce using rule 7 (statement -> function_declarations .)
    STRING_VALUE    reduce using rule 7 (statement -> function_declarations .)
    (               reduce using rule 7 (statement -> function_declarations .)
    UNARY           reduce using rule 7 (statement -> function_declarations .)
    FOR             reduce using rule 7 (statement -> function_declarations .)
    WHILE           reduce using rule 7 (statement -> function_declarations .)


state 15

    (8) statement -> expression .

    }               reduce using rule 8 (statement -> expression .)
    RETURN          reduce using rule 8 (statement -> expression .)
    PRINT           reduce using rule 8 (statement -> expression .)
    IDENTIFIER      reduce using rule 8 (statement -> expression .)
    IF              reduce using rule 8 (statement -> expression .)
    FUNC            reduce using rule 8 (statement -> expression .)
    INT_VALUE       reduce using rule 8 (statement -> expression .)
    FLOAT_VALUE     reduce using rule 8 (statement -> expression .)
    STRING_VALUE    reduce using rule 8 (statement -> expression .)
    (               reduce using rule 8 (statement -> expression .)
    UNARY           reduce using rule 8 (statement -> expression .)
    FOR             reduce using rule 8 (statement -> expression .)
    WHILE           reduce using rule 8 (statement -> expression .)


state 16

    (9) statement -> loops .

    }               reduce using rule 9 (statement -> loops .)
    RETURN          reduce using rule 9 (statement -> loops .)
    PRINT           reduce using rule 9 (statement -> loops .)
    IDENTIFIER      reduce using rule 9 (statement -> loops .)
    IF              reduce using rule 9 (statement -> loops .)
    FUNC            reduce using rule 9 (statement -> loops .)
    INT_VALUE       reduce using rule 9 (statement -> loops .)
    FLOAT_VALUE     reduce using rule 9 (statement -> loops .)
    STRING_VALUE    reduce using rule 9 (statement -> loops .)
    (               reduce using rule 9 (statement -> loops .)
    UNARY           reduce using rule 9 (statement -> loops .)
    FOR             reduce using rule 9 (statement -> loops .)
    WHILE           reduce using rule 9 (statement -> loops .)


state 17

    (10) statement -> RETURN . variable
    (36) variable -> . IDENTIFIER

    IDENTIFIER      shift and go to state 37

    variable                       shift and go to state 40

state 18

    (35) atoms -> variable .

    ADD             reduce using rule 35 (atoms -> variable .)
    SUB             reduce using rule 35 (atoms -> variable .)
    MUL             reduce using rule 35 (atoms -> variable .)
    DIV             reduce using rule 35 (atoms -> variable .)
    OR              reduce using rule 35 (atoms -> variable .)
    LE              reduce using rule 35 (atoms -> variable .)
    GE              reduce using rule 35 (atoms -> variable .)
    EQ              reduce using rule 35 (atoms -> variable .)
    NE              reduce using rule 35 (atoms -> variable .)
    GT              reduce using rule 35 (atoms -> variable .)
    LT              reduce using rule 35 (atoms -> variable .)
    UNARY           reduce using rule 35 (atoms -> variable .)
    }               reduce using rule 35 (atoms -> variable .)
    RETURN          reduce using rule 35 (atoms -> variable .)
    PRINT           reduce using rule 35 (atoms -> variable .)
    IDENTIFIER      reduce using rule 35 (atoms -> variable .)
    IF              reduce using rule 35 (atoms -> variable .)
    FUNC            reduce using rule 35 (atoms -> variable .)
    INT_VALUE       reduce using rule 35 (atoms -> variable .)
    FLOAT_VALUE     reduce using rule 35 (atoms -> variable .)
    STRING_VALUE    reduce using rule 35 (atoms -> variable .)
    (               reduce using rule 35 (atoms -> variable .)
    FOR             reduce using rule 35 (atoms -> variable .)
    WHILE           reduce using rule 35 (atoms -> variable .)
    )               reduce using rule 35 (atoms -> variable .)
    {               reduce using rule 35 (atoms -> variable .)
    ;               reduce using rule 35 (atoms -> variable .)


state 19

    (11) statement -> PRINT . ( variable )
    (12) statement -> PRINT . ( STRING_VALUE )

    (               shift and go to state 41


state 20

    (34) atoms -> STRING_VALUE .

    ADD             reduce using rule 34 (atoms -> STRING_VALUE .)
    SUB             reduce using rule 34 (atoms -> STRING_VALUE .)
    MUL             reduce using rule 34 (atoms -> STRING_VALUE .)
    DIV             reduce using rule 34 (atoms -> STRING_VALUE .)
    OR              reduce using rule 34 (atoms -> STRING_VALUE .)
    LE              reduce using rule 34 (atoms -> STRING_VALUE .)
    GE              reduce using rule 34 (atoms -> STRING_VALUE .)
    EQ              reduce using rule 34 (atoms -> STRING_VALUE .)
    NE              reduce using rule 34 (atoms -> STRING_VALUE .)
    GT              reduce using rule 34 (atoms -> STRING_VALUE .)
    LT              reduce using rule 34 (atoms -> STRING_VALUE .)
    UNARY           reduce using rule 34 (atoms -> STRING_VALUE .)
    }               reduce using rule 34 (atoms -> STRING_VALUE .)
    RETURN          reduce using rule 34 (atoms -> STRING_VALUE .)
    PRINT           reduce using rule 34 (atoms -> STRING_VALUE .)
    IDENTIFIER      reduce using rule 34 (atoms -> STRING_VALUE .)
    IF              reduce using rule 34 (atoms -> STRING_VALUE .)
    FUNC            reduce using rule 34 (atoms -> STRING_VALUE .)
    INT_VALUE       reduce using rule 34 (atoms -> STRING_VALUE .)
    FLOAT_VALUE     reduce using rule 34 (atoms -> STRING_VALUE .)
    STRING_VALUE    reduce using rule 34 (atoms -> STRING_VALUE .)
    (               reduce using rule 34 (atoms -> STRING_VALUE .)
    FOR             reduce using rule 34 (atoms -> STRING_VALUE .)
    WHILE           reduce using rule 34 (atoms -> STRING_VALUE .)
    )               reduce using rule 34 (atoms -> STRING_VALUE .)
    {               reduce using rule 34 (atoms -> STRING_VALUE .)
    ;               reduce using rule 34 (atoms -> STRING_VALUE .)


state 21

    (16) function_calls -> IDENTIFIER . ( )
    (17) function_calls -> IDENTIFIER . ( ) function_calls
    (18) function_calls -> IDENTIFIER . ( parameters )
    (19) function_calls -> IDENTIFIER . ( parameters ) function_calls
    (36) variable -> IDENTIFIER .

  ! shift/reduce conflict for ( resolved as shift
    (               shift and go to state 42
    ADD             reduce using rule 36 (variable -> IDENTIFIER .)
    SUB             reduce using rule 36 (variable -> IDENTIFIER .)
    MUL             reduce using rule 36 (variable -> IDENTIFIER .)
    DIV             reduce using rule 36 (variable -> IDENTIFIER .)
    OR              reduce using rule 36 (variable -> IDENTIFIER .)
    LE              reduce using rule 36 (variable -> IDENTIFIER .)
    GE              reduce using rule 36 (variable -> IDENTIFIER .)
    EQ              reduce using rule 36 (variable -> IDENTIFIER .)
    NE              reduce using rule 36 (variable -> IDENTIFIER .)
    GT              reduce using rule 36 (variable -> IDENTIFIER .)
    LT              reduce using rule 36 (variable -> IDENTIFIER .)
    UNARY           reduce using rule 36 (variable -> IDENTIFIER .)
    }               reduce using rule 36 (variable -> IDENTIFIER .)
    RETURN          reduce using rule 36 (variable -> IDENTIFIER .)
    PRINT           reduce using rule 36 (variable -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 36 (variable -> IDENTIFIER .)
    IF              reduce using rule 36 (variable -> IDENTIFIER .)
    FUNC            reduce using rule 36 (variable -> IDENTIFIER .)
    INT_VALUE       reduce using rule 36 (variable -> IDENTIFIER .)
    FLOAT_VALUE     reduce using rule 36 (variable -> IDENTIFIER .)
    STRING_VALUE    reduce using rule 36 (variable -> IDENTIFIER .)
    FOR             reduce using rule 36 (variable -> IDENTIFIER .)
    WHILE           reduce using rule 36 (variable -> IDENTIFIER .)

  ! (               [ reduce using rule 36 (variable -> IDENTIFIER .) ]


state 22

    (51) condition -> IF . expression { statements }
    (52) condition -> IF . expression { statements } ELSE { statements }
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (36) variable -> . IDENTIFIER

    INT_VALUE       shift and go to state 28
    FLOAT_VALUE     shift and go to state 29
    STRING_VALUE    shift and go to state 20
    (               shift and go to state 9
    UNARY           shift and go to state 30
    IDENTIFIER      shift and go to state 37

    expression                     shift and go to state 43
    atoms                          shift and go to state 24
    paren_expr                     shift and go to state 25
    binary_expr                    shift and go to state 26
    variable                       shift and go to state 18

state 23

    (13) function_declarations -> function_declaration .

    }               reduce using rule 13 (function_declarations -> function_declaration .)
    RETURN          reduce using rule 13 (function_declarations -> function_declaration .)
    PRINT           reduce using rule 13 (function_declarations -> function_declaration .)
    IDENTIFIER      reduce using rule 13 (function_declarations -> function_declaration .)
    IF              reduce using rule 13 (function_declarations -> function_declaration .)
    FUNC            reduce using rule 13 (function_declarations -> function_declaration .)
    INT_VALUE       reduce using rule 13 (function_declarations -> function_declaration .)
    FLOAT_VALUE     reduce using rule 13 (function_declarations -> function_declaration .)
    STRING_VALUE    reduce using rule 13 (function_declarations -> function_declaration .)
    (               reduce using rule 13 (function_declarations -> function_declaration .)
    UNARY           reduce using rule 13 (function_declarations -> function_declaration .)
    FOR             reduce using rule 13 (function_declarations -> function_declaration .)
    WHILE           reduce using rule 13 (function_declarations -> function_declaration .)


state 24

    (29) expression -> atoms .
    (38) binary_expr -> atoms . ADD expression
    (39) binary_expr -> atoms . SUB expression
    (40) binary_expr -> atoms . MUL expression
    (41) binary_expr -> atoms . DIV expression
    (42) binary_expr -> atoms . OR expression
    (43) binary_expr -> atoms . LE expression
    (44) binary_expr -> atoms . GE expression
    (45) binary_expr -> atoms . EQ expression
    (46) binary_expr -> atoms . NE expression
    (47) binary_expr -> atoms . GT expression
    (48) binary_expr -> atoms . LT expression
    (50) binary_expr -> atoms . UNARY

  ! shift/reduce conflict for UNARY resolved as shift
    }               reduce using rule 29 (expression -> atoms .)
    RETURN          reduce using rule 29 (expression -> atoms .)
    PRINT           reduce using rule 29 (expression -> atoms .)
    IDENTIFIER      reduce using rule 29 (expression -> atoms .)
    IF              reduce using rule 29 (expression -> atoms .)
    FUNC            reduce using rule 29 (expression -> atoms .)
    INT_VALUE       reduce using rule 29 (expression -> atoms .)
    FLOAT_VALUE     reduce using rule 29 (expression -> atoms .)
    STRING_VALUE    reduce using rule 29 (expression -> atoms .)
    (               reduce using rule 29 (expression -> atoms .)
    FOR             reduce using rule 29 (expression -> atoms .)
    WHILE           reduce using rule 29 (expression -> atoms .)
    )               reduce using rule 29 (expression -> atoms .)
    {               reduce using rule 29 (expression -> atoms .)
    ;               reduce using rule 29 (expression -> atoms .)
    ADD             shift and go to state 44
    SUB             shift and go to state 45
    MUL             shift and go to state 46
    DIV             shift and go to state 47
    OR              shift and go to state 48
    LE              shift and go to state 49
    GE              shift and go to state 50
    EQ              shift and go to state 51
    NE              shift and go to state 52
    GT              shift and go to state 53
    LT              shift and go to state 54
    UNARY           shift and go to state 55

  ! UNARY           [ reduce using rule 29 (expression -> atoms .) ]


state 25

    (30) expression -> paren_expr .

    }               reduce using rule 30 (expression -> paren_expr .)
    RETURN          reduce using rule 30 (expression -> paren_expr .)
    PRINT           reduce using rule 30 (expression -> paren_expr .)
    IDENTIFIER      reduce using rule 30 (expression -> paren_expr .)
    IF              reduce using rule 30 (expression -> paren_expr .)
    FUNC            reduce using rule 30 (expression -> paren_expr .)
    INT_VALUE       reduce using rule 30 (expression -> paren_expr .)
    FLOAT_VALUE     reduce using rule 30 (expression -> paren_expr .)
    STRING_VALUE    reduce using rule 30 (expression -> paren_expr .)
    (               reduce using rule 30 (expression -> paren_expr .)
    UNARY           reduce using rule 30 (expression -> paren_expr .)
    FOR             reduce using rule 30 (expression -> paren_expr .)
    WHILE           reduce using rule 30 (expression -> paren_expr .)
    )               reduce using rule 30 (expression -> paren_expr .)
    {               reduce using rule 30 (expression -> paren_expr .)
    ;               reduce using rule 30 (expression -> paren_expr .)


state 26

    (31) expression -> binary_expr .

    }               reduce using rule 31 (expression -> binary_expr .)
    RETURN          reduce using rule 31 (expression -> binary_expr .)
    PRINT           reduce using rule 31 (expression -> binary_expr .)
    IDENTIFIER      reduce using rule 31 (expression -> binary_expr .)
    IF              reduce using rule 31 (expression -> binary_expr .)
    FUNC            reduce using rule 31 (expression -> binary_expr .)
    INT_VALUE       reduce using rule 31 (expression -> binary_expr .)
    FLOAT_VALUE     reduce using rule 31 (expression -> binary_expr .)
    STRING_VALUE    reduce using rule 31 (expression -> binary_expr .)
    (               reduce using rule 31 (expression -> binary_expr .)
    UNARY           reduce using rule 31 (expression -> binary_expr .)
    FOR             reduce using rule 31 (expression -> binary_expr .)
    WHILE           reduce using rule 31 (expression -> binary_expr .)
    )               reduce using rule 31 (expression -> binary_expr .)
    {               reduce using rule 31 (expression -> binary_expr .)
    ;               reduce using rule 31 (expression -> binary_expr .)


state 27

    (53) loops -> loop .
    (54) loops -> loop . loops
    (53) loops -> . loop
    (54) loops -> . loop loops
    (55) loop -> . forLoop
    (56) loop -> . whileLoop
    (57) forLoop -> . FOR ( expression ; condition ; expression ) { statements }
    (58) whileLoop -> . WHILE ( condition ) { statements }

  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
    }               reduce using rule 53 (loops -> loop .)
    RETURN          reduce using rule 53 (loops -> loop .)
    PRINT           reduce using rule 53 (loops -> loop .)
    IDENTIFIER      reduce using rule 53 (loops -> loop .)
    IF              reduce using rule 53 (loops -> loop .)
    FUNC            reduce using rule 53 (loops -> loop .)
    INT_VALUE       reduce using rule 53 (loops -> loop .)
    FLOAT_VALUE     reduce using rule 53 (loops -> loop .)
    STRING_VALUE    reduce using rule 53 (loops -> loop .)
    (               reduce using rule 53 (loops -> loop .)
    UNARY           reduce using rule 53 (loops -> loop .)
    FOR             shift and go to state 33
    WHILE           shift and go to state 34

  ! FOR             [ reduce using rule 53 (loops -> loop .) ]
  ! WHILE           [ reduce using rule 53 (loops -> loop .) ]

    loop                           shift and go to state 27
    loops                          shift and go to state 56
    forLoop                        shift and go to state 31
    whileLoop                      shift and go to state 32

state 28

    (32) atoms -> INT_VALUE .

    ADD             reduce using rule 32 (atoms -> INT_VALUE .)
    SUB             reduce using rule 32 (atoms -> INT_VALUE .)
    MUL             reduce using rule 32 (atoms -> INT_VALUE .)
    DIV             reduce using rule 32 (atoms -> INT_VALUE .)
    OR              reduce using rule 32 (atoms -> INT_VALUE .)
    LE              reduce using rule 32 (atoms -> INT_VALUE .)
    GE              reduce using rule 32 (atoms -> INT_VALUE .)
    EQ              reduce using rule 32 (atoms -> INT_VALUE .)
    NE              reduce using rule 32 (atoms -> INT_VALUE .)
    GT              reduce using rule 32 (atoms -> INT_VALUE .)
    LT              reduce using rule 32 (atoms -> INT_VALUE .)
    UNARY           reduce using rule 32 (atoms -> INT_VALUE .)
    }               reduce using rule 32 (atoms -> INT_VALUE .)
    RETURN          reduce using rule 32 (atoms -> INT_VALUE .)
    PRINT           reduce using rule 32 (atoms -> INT_VALUE .)
    IDENTIFIER      reduce using rule 32 (atoms -> INT_VALUE .)
    IF              reduce using rule 32 (atoms -> INT_VALUE .)
    FUNC            reduce using rule 32 (atoms -> INT_VALUE .)
    INT_VALUE       reduce using rule 32 (atoms -> INT_VALUE .)
    FLOAT_VALUE     reduce using rule 32 (atoms -> INT_VALUE .)
    STRING_VALUE    reduce using rule 32 (atoms -> INT_VALUE .)
    (               reduce using rule 32 (atoms -> INT_VALUE .)
    FOR             reduce using rule 32 (atoms -> INT_VALUE .)
    WHILE           reduce using rule 32 (atoms -> INT_VALUE .)
    )               reduce using rule 32 (atoms -> INT_VALUE .)
    {               reduce using rule 32 (atoms -> INT_VALUE .)
    ;               reduce using rule 32 (atoms -> INT_VALUE .)


state 29

    (33) atoms -> FLOAT_VALUE .

    ADD             reduce using rule 33 (atoms -> FLOAT_VALUE .)
    SUB             reduce using rule 33 (atoms -> FLOAT_VALUE .)
    MUL             reduce using rule 33 (atoms -> FLOAT_VALUE .)
    DIV             reduce using rule 33 (atoms -> FLOAT_VALUE .)
    OR              reduce using rule 33 (atoms -> FLOAT_VALUE .)
    LE              reduce using rule 33 (atoms -> FLOAT_VALUE .)
    GE              reduce using rule 33 (atoms -> FLOAT_VALUE .)
    EQ              reduce using rule 33 (atoms -> FLOAT_VALUE .)
    NE              reduce using rule 33 (atoms -> FLOAT_VALUE .)
    GT              reduce using rule 33 (atoms -> FLOAT_VALUE .)
    LT              reduce using rule 33 (atoms -> FLOAT_VALUE .)
    UNARY           reduce using rule 33 (atoms -> FLOAT_VALUE .)
    }               reduce using rule 33 (atoms -> FLOAT_VALUE .)
    RETURN          reduce using rule 33 (atoms -> FLOAT_VALUE .)
    PRINT           reduce using rule 33 (atoms -> FLOAT_VALUE .)
    IDENTIFIER      reduce using rule 33 (atoms -> FLOAT_VALUE .)
    IF              reduce using rule 33 (atoms -> FLOAT_VALUE .)
    FUNC            reduce using rule 33 (atoms -> FLOAT_VALUE .)
    INT_VALUE       reduce using rule 33 (atoms -> FLOAT_VALUE .)
    FLOAT_VALUE     reduce using rule 33 (atoms -> FLOAT_VALUE .)
    STRING_VALUE    reduce using rule 33 (atoms -> FLOAT_VALUE .)
    (               reduce using rule 33 (atoms -> FLOAT_VALUE .)
    FOR             reduce using rule 33 (atoms -> FLOAT_VALUE .)
    WHILE           reduce using rule 33 (atoms -> FLOAT_VALUE .)
    )               reduce using rule 33 (atoms -> FLOAT_VALUE .)
    {               reduce using rule 33 (atoms -> FLOAT_VALUE .)
    ;               reduce using rule 33 (atoms -> FLOAT_VALUE .)


state 30

    (49) binary_expr -> UNARY . atoms
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (36) variable -> . IDENTIFIER

    INT_VALUE       shift and go to state 28
    FLOAT_VALUE     shift and go to state 29
    STRING_VALUE    shift and go to state 20
    IDENTIFIER      shift and go to state 37

    atoms                          shift and go to state 57
    variable                       shift and go to state 18

state 31

    (55) loop -> forLoop .

    FOR             reduce using rule 55 (loop -> forLoop .)
    WHILE           reduce using rule 55 (loop -> forLoop .)
    }               reduce using rule 55 (loop -> forLoop .)
    RETURN          reduce using rule 55 (loop -> forLoop .)
    PRINT           reduce using rule 55 (loop -> forLoop .)
    IDENTIFIER      reduce using rule 55 (loop -> forLoop .)
    IF              reduce using rule 55 (loop -> forLoop .)
    FUNC            reduce using rule 55 (loop -> forLoop .)
    INT_VALUE       reduce using rule 55 (loop -> forLoop .)
    FLOAT_VALUE     reduce using rule 55 (loop -> forLoop .)
    STRING_VALUE    reduce using rule 55 (loop -> forLoop .)
    (               reduce using rule 55 (loop -> forLoop .)
    UNARY           reduce using rule 55 (loop -> forLoop .)


state 32

    (56) loop -> whileLoop .

    FOR             reduce using rule 56 (loop -> whileLoop .)
    WHILE           reduce using rule 56 (loop -> whileLoop .)
    }               reduce using rule 56 (loop -> whileLoop .)
    RETURN          reduce using rule 56 (loop -> whileLoop .)
    PRINT           reduce using rule 56 (loop -> whileLoop .)
    IDENTIFIER      reduce using rule 56 (loop -> whileLoop .)
    IF              reduce using rule 56 (loop -> whileLoop .)
    FUNC            reduce using rule 56 (loop -> whileLoop .)
    INT_VALUE       reduce using rule 56 (loop -> whileLoop .)
    FLOAT_VALUE     reduce using rule 56 (loop -> whileLoop .)
    STRING_VALUE    reduce using rule 56 (loop -> whileLoop .)
    (               reduce using rule 56 (loop -> whileLoop .)
    UNARY           reduce using rule 56 (loop -> whileLoop .)


state 33

    (57) forLoop -> FOR . ( expression ; condition ; expression ) { statements }

    (               shift and go to state 58


state 34

    (58) whileLoop -> WHILE . ( condition ) { statements }

    (               shift and go to state 59


state 35

    (14) function_declaration -> FUNC IDENTIFIER . ( ) : datatype { function_body }

    (               shift and go to state 60


state 36

    (37) paren_expr -> ( expression . )

    )               shift and go to state 61


state 37

    (36) variable -> IDENTIFIER .

    ADD             reduce using rule 36 (variable -> IDENTIFIER .)
    SUB             reduce using rule 36 (variable -> IDENTIFIER .)
    MUL             reduce using rule 36 (variable -> IDENTIFIER .)
    DIV             reduce using rule 36 (variable -> IDENTIFIER .)
    OR              reduce using rule 36 (variable -> IDENTIFIER .)
    LE              reduce using rule 36 (variable -> IDENTIFIER .)
    GE              reduce using rule 36 (variable -> IDENTIFIER .)
    EQ              reduce using rule 36 (variable -> IDENTIFIER .)
    NE              reduce using rule 36 (variable -> IDENTIFIER .)
    GT              reduce using rule 36 (variable -> IDENTIFIER .)
    LT              reduce using rule 36 (variable -> IDENTIFIER .)
    UNARY           reduce using rule 36 (variable -> IDENTIFIER .)
    )               reduce using rule 36 (variable -> IDENTIFIER .)
    }               reduce using rule 36 (variable -> IDENTIFIER .)
    RETURN          reduce using rule 36 (variable -> IDENTIFIER .)
    PRINT           reduce using rule 36 (variable -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 36 (variable -> IDENTIFIER .)
    IF              reduce using rule 36 (variable -> IDENTIFIER .)
    FUNC            reduce using rule 36 (variable -> IDENTIFIER .)
    INT_VALUE       reduce using rule 36 (variable -> IDENTIFIER .)
    FLOAT_VALUE     reduce using rule 36 (variable -> IDENTIFIER .)
    STRING_VALUE    reduce using rule 36 (variable -> IDENTIFIER .)
    (               reduce using rule 36 (variable -> IDENTIFIER .)
    FOR             reduce using rule 36 (variable -> IDENTIFIER .)
    WHILE           reduce using rule 36 (variable -> IDENTIFIER .)
    {               reduce using rule 36 (variable -> IDENTIFIER .)
    ;               reduce using rule 36 (variable -> IDENTIFIER .)


state 38

    (2) programStart -> FUNC INIT ( ) { statements } .

    $end            reduce using rule 2 (programStart -> FUNC INIT ( ) { statements } .)


state 39

    (4) statements -> statements statement .

    }               reduce using rule 4 (statements -> statements statement .)
    RETURN          reduce using rule 4 (statements -> statements statement .)
    PRINT           reduce using rule 4 (statements -> statements statement .)
    IDENTIFIER      reduce using rule 4 (statements -> statements statement .)
    IF              reduce using rule 4 (statements -> statements statement .)
    FUNC            reduce using rule 4 (statements -> statements statement .)
    INT_VALUE       reduce using rule 4 (statements -> statements statement .)
    FLOAT_VALUE     reduce using rule 4 (statements -> statements statement .)
    STRING_VALUE    reduce using rule 4 (statements -> statements statement .)
    (               reduce using rule 4 (statements -> statements statement .)
    UNARY           reduce using rule 4 (statements -> statements statement .)
    FOR             reduce using rule 4 (statements -> statements statement .)
    WHILE           reduce using rule 4 (statements -> statements statement .)


state 40

    (10) statement -> RETURN variable .

    }               reduce using rule 10 (statement -> RETURN variable .)
    RETURN          reduce using rule 10 (statement -> RETURN variable .)
    PRINT           reduce using rule 10 (statement -> RETURN variable .)
    IDENTIFIER      reduce using rule 10 (statement -> RETURN variable .)
    IF              reduce using rule 10 (statement -> RETURN variable .)
    FUNC            reduce using rule 10 (statement -> RETURN variable .)
    INT_VALUE       reduce using rule 10 (statement -> RETURN variable .)
    FLOAT_VALUE     reduce using rule 10 (statement -> RETURN variable .)
    STRING_VALUE    reduce using rule 10 (statement -> RETURN variable .)
    (               reduce using rule 10 (statement -> RETURN variable .)
    UNARY           reduce using rule 10 (statement -> RETURN variable .)
    FOR             reduce using rule 10 (statement -> RETURN variable .)
    WHILE           reduce using rule 10 (statement -> RETURN variable .)


state 41

    (11) statement -> PRINT ( . variable )
    (12) statement -> PRINT ( . STRING_VALUE )
    (36) variable -> . IDENTIFIER

    STRING_VALUE    shift and go to state 63
    IDENTIFIER      shift and go to state 37

    variable                       shift and go to state 62

state 42

    (16) function_calls -> IDENTIFIER ( . )
    (17) function_calls -> IDENTIFIER ( . ) function_calls
    (18) function_calls -> IDENTIFIER ( . parameters )
    (19) function_calls -> IDENTIFIER ( . parameters ) function_calls
    (20) parameters -> . parameterList
    (21) parameterList -> . parameter
    (22) parameterList -> . parameter , parameterList
    (23) parameter -> . datatype IDENTIFIER
    (24) datatype -> . INT
    (25) datatype -> . FLOAT
    (26) datatype -> . STRING
    (27) datatype -> . ADAPT
    (28) datatype -> . VOID

    )               shift and go to state 64
    INT             shift and go to state 69
    FLOAT           shift and go to state 70
    STRING          shift and go to state 71
    ADAPT           shift and go to state 72
    VOID            shift and go to state 73

    parameters                     shift and go to state 65
    parameterList                  shift and go to state 66
    parameter                      shift and go to state 67
    datatype                       shift and go to state 68

state 43

    (51) condition -> IF expression . { statements }
    (52) condition -> IF expression . { statements } ELSE { statements }

    {               shift and go to state 74


state 44

    (38) binary_expr -> atoms ADD . expression
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (36) variable -> . IDENTIFIER

    INT_VALUE       shift and go to state 28
    FLOAT_VALUE     shift and go to state 29
    STRING_VALUE    shift and go to state 20
    (               shift and go to state 9
    UNARY           shift and go to state 30
    IDENTIFIER      shift and go to state 37

    atoms                          shift and go to state 24
    expression                     shift and go to state 75
    paren_expr                     shift and go to state 25
    binary_expr                    shift and go to state 26
    variable                       shift and go to state 18

state 45

    (39) binary_expr -> atoms SUB . expression
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (36) variable -> . IDENTIFIER

    INT_VALUE       shift and go to state 28
    FLOAT_VALUE     shift and go to state 29
    STRING_VALUE    shift and go to state 20
    (               shift and go to state 9
    UNARY           shift and go to state 30
    IDENTIFIER      shift and go to state 37

    atoms                          shift and go to state 24
    expression                     shift and go to state 76
    paren_expr                     shift and go to state 25
    binary_expr                    shift and go to state 26
    variable                       shift and go to state 18

state 46

    (40) binary_expr -> atoms MUL . expression
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (36) variable -> . IDENTIFIER

    INT_VALUE       shift and go to state 28
    FLOAT_VALUE     shift and go to state 29
    STRING_VALUE    shift and go to state 20
    (               shift and go to state 9
    UNARY           shift and go to state 30
    IDENTIFIER      shift and go to state 37

    atoms                          shift and go to state 24
    expression                     shift and go to state 77
    paren_expr                     shift and go to state 25
    binary_expr                    shift and go to state 26
    variable                       shift and go to state 18

state 47

    (41) binary_expr -> atoms DIV . expression
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (36) variable -> . IDENTIFIER

    INT_VALUE       shift and go to state 28
    FLOAT_VALUE     shift and go to state 29
    STRING_VALUE    shift and go to state 20
    (               shift and go to state 9
    UNARY           shift and go to state 30
    IDENTIFIER      shift and go to state 37

    atoms                          shift and go to state 24
    expression                     shift and go to state 78
    paren_expr                     shift and go to state 25
    binary_expr                    shift and go to state 26
    variable                       shift and go to state 18

state 48

    (42) binary_expr -> atoms OR . expression
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (36) variable -> . IDENTIFIER

    INT_VALUE       shift and go to state 28
    FLOAT_VALUE     shift and go to state 29
    STRING_VALUE    shift and go to state 20
    (               shift and go to state 9
    UNARY           shift and go to state 30
    IDENTIFIER      shift and go to state 37

    atoms                          shift and go to state 24
    expression                     shift and go to state 79
    paren_expr                     shift and go to state 25
    binary_expr                    shift and go to state 26
    variable                       shift and go to state 18

state 49

    (43) binary_expr -> atoms LE . expression
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (36) variable -> . IDENTIFIER

    INT_VALUE       shift and go to state 28
    FLOAT_VALUE     shift and go to state 29
    STRING_VALUE    shift and go to state 20
    (               shift and go to state 9
    UNARY           shift and go to state 30
    IDENTIFIER      shift and go to state 37

    atoms                          shift and go to state 24
    expression                     shift and go to state 80
    paren_expr                     shift and go to state 25
    binary_expr                    shift and go to state 26
    variable                       shift and go to state 18

state 50

    (44) binary_expr -> atoms GE . expression
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (36) variable -> . IDENTIFIER

    INT_VALUE       shift and go to state 28
    FLOAT_VALUE     shift and go to state 29
    STRING_VALUE    shift and go to state 20
    (               shift and go to state 9
    UNARY           shift and go to state 30
    IDENTIFIER      shift and go to state 37

    atoms                          shift and go to state 24
    expression                     shift and go to state 81
    paren_expr                     shift and go to state 25
    binary_expr                    shift and go to state 26
    variable                       shift and go to state 18

state 51

    (45) binary_expr -> atoms EQ . expression
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (36) variable -> . IDENTIFIER

    INT_VALUE       shift and go to state 28
    FLOAT_VALUE     shift and go to state 29
    STRING_VALUE    shift and go to state 20
    (               shift and go to state 9
    UNARY           shift and go to state 30
    IDENTIFIER      shift and go to state 37

    atoms                          shift and go to state 24
    expression                     shift and go to state 82
    paren_expr                     shift and go to state 25
    binary_expr                    shift and go to state 26
    variable                       shift and go to state 18

state 52

    (46) binary_expr -> atoms NE . expression
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (36) variable -> . IDENTIFIER

    INT_VALUE       shift and go to state 28
    FLOAT_VALUE     shift and go to state 29
    STRING_VALUE    shift and go to state 20
    (               shift and go to state 9
    UNARY           shift and go to state 30
    IDENTIFIER      shift and go to state 37

    atoms                          shift and go to state 24
    expression                     shift and go to state 83
    paren_expr                     shift and go to state 25
    binary_expr                    shift and go to state 26
    variable                       shift and go to state 18

state 53

    (47) binary_expr -> atoms GT . expression
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (36) variable -> . IDENTIFIER

    INT_VALUE       shift and go to state 28
    FLOAT_VALUE     shift and go to state 29
    STRING_VALUE    shift and go to state 20
    (               shift and go to state 9
    UNARY           shift and go to state 30
    IDENTIFIER      shift and go to state 37

    atoms                          shift and go to state 24
    expression                     shift and go to state 84
    paren_expr                     shift and go to state 25
    binary_expr                    shift and go to state 26
    variable                       shift and go to state 18

state 54

    (48) binary_expr -> atoms LT . expression
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (36) variable -> . IDENTIFIER

    INT_VALUE       shift and go to state 28
    FLOAT_VALUE     shift and go to state 29
    STRING_VALUE    shift and go to state 20
    (               shift and go to state 9
    UNARY           shift and go to state 30
    IDENTIFIER      shift and go to state 37

    atoms                          shift and go to state 24
    expression                     shift and go to state 85
    paren_expr                     shift and go to state 25
    binary_expr                    shift and go to state 26
    variable                       shift and go to state 18

state 55

    (50) binary_expr -> atoms UNARY .

    }               reduce using rule 50 (binary_expr -> atoms UNARY .)
    RETURN          reduce using rule 50 (binary_expr -> atoms UNARY .)
    PRINT           reduce using rule 50 (binary_expr -> atoms UNARY .)
    IDENTIFIER      reduce using rule 50 (binary_expr -> atoms UNARY .)
    IF              reduce using rule 50 (binary_expr -> atoms UNARY .)
    FUNC            reduce using rule 50 (binary_expr -> atoms UNARY .)
    INT_VALUE       reduce using rule 50 (binary_expr -> atoms UNARY .)
    FLOAT_VALUE     reduce using rule 50 (binary_expr -> atoms UNARY .)
    STRING_VALUE    reduce using rule 50 (binary_expr -> atoms UNARY .)
    (               reduce using rule 50 (binary_expr -> atoms UNARY .)
    UNARY           reduce using rule 50 (binary_expr -> atoms UNARY .)
    FOR             reduce using rule 50 (binary_expr -> atoms UNARY .)
    WHILE           reduce using rule 50 (binary_expr -> atoms UNARY .)
    )               reduce using rule 50 (binary_expr -> atoms UNARY .)
    {               reduce using rule 50 (binary_expr -> atoms UNARY .)
    ;               reduce using rule 50 (binary_expr -> atoms UNARY .)


state 56

    (54) loops -> loop loops .

    }               reduce using rule 54 (loops -> loop loops .)
    RETURN          reduce using rule 54 (loops -> loop loops .)
    PRINT           reduce using rule 54 (loops -> loop loops .)
    IDENTIFIER      reduce using rule 54 (loops -> loop loops .)
    IF              reduce using rule 54 (loops -> loop loops .)
    FUNC            reduce using rule 54 (loops -> loop loops .)
    INT_VALUE       reduce using rule 54 (loops -> loop loops .)
    FLOAT_VALUE     reduce using rule 54 (loops -> loop loops .)
    STRING_VALUE    reduce using rule 54 (loops -> loop loops .)
    (               reduce using rule 54 (loops -> loop loops .)
    UNARY           reduce using rule 54 (loops -> loop loops .)
    FOR             reduce using rule 54 (loops -> loop loops .)
    WHILE           reduce using rule 54 (loops -> loop loops .)


state 57

    (49) binary_expr -> UNARY atoms .

    }               reduce using rule 49 (binary_expr -> UNARY atoms .)
    RETURN          reduce using rule 49 (binary_expr -> UNARY atoms .)
    PRINT           reduce using rule 49 (binary_expr -> UNARY atoms .)
    IDENTIFIER      reduce using rule 49 (binary_expr -> UNARY atoms .)
    IF              reduce using rule 49 (binary_expr -> UNARY atoms .)
    FUNC            reduce using rule 49 (binary_expr -> UNARY atoms .)
    INT_VALUE       reduce using rule 49 (binary_expr -> UNARY atoms .)
    FLOAT_VALUE     reduce using rule 49 (binary_expr -> UNARY atoms .)
    STRING_VALUE    reduce using rule 49 (binary_expr -> UNARY atoms .)
    (               reduce using rule 49 (binary_expr -> UNARY atoms .)
    UNARY           reduce using rule 49 (binary_expr -> UNARY atoms .)
    FOR             reduce using rule 49 (binary_expr -> UNARY atoms .)
    WHILE           reduce using rule 49 (binary_expr -> UNARY atoms .)
    )               reduce using rule 49 (binary_expr -> UNARY atoms .)
    {               reduce using rule 49 (binary_expr -> UNARY atoms .)
    ;               reduce using rule 49 (binary_expr -> UNARY atoms .)


state 58

    (57) forLoop -> FOR ( . expression ; condition ; expression ) { statements }
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (36) variable -> . IDENTIFIER

    INT_VALUE       shift and go to state 28
    FLOAT_VALUE     shift and go to state 29
    STRING_VALUE    shift and go to state 20
    (               shift and go to state 9
    UNARY           shift and go to state 30
    IDENTIFIER      shift and go to state 37

    expression                     shift and go to state 86
    atoms                          shift and go to state 24
    paren_expr                     shift and go to state 25
    binary_expr                    shift and go to state 26
    variable                       shift and go to state 18

state 59

    (58) whileLoop -> WHILE ( . condition ) { statements }
    (51) condition -> . IF expression { statements }
    (52) condition -> . IF expression { statements } ELSE { statements }

    IF              shift and go to state 22

    condition                      shift and go to state 87

state 60

    (14) function_declaration -> FUNC IDENTIFIER ( . ) : datatype { function_body }

    )               shift and go to state 88


state 61

    (37) paren_expr -> ( expression ) .

    }               reduce using rule 37 (paren_expr -> ( expression ) .)
    RETURN          reduce using rule 37 (paren_expr -> ( expression ) .)
    PRINT           reduce using rule 37 (paren_expr -> ( expression ) .)
    IDENTIFIER      reduce using rule 37 (paren_expr -> ( expression ) .)
    IF              reduce using rule 37 (paren_expr -> ( expression ) .)
    FUNC            reduce using rule 37 (paren_expr -> ( expression ) .)
    INT_VALUE       reduce using rule 37 (paren_expr -> ( expression ) .)
    FLOAT_VALUE     reduce using rule 37 (paren_expr -> ( expression ) .)
    STRING_VALUE    reduce using rule 37 (paren_expr -> ( expression ) .)
    (               reduce using rule 37 (paren_expr -> ( expression ) .)
    UNARY           reduce using rule 37 (paren_expr -> ( expression ) .)
    FOR             reduce using rule 37 (paren_expr -> ( expression ) .)
    WHILE           reduce using rule 37 (paren_expr -> ( expression ) .)
    )               reduce using rule 37 (paren_expr -> ( expression ) .)
    {               reduce using rule 37 (paren_expr -> ( expression ) .)
    ;               reduce using rule 37 (paren_expr -> ( expression ) .)


state 62

    (11) statement -> PRINT ( variable . )

    )               shift and go to state 89


state 63

    (12) statement -> PRINT ( STRING_VALUE . )

    )               shift and go to state 90


state 64

    (16) function_calls -> IDENTIFIER ( ) .
    (17) function_calls -> IDENTIFIER ( ) . function_calls
    (16) function_calls -> . IDENTIFIER ( )
    (17) function_calls -> . IDENTIFIER ( ) function_calls
    (18) function_calls -> . IDENTIFIER ( parameters )
    (19) function_calls -> . IDENTIFIER ( parameters ) function_calls

  ! shift/reduce conflict for IDENTIFIER resolved as shift
    }               reduce using rule 16 (function_calls -> IDENTIFIER ( ) .)
    RETURN          reduce using rule 16 (function_calls -> IDENTIFIER ( ) .)
    PRINT           reduce using rule 16 (function_calls -> IDENTIFIER ( ) .)
    IF              reduce using rule 16 (function_calls -> IDENTIFIER ( ) .)
    FUNC            reduce using rule 16 (function_calls -> IDENTIFIER ( ) .)
    INT_VALUE       reduce using rule 16 (function_calls -> IDENTIFIER ( ) .)
    FLOAT_VALUE     reduce using rule 16 (function_calls -> IDENTIFIER ( ) .)
    STRING_VALUE    reduce using rule 16 (function_calls -> IDENTIFIER ( ) .)
    (               reduce using rule 16 (function_calls -> IDENTIFIER ( ) .)
    UNARY           reduce using rule 16 (function_calls -> IDENTIFIER ( ) .)
    FOR             reduce using rule 16 (function_calls -> IDENTIFIER ( ) .)
    WHILE           reduce using rule 16 (function_calls -> IDENTIFIER ( ) .)
    IDENTIFIER      shift and go to state 91

  ! IDENTIFIER      [ reduce using rule 16 (function_calls -> IDENTIFIER ( ) .) ]

    function_calls                 shift and go to state 92

state 65

    (18) function_calls -> IDENTIFIER ( parameters . )
    (19) function_calls -> IDENTIFIER ( parameters . ) function_calls

    )               shift and go to state 93


state 66

    (20) parameters -> parameterList .

    )               reduce using rule 20 (parameters -> parameterList .)


state 67

    (21) parameterList -> parameter .
    (22) parameterList -> parameter . , parameterList

    )               reduce using rule 21 (parameterList -> parameter .)
    ,               shift and go to state 94


state 68

    (23) parameter -> datatype . IDENTIFIER

    IDENTIFIER      shift and go to state 95


state 69

    (24) datatype -> INT .

    IDENTIFIER      reduce using rule 24 (datatype -> INT .)
    {               reduce using rule 24 (datatype -> INT .)


state 70

    (25) datatype -> FLOAT .

    IDENTIFIER      reduce using rule 25 (datatype -> FLOAT .)
    {               reduce using rule 25 (datatype -> FLOAT .)


state 71

    (26) datatype -> STRING .

    IDENTIFIER      reduce using rule 26 (datatype -> STRING .)
    {               reduce using rule 26 (datatype -> STRING .)


state 72

    (27) datatype -> ADAPT .

    IDENTIFIER      reduce using rule 27 (datatype -> ADAPT .)
    {               reduce using rule 27 (datatype -> ADAPT .)


state 73

    (28) datatype -> VOID .

    IDENTIFIER      reduce using rule 28 (datatype -> VOID .)
    {               reduce using rule 28 (datatype -> VOID .)


state 74

    (51) condition -> IF expression { . statements }
    (52) condition -> IF expression { . statements } ELSE { statements }
    (3) statements -> . statement
    (4) statements -> . statements statement
    (5) statement -> . function_calls
    (6) statement -> . condition
    (7) statement -> . function_declarations
    (8) statement -> . expression
    (9) statement -> . loops
    (10) statement -> . RETURN variable
    (11) statement -> . PRINT ( variable )
    (12) statement -> . PRINT ( STRING_VALUE )
    (16) function_calls -> . IDENTIFIER ( )
    (17) function_calls -> . IDENTIFIER ( ) function_calls
    (18) function_calls -> . IDENTIFIER ( parameters )
    (19) function_calls -> . IDENTIFIER ( parameters ) function_calls
    (51) condition -> . IF expression { statements }
    (52) condition -> . IF expression { statements } ELSE { statements }
    (13) function_declarations -> . function_declaration
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (53) loops -> . loop
    (54) loops -> . loop loops
    (14) function_declaration -> . FUNC IDENTIFIER ( ) : datatype { function_body }
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (55) loop -> . forLoop
    (56) loop -> . whileLoop
    (36) variable -> . IDENTIFIER
    (57) forLoop -> . FOR ( expression ; condition ; expression ) { statements }
    (58) whileLoop -> . WHILE ( condition ) { statements }

    RETURN          shift and go to state 17
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 21
    IF              shift and go to state 22
    FUNC            shift and go to state 8
    INT_VALUE       shift and go to state 28
    FLOAT_VALUE     shift and go to state 29
    STRING_VALUE    shift and go to state 20
    (               shift and go to state 9
    UNARY           shift and go to state 30
    FOR             shift and go to state 33
    WHILE           shift and go to state 34

    expression                     shift and go to state 15
    statements                     shift and go to state 96
    statement                      shift and go to state 11
    function_calls                 shift and go to state 12
    condition                      shift and go to state 13
    function_declarations          shift and go to state 14
    loops                          shift and go to state 16
    variable                       shift and go to state 18
    function_declaration           shift and go to state 23
    atoms                          shift and go to state 24
    paren_expr                     shift and go to state 25
    binary_expr                    shift and go to state 26
    loop                           shift and go to state 27
    forLoop                        shift and go to state 31
    whileLoop                      shift and go to state 32

state 75

    (38) binary_expr -> atoms ADD expression .

    }               reduce using rule 38 (binary_expr -> atoms ADD expression .)
    RETURN          reduce using rule 38 (binary_expr -> atoms ADD expression .)
    PRINT           reduce using rule 38 (binary_expr -> atoms ADD expression .)
    IDENTIFIER      reduce using rule 38 (binary_expr -> atoms ADD expression .)
    IF              reduce using rule 38 (binary_expr -> atoms ADD expression .)
    FUNC            reduce using rule 38 (binary_expr -> atoms ADD expression .)
    INT_VALUE       reduce using rule 38 (binary_expr -> atoms ADD expression .)
    FLOAT_VALUE     reduce using rule 38 (binary_expr -> atoms ADD expression .)
    STRING_VALUE    reduce using rule 38 (binary_expr -> atoms ADD expression .)
    (               reduce using rule 38 (binary_expr -> atoms ADD expression .)
    UNARY           reduce using rule 38 (binary_expr -> atoms ADD expression .)
    FOR             reduce using rule 38 (binary_expr -> atoms ADD expression .)
    WHILE           reduce using rule 38 (binary_expr -> atoms ADD expression .)
    )               reduce using rule 38 (binary_expr -> atoms ADD expression .)
    {               reduce using rule 38 (binary_expr -> atoms ADD expression .)
    ;               reduce using rule 38 (binary_expr -> atoms ADD expression .)


state 76

    (39) binary_expr -> atoms SUB expression .

    }               reduce using rule 39 (binary_expr -> atoms SUB expression .)
    RETURN          reduce using rule 39 (binary_expr -> atoms SUB expression .)
    PRINT           reduce using rule 39 (binary_expr -> atoms SUB expression .)
    IDENTIFIER      reduce using rule 39 (binary_expr -> atoms SUB expression .)
    IF              reduce using rule 39 (binary_expr -> atoms SUB expression .)
    FUNC            reduce using rule 39 (binary_expr -> atoms SUB expression .)
    INT_VALUE       reduce using rule 39 (binary_expr -> atoms SUB expression .)
    FLOAT_VALUE     reduce using rule 39 (binary_expr -> atoms SUB expression .)
    STRING_VALUE    reduce using rule 39 (binary_expr -> atoms SUB expression .)
    (               reduce using rule 39 (binary_expr -> atoms SUB expression .)
    UNARY           reduce using rule 39 (binary_expr -> atoms SUB expression .)
    FOR             reduce using rule 39 (binary_expr -> atoms SUB expression .)
    WHILE           reduce using rule 39 (binary_expr -> atoms SUB expression .)
    )               reduce using rule 39 (binary_expr -> atoms SUB expression .)
    {               reduce using rule 39 (binary_expr -> atoms SUB expression .)
    ;               reduce using rule 39 (binary_expr -> atoms SUB expression .)


state 77

    (40) binary_expr -> atoms MUL expression .

    }               reduce using rule 40 (binary_expr -> atoms MUL expression .)
    RETURN          reduce using rule 40 (binary_expr -> atoms MUL expression .)
    PRINT           reduce using rule 40 (binary_expr -> atoms MUL expression .)
    IDENTIFIER      reduce using rule 40 (binary_expr -> atoms MUL expression .)
    IF              reduce using rule 40 (binary_expr -> atoms MUL expression .)
    FUNC            reduce using rule 40 (binary_expr -> atoms MUL expression .)
    INT_VALUE       reduce using rule 40 (binary_expr -> atoms MUL expression .)
    FLOAT_VALUE     reduce using rule 40 (binary_expr -> atoms MUL expression .)
    STRING_VALUE    reduce using rule 40 (binary_expr -> atoms MUL expression .)
    (               reduce using rule 40 (binary_expr -> atoms MUL expression .)
    UNARY           reduce using rule 40 (binary_expr -> atoms MUL expression .)
    FOR             reduce using rule 40 (binary_expr -> atoms MUL expression .)
    WHILE           reduce using rule 40 (binary_expr -> atoms MUL expression .)
    )               reduce using rule 40 (binary_expr -> atoms MUL expression .)
    {               reduce using rule 40 (binary_expr -> atoms MUL expression .)
    ;               reduce using rule 40 (binary_expr -> atoms MUL expression .)


state 78

    (41) binary_expr -> atoms DIV expression .

    }               reduce using rule 41 (binary_expr -> atoms DIV expression .)
    RETURN          reduce using rule 41 (binary_expr -> atoms DIV expression .)
    PRINT           reduce using rule 41 (binary_expr -> atoms DIV expression .)
    IDENTIFIER      reduce using rule 41 (binary_expr -> atoms DIV expression .)
    IF              reduce using rule 41 (binary_expr -> atoms DIV expression .)
    FUNC            reduce using rule 41 (binary_expr -> atoms DIV expression .)
    INT_VALUE       reduce using rule 41 (binary_expr -> atoms DIV expression .)
    FLOAT_VALUE     reduce using rule 41 (binary_expr -> atoms DIV expression .)
    STRING_VALUE    reduce using rule 41 (binary_expr -> atoms DIV expression .)
    (               reduce using rule 41 (binary_expr -> atoms DIV expression .)
    UNARY           reduce using rule 41 (binary_expr -> atoms DIV expression .)
    FOR             reduce using rule 41 (binary_expr -> atoms DIV expression .)
    WHILE           reduce using rule 41 (binary_expr -> atoms DIV expression .)
    )               reduce using rule 41 (binary_expr -> atoms DIV expression .)
    {               reduce using rule 41 (binary_expr -> atoms DIV expression .)
    ;               reduce using rule 41 (binary_expr -> atoms DIV expression .)


state 79

    (42) binary_expr -> atoms OR expression .

    }               reduce using rule 42 (binary_expr -> atoms OR expression .)
    RETURN          reduce using rule 42 (binary_expr -> atoms OR expression .)
    PRINT           reduce using rule 42 (binary_expr -> atoms OR expression .)
    IDENTIFIER      reduce using rule 42 (binary_expr -> atoms OR expression .)
    IF              reduce using rule 42 (binary_expr -> atoms OR expression .)
    FUNC            reduce using rule 42 (binary_expr -> atoms OR expression .)
    INT_VALUE       reduce using rule 42 (binary_expr -> atoms OR expression .)
    FLOAT_VALUE     reduce using rule 42 (binary_expr -> atoms OR expression .)
    STRING_VALUE    reduce using rule 42 (binary_expr -> atoms OR expression .)
    (               reduce using rule 42 (binary_expr -> atoms OR expression .)
    UNARY           reduce using rule 42 (binary_expr -> atoms OR expression .)
    FOR             reduce using rule 42 (binary_expr -> atoms OR expression .)
    WHILE           reduce using rule 42 (binary_expr -> atoms OR expression .)
    )               reduce using rule 42 (binary_expr -> atoms OR expression .)
    {               reduce using rule 42 (binary_expr -> atoms OR expression .)
    ;               reduce using rule 42 (binary_expr -> atoms OR expression .)


state 80

    (43) binary_expr -> atoms LE expression .

    }               reduce using rule 43 (binary_expr -> atoms LE expression .)
    RETURN          reduce using rule 43 (binary_expr -> atoms LE expression .)
    PRINT           reduce using rule 43 (binary_expr -> atoms LE expression .)
    IDENTIFIER      reduce using rule 43 (binary_expr -> atoms LE expression .)
    IF              reduce using rule 43 (binary_expr -> atoms LE expression .)
    FUNC            reduce using rule 43 (binary_expr -> atoms LE expression .)
    INT_VALUE       reduce using rule 43 (binary_expr -> atoms LE expression .)
    FLOAT_VALUE     reduce using rule 43 (binary_expr -> atoms LE expression .)
    STRING_VALUE    reduce using rule 43 (binary_expr -> atoms LE expression .)
    (               reduce using rule 43 (binary_expr -> atoms LE expression .)
    UNARY           reduce using rule 43 (binary_expr -> atoms LE expression .)
    FOR             reduce using rule 43 (binary_expr -> atoms LE expression .)
    WHILE           reduce using rule 43 (binary_expr -> atoms LE expression .)
    )               reduce using rule 43 (binary_expr -> atoms LE expression .)
    {               reduce using rule 43 (binary_expr -> atoms LE expression .)
    ;               reduce using rule 43 (binary_expr -> atoms LE expression .)


state 81

    (44) binary_expr -> atoms GE expression .

    }               reduce using rule 44 (binary_expr -> atoms GE expression .)
    RETURN          reduce using rule 44 (binary_expr -> atoms GE expression .)
    PRINT           reduce using rule 44 (binary_expr -> atoms GE expression .)
    IDENTIFIER      reduce using rule 44 (binary_expr -> atoms GE expression .)
    IF              reduce using rule 44 (binary_expr -> atoms GE expression .)
    FUNC            reduce using rule 44 (binary_expr -> atoms GE expression .)
    INT_VALUE       reduce using rule 44 (binary_expr -> atoms GE expression .)
    FLOAT_VALUE     reduce using rule 44 (binary_expr -> atoms GE expression .)
    STRING_VALUE    reduce using rule 44 (binary_expr -> atoms GE expression .)
    (               reduce using rule 44 (binary_expr -> atoms GE expression .)
    UNARY           reduce using rule 44 (binary_expr -> atoms GE expression .)
    FOR             reduce using rule 44 (binary_expr -> atoms GE expression .)
    WHILE           reduce using rule 44 (binary_expr -> atoms GE expression .)
    )               reduce using rule 44 (binary_expr -> atoms GE expression .)
    {               reduce using rule 44 (binary_expr -> atoms GE expression .)
    ;               reduce using rule 44 (binary_expr -> atoms GE expression .)


state 82

    (45) binary_expr -> atoms EQ expression .

    }               reduce using rule 45 (binary_expr -> atoms EQ expression .)
    RETURN          reduce using rule 45 (binary_expr -> atoms EQ expression .)
    PRINT           reduce using rule 45 (binary_expr -> atoms EQ expression .)
    IDENTIFIER      reduce using rule 45 (binary_expr -> atoms EQ expression .)
    IF              reduce using rule 45 (binary_expr -> atoms EQ expression .)
    FUNC            reduce using rule 45 (binary_expr -> atoms EQ expression .)
    INT_VALUE       reduce using rule 45 (binary_expr -> atoms EQ expression .)
    FLOAT_VALUE     reduce using rule 45 (binary_expr -> atoms EQ expression .)
    STRING_VALUE    reduce using rule 45 (binary_expr -> atoms EQ expression .)
    (               reduce using rule 45 (binary_expr -> atoms EQ expression .)
    UNARY           reduce using rule 45 (binary_expr -> atoms EQ expression .)
    FOR             reduce using rule 45 (binary_expr -> atoms EQ expression .)
    WHILE           reduce using rule 45 (binary_expr -> atoms EQ expression .)
    )               reduce using rule 45 (binary_expr -> atoms EQ expression .)
    {               reduce using rule 45 (binary_expr -> atoms EQ expression .)
    ;               reduce using rule 45 (binary_expr -> atoms EQ expression .)


state 83

    (46) binary_expr -> atoms NE expression .

    }               reduce using rule 46 (binary_expr -> atoms NE expression .)
    RETURN          reduce using rule 46 (binary_expr -> atoms NE expression .)
    PRINT           reduce using rule 46 (binary_expr -> atoms NE expression .)
    IDENTIFIER      reduce using rule 46 (binary_expr -> atoms NE expression .)
    IF              reduce using rule 46 (binary_expr -> atoms NE expression .)
    FUNC            reduce using rule 46 (binary_expr -> atoms NE expression .)
    INT_VALUE       reduce using rule 46 (binary_expr -> atoms NE expression .)
    FLOAT_VALUE     reduce using rule 46 (binary_expr -> atoms NE expression .)
    STRING_VALUE    reduce using rule 46 (binary_expr -> atoms NE expression .)
    (               reduce using rule 46 (binary_expr -> atoms NE expression .)
    UNARY           reduce using rule 46 (binary_expr -> atoms NE expression .)
    FOR             reduce using rule 46 (binary_expr -> atoms NE expression .)
    WHILE           reduce using rule 46 (binary_expr -> atoms NE expression .)
    )               reduce using rule 46 (binary_expr -> atoms NE expression .)
    {               reduce using rule 46 (binary_expr -> atoms NE expression .)
    ;               reduce using rule 46 (binary_expr -> atoms NE expression .)


state 84

    (47) binary_expr -> atoms GT expression .

    }               reduce using rule 47 (binary_expr -> atoms GT expression .)
    RETURN          reduce using rule 47 (binary_expr -> atoms GT expression .)
    PRINT           reduce using rule 47 (binary_expr -> atoms GT expression .)
    IDENTIFIER      reduce using rule 47 (binary_expr -> atoms GT expression .)
    IF              reduce using rule 47 (binary_expr -> atoms GT expression .)
    FUNC            reduce using rule 47 (binary_expr -> atoms GT expression .)
    INT_VALUE       reduce using rule 47 (binary_expr -> atoms GT expression .)
    FLOAT_VALUE     reduce using rule 47 (binary_expr -> atoms GT expression .)
    STRING_VALUE    reduce using rule 47 (binary_expr -> atoms GT expression .)
    (               reduce using rule 47 (binary_expr -> atoms GT expression .)
    UNARY           reduce using rule 47 (binary_expr -> atoms GT expression .)
    FOR             reduce using rule 47 (binary_expr -> atoms GT expression .)
    WHILE           reduce using rule 47 (binary_expr -> atoms GT expression .)
    )               reduce using rule 47 (binary_expr -> atoms GT expression .)
    {               reduce using rule 47 (binary_expr -> atoms GT expression .)
    ;               reduce using rule 47 (binary_expr -> atoms GT expression .)


state 85

    (48) binary_expr -> atoms LT expression .

    }               reduce using rule 48 (binary_expr -> atoms LT expression .)
    RETURN          reduce using rule 48 (binary_expr -> atoms LT expression .)
    PRINT           reduce using rule 48 (binary_expr -> atoms LT expression .)
    IDENTIFIER      reduce using rule 48 (binary_expr -> atoms LT expression .)
    IF              reduce using rule 48 (binary_expr -> atoms LT expression .)
    FUNC            reduce using rule 48 (binary_expr -> atoms LT expression .)
    INT_VALUE       reduce using rule 48 (binary_expr -> atoms LT expression .)
    FLOAT_VALUE     reduce using rule 48 (binary_expr -> atoms LT expression .)
    STRING_VALUE    reduce using rule 48 (binary_expr -> atoms LT expression .)
    (               reduce using rule 48 (binary_expr -> atoms LT expression .)
    UNARY           reduce using rule 48 (binary_expr -> atoms LT expression .)
    FOR             reduce using rule 48 (binary_expr -> atoms LT expression .)
    WHILE           reduce using rule 48 (binary_expr -> atoms LT expression .)
    )               reduce using rule 48 (binary_expr -> atoms LT expression .)
    {               reduce using rule 48 (binary_expr -> atoms LT expression .)
    ;               reduce using rule 48 (binary_expr -> atoms LT expression .)


state 86

    (57) forLoop -> FOR ( expression . ; condition ; expression ) { statements }

    ;               shift and go to state 97


state 87

    (58) whileLoop -> WHILE ( condition . ) { statements }

    )               shift and go to state 98


state 88

    (14) function_declaration -> FUNC IDENTIFIER ( ) . : datatype { function_body }

    :               shift and go to state 99


state 89

    (11) statement -> PRINT ( variable ) .

    }               reduce using rule 11 (statement -> PRINT ( variable ) .)
    RETURN          reduce using rule 11 (statement -> PRINT ( variable ) .)
    PRINT           reduce using rule 11 (statement -> PRINT ( variable ) .)
    IDENTIFIER      reduce using rule 11 (statement -> PRINT ( variable ) .)
    IF              reduce using rule 11 (statement -> PRINT ( variable ) .)
    FUNC            reduce using rule 11 (statement -> PRINT ( variable ) .)
    INT_VALUE       reduce using rule 11 (statement -> PRINT ( variable ) .)
    FLOAT_VALUE     reduce using rule 11 (statement -> PRINT ( variable ) .)
    STRING_VALUE    reduce using rule 11 (statement -> PRINT ( variable ) .)
    (               reduce using rule 11 (statement -> PRINT ( variable ) .)
    UNARY           reduce using rule 11 (statement -> PRINT ( variable ) .)
    FOR             reduce using rule 11 (statement -> PRINT ( variable ) .)
    WHILE           reduce using rule 11 (statement -> PRINT ( variable ) .)


state 90

    (12) statement -> PRINT ( STRING_VALUE ) .

    }               reduce using rule 12 (statement -> PRINT ( STRING_VALUE ) .)
    RETURN          reduce using rule 12 (statement -> PRINT ( STRING_VALUE ) .)
    PRINT           reduce using rule 12 (statement -> PRINT ( STRING_VALUE ) .)
    IDENTIFIER      reduce using rule 12 (statement -> PRINT ( STRING_VALUE ) .)
    IF              reduce using rule 12 (statement -> PRINT ( STRING_VALUE ) .)
    FUNC            reduce using rule 12 (statement -> PRINT ( STRING_VALUE ) .)
    INT_VALUE       reduce using rule 12 (statement -> PRINT ( STRING_VALUE ) .)
    FLOAT_VALUE     reduce using rule 12 (statement -> PRINT ( STRING_VALUE ) .)
    STRING_VALUE    reduce using rule 12 (statement -> PRINT ( STRING_VALUE ) .)
    (               reduce using rule 12 (statement -> PRINT ( STRING_VALUE ) .)
    UNARY           reduce using rule 12 (statement -> PRINT ( STRING_VALUE ) .)
    FOR             reduce using rule 12 (statement -> PRINT ( STRING_VALUE ) .)
    WHILE           reduce using rule 12 (statement -> PRINT ( STRING_VALUE ) .)


state 91

    (16) function_calls -> IDENTIFIER . ( )
    (17) function_calls -> IDENTIFIER . ( ) function_calls
    (18) function_calls -> IDENTIFIER . ( parameters )
    (19) function_calls -> IDENTIFIER . ( parameters ) function_calls

    (               shift and go to state 42


state 92

    (17) function_calls -> IDENTIFIER ( ) function_calls .

    }               reduce using rule 17 (function_calls -> IDENTIFIER ( ) function_calls .)
    RETURN          reduce using rule 17 (function_calls -> IDENTIFIER ( ) function_calls .)
    PRINT           reduce using rule 17 (function_calls -> IDENTIFIER ( ) function_calls .)
    IDENTIFIER      reduce using rule 17 (function_calls -> IDENTIFIER ( ) function_calls .)
    IF              reduce using rule 17 (function_calls -> IDENTIFIER ( ) function_calls .)
    FUNC            reduce using rule 17 (function_calls -> IDENTIFIER ( ) function_calls .)
    INT_VALUE       reduce using rule 17 (function_calls -> IDENTIFIER ( ) function_calls .)
    FLOAT_VALUE     reduce using rule 17 (function_calls -> IDENTIFIER ( ) function_calls .)
    STRING_VALUE    reduce using rule 17 (function_calls -> IDENTIFIER ( ) function_calls .)
    (               reduce using rule 17 (function_calls -> IDENTIFIER ( ) function_calls .)
    UNARY           reduce using rule 17 (function_calls -> IDENTIFIER ( ) function_calls .)
    FOR             reduce using rule 17 (function_calls -> IDENTIFIER ( ) function_calls .)
    WHILE           reduce using rule 17 (function_calls -> IDENTIFIER ( ) function_calls .)


state 93

    (18) function_calls -> IDENTIFIER ( parameters ) .
    (19) function_calls -> IDENTIFIER ( parameters ) . function_calls
    (16) function_calls -> . IDENTIFIER ( )
    (17) function_calls -> . IDENTIFIER ( ) function_calls
    (18) function_calls -> . IDENTIFIER ( parameters )
    (19) function_calls -> . IDENTIFIER ( parameters ) function_calls

  ! shift/reduce conflict for IDENTIFIER resolved as shift
    }               reduce using rule 18 (function_calls -> IDENTIFIER ( parameters ) .)
    RETURN          reduce using rule 18 (function_calls -> IDENTIFIER ( parameters ) .)
    PRINT           reduce using rule 18 (function_calls -> IDENTIFIER ( parameters ) .)
    IF              reduce using rule 18 (function_calls -> IDENTIFIER ( parameters ) .)
    FUNC            reduce using rule 18 (function_calls -> IDENTIFIER ( parameters ) .)
    INT_VALUE       reduce using rule 18 (function_calls -> IDENTIFIER ( parameters ) .)
    FLOAT_VALUE     reduce using rule 18 (function_calls -> IDENTIFIER ( parameters ) .)
    STRING_VALUE    reduce using rule 18 (function_calls -> IDENTIFIER ( parameters ) .)
    (               reduce using rule 18 (function_calls -> IDENTIFIER ( parameters ) .)
    UNARY           reduce using rule 18 (function_calls -> IDENTIFIER ( parameters ) .)
    FOR             reduce using rule 18 (function_calls -> IDENTIFIER ( parameters ) .)
    WHILE           reduce using rule 18 (function_calls -> IDENTIFIER ( parameters ) .)
    IDENTIFIER      shift and go to state 91

  ! IDENTIFIER      [ reduce using rule 18 (function_calls -> IDENTIFIER ( parameters ) .) ]

    function_calls                 shift and go to state 100

state 94

    (22) parameterList -> parameter , . parameterList
    (21) parameterList -> . parameter
    (22) parameterList -> . parameter , parameterList
    (23) parameter -> . datatype IDENTIFIER
    (24) datatype -> . INT
    (25) datatype -> . FLOAT
    (26) datatype -> . STRING
    (27) datatype -> . ADAPT
    (28) datatype -> . VOID

    INT             shift and go to state 69
    FLOAT           shift and go to state 70
    STRING          shift and go to state 71
    ADAPT           shift and go to state 72
    VOID            shift and go to state 73

    parameter                      shift and go to state 67
    parameterList                  shift and go to state 101
    datatype                       shift and go to state 68

state 95

    (23) parameter -> datatype IDENTIFIER .

    ,               reduce using rule 23 (parameter -> datatype IDENTIFIER .)
    )               reduce using rule 23 (parameter -> datatype IDENTIFIER .)


state 96

    (51) condition -> IF expression { statements . }
    (52) condition -> IF expression { statements . } ELSE { statements }
    (4) statements -> statements . statement
    (5) statement -> . function_calls
    (6) statement -> . condition
    (7) statement -> . function_declarations
    (8) statement -> . expression
    (9) statement -> . loops
    (10) statement -> . RETURN variable
    (11) statement -> . PRINT ( variable )
    (12) statement -> . PRINT ( STRING_VALUE )
    (16) function_calls -> . IDENTIFIER ( )
    (17) function_calls -> . IDENTIFIER ( ) function_calls
    (18) function_calls -> . IDENTIFIER ( parameters )
    (19) function_calls -> . IDENTIFIER ( parameters ) function_calls
    (51) condition -> . IF expression { statements }
    (52) condition -> . IF expression { statements } ELSE { statements }
    (13) function_declarations -> . function_declaration
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (53) loops -> . loop
    (54) loops -> . loop loops
    (14) function_declaration -> . FUNC IDENTIFIER ( ) : datatype { function_body }
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (55) loop -> . forLoop
    (56) loop -> . whileLoop
    (36) variable -> . IDENTIFIER
    (57) forLoop -> . FOR ( expression ; condition ; expression ) { statements }
    (58) whileLoop -> . WHILE ( condition ) { statements }

    }               shift and go to state 102
    RETURN          shift and go to state 17
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 21
    IF              shift and go to state 22
    FUNC            shift and go to state 8
    INT_VALUE       shift and go to state 28
    FLOAT_VALUE     shift and go to state 29
    STRING_VALUE    shift and go to state 20
    (               shift and go to state 9
    UNARY           shift and go to state 30
    FOR             shift and go to state 33
    WHILE           shift and go to state 34

    expression                     shift and go to state 15
    statement                      shift and go to state 39
    function_calls                 shift and go to state 12
    condition                      shift and go to state 13
    function_declarations          shift and go to state 14
    loops                          shift and go to state 16
    variable                       shift and go to state 18
    function_declaration           shift and go to state 23
    atoms                          shift and go to state 24
    paren_expr                     shift and go to state 25
    binary_expr                    shift and go to state 26
    loop                           shift and go to state 27
    forLoop                        shift and go to state 31
    whileLoop                      shift and go to state 32

state 97

    (57) forLoop -> FOR ( expression ; . condition ; expression ) { statements }
    (51) condition -> . IF expression { statements }
    (52) condition -> . IF expression { statements } ELSE { statements }

    IF              shift and go to state 22

    condition                      shift and go to state 103

state 98

    (58) whileLoop -> WHILE ( condition ) . { statements }

    {               shift and go to state 104


state 99

    (14) function_declaration -> FUNC IDENTIFIER ( ) : . datatype { function_body }
    (24) datatype -> . INT
    (25) datatype -> . FLOAT
    (26) datatype -> . STRING
    (27) datatype -> . ADAPT
    (28) datatype -> . VOID

    INT             shift and go to state 69
    FLOAT           shift and go to state 70
    STRING          shift and go to state 71
    ADAPT           shift and go to state 72
    VOID            shift and go to state 73

    datatype                       shift and go to state 105

state 100

    (19) function_calls -> IDENTIFIER ( parameters ) function_calls .

    }               reduce using rule 19 (function_calls -> IDENTIFIER ( parameters ) function_calls .)
    RETURN          reduce using rule 19 (function_calls -> IDENTIFIER ( parameters ) function_calls .)
    PRINT           reduce using rule 19 (function_calls -> IDENTIFIER ( parameters ) function_calls .)
    IDENTIFIER      reduce using rule 19 (function_calls -> IDENTIFIER ( parameters ) function_calls .)
    IF              reduce using rule 19 (function_calls -> IDENTIFIER ( parameters ) function_calls .)
    FUNC            reduce using rule 19 (function_calls -> IDENTIFIER ( parameters ) function_calls .)
    INT_VALUE       reduce using rule 19 (function_calls -> IDENTIFIER ( parameters ) function_calls .)
    FLOAT_VALUE     reduce using rule 19 (function_calls -> IDENTIFIER ( parameters ) function_calls .)
    STRING_VALUE    reduce using rule 19 (function_calls -> IDENTIFIER ( parameters ) function_calls .)
    (               reduce using rule 19 (function_calls -> IDENTIFIER ( parameters ) function_calls .)
    UNARY           reduce using rule 19 (function_calls -> IDENTIFIER ( parameters ) function_calls .)
    FOR             reduce using rule 19 (function_calls -> IDENTIFIER ( parameters ) function_calls .)
    WHILE           reduce using rule 19 (function_calls -> IDENTIFIER ( parameters ) function_calls .)


state 101

    (22) parameterList -> parameter , parameterList .

    )               reduce using rule 22 (parameterList -> parameter , parameterList .)


state 102

    (51) condition -> IF expression { statements } .
    (52) condition -> IF expression { statements } . ELSE { statements }

    }               reduce using rule 51 (condition -> IF expression { statements } .)
    RETURN          reduce using rule 51 (condition -> IF expression { statements } .)
    PRINT           reduce using rule 51 (condition -> IF expression { statements } .)
    IDENTIFIER      reduce using rule 51 (condition -> IF expression { statements } .)
    IF              reduce using rule 51 (condition -> IF expression { statements } .)
    FUNC            reduce using rule 51 (condition -> IF expression { statements } .)
    INT_VALUE       reduce using rule 51 (condition -> IF expression { statements } .)
    FLOAT_VALUE     reduce using rule 51 (condition -> IF expression { statements } .)
    STRING_VALUE    reduce using rule 51 (condition -> IF expression { statements } .)
    (               reduce using rule 51 (condition -> IF expression { statements } .)
    UNARY           reduce using rule 51 (condition -> IF expression { statements } .)
    FOR             reduce using rule 51 (condition -> IF expression { statements } .)
    WHILE           reduce using rule 51 (condition -> IF expression { statements } .)
    )               reduce using rule 51 (condition -> IF expression { statements } .)
    ;               reduce using rule 51 (condition -> IF expression { statements } .)
    ELSE            shift and go to state 106


state 103

    (57) forLoop -> FOR ( expression ; condition . ; expression ) { statements }

    ;               shift and go to state 107


state 104

    (58) whileLoop -> WHILE ( condition ) { . statements }
    (3) statements -> . statement
    (4) statements -> . statements statement
    (5) statement -> . function_calls
    (6) statement -> . condition
    (7) statement -> . function_declarations
    (8) statement -> . expression
    (9) statement -> . loops
    (10) statement -> . RETURN variable
    (11) statement -> . PRINT ( variable )
    (12) statement -> . PRINT ( STRING_VALUE )
    (16) function_calls -> . IDENTIFIER ( )
    (17) function_calls -> . IDENTIFIER ( ) function_calls
    (18) function_calls -> . IDENTIFIER ( parameters )
    (19) function_calls -> . IDENTIFIER ( parameters ) function_calls
    (51) condition -> . IF expression { statements }
    (52) condition -> . IF expression { statements } ELSE { statements }
    (13) function_declarations -> . function_declaration
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (53) loops -> . loop
    (54) loops -> . loop loops
    (14) function_declaration -> . FUNC IDENTIFIER ( ) : datatype { function_body }
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (55) loop -> . forLoop
    (56) loop -> . whileLoop
    (36) variable -> . IDENTIFIER
    (57) forLoop -> . FOR ( expression ; condition ; expression ) { statements }
    (58) whileLoop -> . WHILE ( condition ) { statements }

    RETURN          shift and go to state 17
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 21
    IF              shift and go to state 22
    FUNC            shift and go to state 8
    INT_VALUE       shift and go to state 28
    FLOAT_VALUE     shift and go to state 29
    STRING_VALUE    shift and go to state 20
    (               shift and go to state 9
    UNARY           shift and go to state 30
    FOR             shift and go to state 33
    WHILE           shift and go to state 34

    condition                      shift and go to state 13
    statements                     shift and go to state 108
    statement                      shift and go to state 11
    function_calls                 shift and go to state 12
    function_declarations          shift and go to state 14
    expression                     shift and go to state 15
    loops                          shift and go to state 16
    variable                       shift and go to state 18
    function_declaration           shift and go to state 23
    atoms                          shift and go to state 24
    paren_expr                     shift and go to state 25
    binary_expr                    shift and go to state 26
    loop                           shift and go to state 27
    forLoop                        shift and go to state 31
    whileLoop                      shift and go to state 32

state 105

    (14) function_declaration -> FUNC IDENTIFIER ( ) : datatype . { function_body }

    {               shift and go to state 109


state 106

    (52) condition -> IF expression { statements } ELSE . { statements }

    {               shift and go to state 110


state 107

    (57) forLoop -> FOR ( expression ; condition ; . expression ) { statements }
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (36) variable -> . IDENTIFIER

    INT_VALUE       shift and go to state 28
    FLOAT_VALUE     shift and go to state 29
    STRING_VALUE    shift and go to state 20
    (               shift and go to state 9
    UNARY           shift and go to state 30
    IDENTIFIER      shift and go to state 37

    expression                     shift and go to state 111
    atoms                          shift and go to state 24
    paren_expr                     shift and go to state 25
    binary_expr                    shift and go to state 26
    variable                       shift and go to state 18

state 108

    (58) whileLoop -> WHILE ( condition ) { statements . }
    (4) statements -> statements . statement
    (5) statement -> . function_calls
    (6) statement -> . condition
    (7) statement -> . function_declarations
    (8) statement -> . expression
    (9) statement -> . loops
    (10) statement -> . RETURN variable
    (11) statement -> . PRINT ( variable )
    (12) statement -> . PRINT ( STRING_VALUE )
    (16) function_calls -> . IDENTIFIER ( )
    (17) function_calls -> . IDENTIFIER ( ) function_calls
    (18) function_calls -> . IDENTIFIER ( parameters )
    (19) function_calls -> . IDENTIFIER ( parameters ) function_calls
    (51) condition -> . IF expression { statements }
    (52) condition -> . IF expression { statements } ELSE { statements }
    (13) function_declarations -> . function_declaration
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (53) loops -> . loop
    (54) loops -> . loop loops
    (14) function_declaration -> . FUNC IDENTIFIER ( ) : datatype { function_body }
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (55) loop -> . forLoop
    (56) loop -> . whileLoop
    (36) variable -> . IDENTIFIER
    (57) forLoop -> . FOR ( expression ; condition ; expression ) { statements }
    (58) whileLoop -> . WHILE ( condition ) { statements }

    }               shift and go to state 112
    RETURN          shift and go to state 17
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 21
    IF              shift and go to state 22
    FUNC            shift and go to state 8
    INT_VALUE       shift and go to state 28
    FLOAT_VALUE     shift and go to state 29
    STRING_VALUE    shift and go to state 20
    (               shift and go to state 9
    UNARY           shift and go to state 30
    FOR             shift and go to state 33
    WHILE           shift and go to state 34

    condition                      shift and go to state 13
    statement                      shift and go to state 39
    function_calls                 shift and go to state 12
    function_declarations          shift and go to state 14
    expression                     shift and go to state 15
    loops                          shift and go to state 16
    variable                       shift and go to state 18
    function_declaration           shift and go to state 23
    atoms                          shift and go to state 24
    paren_expr                     shift and go to state 25
    binary_expr                    shift and go to state 26
    loop                           shift and go to state 27
    forLoop                        shift and go to state 31
    whileLoop                      shift and go to state 32

state 109

    (14) function_declaration -> FUNC IDENTIFIER ( ) : datatype { . function_body }
    (15) function_body -> . statements
    (3) statements -> . statement
    (4) statements -> . statements statement
    (5) statement -> . function_calls
    (6) statement -> . condition
    (7) statement -> . function_declarations
    (8) statement -> . expression
    (9) statement -> . loops
    (10) statement -> . RETURN variable
    (11) statement -> . PRINT ( variable )
    (12) statement -> . PRINT ( STRING_VALUE )
    (16) function_calls -> . IDENTIFIER ( )
    (17) function_calls -> . IDENTIFIER ( ) function_calls
    (18) function_calls -> . IDENTIFIER ( parameters )
    (19) function_calls -> . IDENTIFIER ( parameters ) function_calls
    (51) condition -> . IF expression { statements }
    (52) condition -> . IF expression { statements } ELSE { statements }
    (13) function_declarations -> . function_declaration
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (53) loops -> . loop
    (54) loops -> . loop loops
    (14) function_declaration -> . FUNC IDENTIFIER ( ) : datatype { function_body }
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (55) loop -> . forLoop
    (56) loop -> . whileLoop
    (36) variable -> . IDENTIFIER
    (57) forLoop -> . FOR ( expression ; condition ; expression ) { statements }
    (58) whileLoop -> . WHILE ( condition ) { statements }

    RETURN          shift and go to state 17
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 21
    IF              shift and go to state 22
    FUNC            shift and go to state 8
    INT_VALUE       shift and go to state 28
    FLOAT_VALUE     shift and go to state 29
    STRING_VALUE    shift and go to state 20
    (               shift and go to state 9
    UNARY           shift and go to state 30
    FOR             shift and go to state 33
    WHILE           shift and go to state 34

    function_body                  shift and go to state 113
    statements                     shift and go to state 114
    statement                      shift and go to state 11
    function_calls                 shift and go to state 12
    condition                      shift and go to state 13
    function_declarations          shift and go to state 14
    expression                     shift and go to state 15
    loops                          shift and go to state 16
    variable                       shift and go to state 18
    function_declaration           shift and go to state 23
    atoms                          shift and go to state 24
    paren_expr                     shift and go to state 25
    binary_expr                    shift and go to state 26
    loop                           shift and go to state 27
    forLoop                        shift and go to state 31
    whileLoop                      shift and go to state 32

state 110

    (52) condition -> IF expression { statements } ELSE { . statements }
    (3) statements -> . statement
    (4) statements -> . statements statement
    (5) statement -> . function_calls
    (6) statement -> . condition
    (7) statement -> . function_declarations
    (8) statement -> . expression
    (9) statement -> . loops
    (10) statement -> . RETURN variable
    (11) statement -> . PRINT ( variable )
    (12) statement -> . PRINT ( STRING_VALUE )
    (16) function_calls -> . IDENTIFIER ( )
    (17) function_calls -> . IDENTIFIER ( ) function_calls
    (18) function_calls -> . IDENTIFIER ( parameters )
    (19) function_calls -> . IDENTIFIER ( parameters ) function_calls
    (51) condition -> . IF expression { statements }
    (52) condition -> . IF expression { statements } ELSE { statements }
    (13) function_declarations -> . function_declaration
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (53) loops -> . loop
    (54) loops -> . loop loops
    (14) function_declaration -> . FUNC IDENTIFIER ( ) : datatype { function_body }
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (55) loop -> . forLoop
    (56) loop -> . whileLoop
    (36) variable -> . IDENTIFIER
    (57) forLoop -> . FOR ( expression ; condition ; expression ) { statements }
    (58) whileLoop -> . WHILE ( condition ) { statements }

    RETURN          shift and go to state 17
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 21
    IF              shift and go to state 22
    FUNC            shift and go to state 8
    INT_VALUE       shift and go to state 28
    FLOAT_VALUE     shift and go to state 29
    STRING_VALUE    shift and go to state 20
    (               shift and go to state 9
    UNARY           shift and go to state 30
    FOR             shift and go to state 33
    WHILE           shift and go to state 34

    expression                     shift and go to state 15
    statements                     shift and go to state 115
    statement                      shift and go to state 11
    function_calls                 shift and go to state 12
    condition                      shift and go to state 13
    function_declarations          shift and go to state 14
    loops                          shift and go to state 16
    variable                       shift and go to state 18
    function_declaration           shift and go to state 23
    atoms                          shift and go to state 24
    paren_expr                     shift and go to state 25
    binary_expr                    shift and go to state 26
    loop                           shift and go to state 27
    forLoop                        shift and go to state 31
    whileLoop                      shift and go to state 32

state 111

    (57) forLoop -> FOR ( expression ; condition ; expression . ) { statements }

    )               shift and go to state 116


state 112

    (58) whileLoop -> WHILE ( condition ) { statements } .

    FOR             reduce using rule 58 (whileLoop -> WHILE ( condition ) { statements } .)
    WHILE           reduce using rule 58 (whileLoop -> WHILE ( condition ) { statements } .)
    }               reduce using rule 58 (whileLoop -> WHILE ( condition ) { statements } .)
    RETURN          reduce using rule 58 (whileLoop -> WHILE ( condition ) { statements } .)
    PRINT           reduce using rule 58 (whileLoop -> WHILE ( condition ) { statements } .)
    IDENTIFIER      reduce using rule 58 (whileLoop -> WHILE ( condition ) { statements } .)
    IF              reduce using rule 58 (whileLoop -> WHILE ( condition ) { statements } .)
    FUNC            reduce using rule 58 (whileLoop -> WHILE ( condition ) { statements } .)
    INT_VALUE       reduce using rule 58 (whileLoop -> WHILE ( condition ) { statements } .)
    FLOAT_VALUE     reduce using rule 58 (whileLoop -> WHILE ( condition ) { statements } .)
    STRING_VALUE    reduce using rule 58 (whileLoop -> WHILE ( condition ) { statements } .)
    (               reduce using rule 58 (whileLoop -> WHILE ( condition ) { statements } .)
    UNARY           reduce using rule 58 (whileLoop -> WHILE ( condition ) { statements } .)


state 113

    (14) function_declaration -> FUNC IDENTIFIER ( ) : datatype { function_body . }

    }               shift and go to state 117


state 114

    (15) function_body -> statements .
    (4) statements -> statements . statement
    (5) statement -> . function_calls
    (6) statement -> . condition
    (7) statement -> . function_declarations
    (8) statement -> . expression
    (9) statement -> . loops
    (10) statement -> . RETURN variable
    (11) statement -> . PRINT ( variable )
    (12) statement -> . PRINT ( STRING_VALUE )
    (16) function_calls -> . IDENTIFIER ( )
    (17) function_calls -> . IDENTIFIER ( ) function_calls
    (18) function_calls -> . IDENTIFIER ( parameters )
    (19) function_calls -> . IDENTIFIER ( parameters ) function_calls
    (51) condition -> . IF expression { statements }
    (52) condition -> . IF expression { statements } ELSE { statements }
    (13) function_declarations -> . function_declaration
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (53) loops -> . loop
    (54) loops -> . loop loops
    (14) function_declaration -> . FUNC IDENTIFIER ( ) : datatype { function_body }
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (55) loop -> . forLoop
    (56) loop -> . whileLoop
    (36) variable -> . IDENTIFIER
    (57) forLoop -> . FOR ( expression ; condition ; expression ) { statements }
    (58) whileLoop -> . WHILE ( condition ) { statements }

    }               reduce using rule 15 (function_body -> statements .)
    RETURN          shift and go to state 17
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 21
    IF              shift and go to state 22
    FUNC            shift and go to state 8
    INT_VALUE       shift and go to state 28
    FLOAT_VALUE     shift and go to state 29
    STRING_VALUE    shift and go to state 20
    (               shift and go to state 9
    UNARY           shift and go to state 30
    FOR             shift and go to state 33
    WHILE           shift and go to state 34

    statement                      shift and go to state 39
    function_calls                 shift and go to state 12
    condition                      shift and go to state 13
    function_declarations          shift and go to state 14
    expression                     shift and go to state 15
    loops                          shift and go to state 16
    variable                       shift and go to state 18
    function_declaration           shift and go to state 23
    atoms                          shift and go to state 24
    paren_expr                     shift and go to state 25
    binary_expr                    shift and go to state 26
    loop                           shift and go to state 27
    forLoop                        shift and go to state 31
    whileLoop                      shift and go to state 32

state 115

    (52) condition -> IF expression { statements } ELSE { statements . }
    (4) statements -> statements . statement
    (5) statement -> . function_calls
    (6) statement -> . condition
    (7) statement -> . function_declarations
    (8) statement -> . expression
    (9) statement -> . loops
    (10) statement -> . RETURN variable
    (11) statement -> . PRINT ( variable )
    (12) statement -> . PRINT ( STRING_VALUE )
    (16) function_calls -> . IDENTIFIER ( )
    (17) function_calls -> . IDENTIFIER ( ) function_calls
    (18) function_calls -> . IDENTIFIER ( parameters )
    (19) function_calls -> . IDENTIFIER ( parameters ) function_calls
    (51) condition -> . IF expression { statements }
    (52) condition -> . IF expression { statements } ELSE { statements }
    (13) function_declarations -> . function_declaration
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (53) loops -> . loop
    (54) loops -> . loop loops
    (14) function_declaration -> . FUNC IDENTIFIER ( ) : datatype { function_body }
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (55) loop -> . forLoop
    (56) loop -> . whileLoop
    (36) variable -> . IDENTIFIER
    (57) forLoop -> . FOR ( expression ; condition ; expression ) { statements }
    (58) whileLoop -> . WHILE ( condition ) { statements }

    }               shift and go to state 118
    RETURN          shift and go to state 17
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 21
    IF              shift and go to state 22
    FUNC            shift and go to state 8
    INT_VALUE       shift and go to state 28
    FLOAT_VALUE     shift and go to state 29
    STRING_VALUE    shift and go to state 20
    (               shift and go to state 9
    UNARY           shift and go to state 30
    FOR             shift and go to state 33
    WHILE           shift and go to state 34

    expression                     shift and go to state 15
    statement                      shift and go to state 39
    function_calls                 shift and go to state 12
    condition                      shift and go to state 13
    function_declarations          shift and go to state 14
    loops                          shift and go to state 16
    variable                       shift and go to state 18
    function_declaration           shift and go to state 23
    atoms                          shift and go to state 24
    paren_expr                     shift and go to state 25
    binary_expr                    shift and go to state 26
    loop                           shift and go to state 27
    forLoop                        shift and go to state 31
    whileLoop                      shift and go to state 32

state 116

    (57) forLoop -> FOR ( expression ; condition ; expression ) . { statements }

    {               shift and go to state 119


state 117

    (14) function_declaration -> FUNC IDENTIFIER ( ) : datatype { function_body } .

    }               reduce using rule 14 (function_declaration -> FUNC IDENTIFIER ( ) : datatype { function_body } .)
    RETURN          reduce using rule 14 (function_declaration -> FUNC IDENTIFIER ( ) : datatype { function_body } .)
    PRINT           reduce using rule 14 (function_declaration -> FUNC IDENTIFIER ( ) : datatype { function_body } .)
    IDENTIFIER      reduce using rule 14 (function_declaration -> FUNC IDENTIFIER ( ) : datatype { function_body } .)
    IF              reduce using rule 14 (function_declaration -> FUNC IDENTIFIER ( ) : datatype { function_body } .)
    FUNC            reduce using rule 14 (function_declaration -> FUNC IDENTIFIER ( ) : datatype { function_body } .)
    INT_VALUE       reduce using rule 14 (function_declaration -> FUNC IDENTIFIER ( ) : datatype { function_body } .)
    FLOAT_VALUE     reduce using rule 14 (function_declaration -> FUNC IDENTIFIER ( ) : datatype { function_body } .)
    STRING_VALUE    reduce using rule 14 (function_declaration -> FUNC IDENTIFIER ( ) : datatype { function_body } .)
    (               reduce using rule 14 (function_declaration -> FUNC IDENTIFIER ( ) : datatype { function_body } .)
    UNARY           reduce using rule 14 (function_declaration -> FUNC IDENTIFIER ( ) : datatype { function_body } .)
    FOR             reduce using rule 14 (function_declaration -> FUNC IDENTIFIER ( ) : datatype { function_body } .)
    WHILE           reduce using rule 14 (function_declaration -> FUNC IDENTIFIER ( ) : datatype { function_body } .)


state 118

    (52) condition -> IF expression { statements } ELSE { statements } .

    }               reduce using rule 52 (condition -> IF expression { statements } ELSE { statements } .)
    RETURN          reduce using rule 52 (condition -> IF expression { statements } ELSE { statements } .)
    PRINT           reduce using rule 52 (condition -> IF expression { statements } ELSE { statements } .)
    IDENTIFIER      reduce using rule 52 (condition -> IF expression { statements } ELSE { statements } .)
    IF              reduce using rule 52 (condition -> IF expression { statements } ELSE { statements } .)
    FUNC            reduce using rule 52 (condition -> IF expression { statements } ELSE { statements } .)
    INT_VALUE       reduce using rule 52 (condition -> IF expression { statements } ELSE { statements } .)
    FLOAT_VALUE     reduce using rule 52 (condition -> IF expression { statements } ELSE { statements } .)
    STRING_VALUE    reduce using rule 52 (condition -> IF expression { statements } ELSE { statements } .)
    (               reduce using rule 52 (condition -> IF expression { statements } ELSE { statements } .)
    UNARY           reduce using rule 52 (condition -> IF expression { statements } ELSE { statements } .)
    FOR             reduce using rule 52 (condition -> IF expression { statements } ELSE { statements } .)
    WHILE           reduce using rule 52 (condition -> IF expression { statements } ELSE { statements } .)
    )               reduce using rule 52 (condition -> IF expression { statements } ELSE { statements } .)
    ;               reduce using rule 52 (condition -> IF expression { statements } ELSE { statements } .)


state 119

    (57) forLoop -> FOR ( expression ; condition ; expression ) { . statements }
    (3) statements -> . statement
    (4) statements -> . statements statement
    (5) statement -> . function_calls
    (6) statement -> . condition
    (7) statement -> . function_declarations
    (8) statement -> . expression
    (9) statement -> . loops
    (10) statement -> . RETURN variable
    (11) statement -> . PRINT ( variable )
    (12) statement -> . PRINT ( STRING_VALUE )
    (16) function_calls -> . IDENTIFIER ( )
    (17) function_calls -> . IDENTIFIER ( ) function_calls
    (18) function_calls -> . IDENTIFIER ( parameters )
    (19) function_calls -> . IDENTIFIER ( parameters ) function_calls
    (51) condition -> . IF expression { statements }
    (52) condition -> . IF expression { statements } ELSE { statements }
    (13) function_declarations -> . function_declaration
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (53) loops -> . loop
    (54) loops -> . loop loops
    (14) function_declaration -> . FUNC IDENTIFIER ( ) : datatype { function_body }
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (55) loop -> . forLoop
    (56) loop -> . whileLoop
    (36) variable -> . IDENTIFIER
    (57) forLoop -> . FOR ( expression ; condition ; expression ) { statements }
    (58) whileLoop -> . WHILE ( condition ) { statements }

    RETURN          shift and go to state 17
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 21
    IF              shift and go to state 22
    FUNC            shift and go to state 8
    INT_VALUE       shift and go to state 28
    FLOAT_VALUE     shift and go to state 29
    STRING_VALUE    shift and go to state 20
    (               shift and go to state 9
    UNARY           shift and go to state 30
    FOR             shift and go to state 33
    WHILE           shift and go to state 34

    expression                     shift and go to state 15
    condition                      shift and go to state 13
    statements                     shift and go to state 120
    statement                      shift and go to state 11
    function_calls                 shift and go to state 12
    function_declarations          shift and go to state 14
    loops                          shift and go to state 16
    variable                       shift and go to state 18
    function_declaration           shift and go to state 23
    atoms                          shift and go to state 24
    paren_expr                     shift and go to state 25
    binary_expr                    shift and go to state 26
    loop                           shift and go to state 27
    forLoop                        shift and go to state 31
    whileLoop                      shift and go to state 32

state 120

    (57) forLoop -> FOR ( expression ; condition ; expression ) { statements . }
    (4) statements -> statements . statement
    (5) statement -> . function_calls
    (6) statement -> . condition
    (7) statement -> . function_declarations
    (8) statement -> . expression
    (9) statement -> . loops
    (10) statement -> . RETURN variable
    (11) statement -> . PRINT ( variable )
    (12) statement -> . PRINT ( STRING_VALUE )
    (16) function_calls -> . IDENTIFIER ( )
    (17) function_calls -> . IDENTIFIER ( ) function_calls
    (18) function_calls -> . IDENTIFIER ( parameters )
    (19) function_calls -> . IDENTIFIER ( parameters ) function_calls
    (51) condition -> . IF expression { statements }
    (52) condition -> . IF expression { statements } ELSE { statements }
    (13) function_declarations -> . function_declaration
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (53) loops -> . loop
    (54) loops -> . loop loops
    (14) function_declaration -> . FUNC IDENTIFIER ( ) : datatype { function_body }
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (55) loop -> . forLoop
    (56) loop -> . whileLoop
    (36) variable -> . IDENTIFIER
    (57) forLoop -> . FOR ( expression ; condition ; expression ) { statements }
    (58) whileLoop -> . WHILE ( condition ) { statements }

    }               shift and go to state 121
    RETURN          shift and go to state 17
    PRINT           shift and go to state 19
    IDENTIFIER      shift and go to state 21
    IF              shift and go to state 22
    FUNC            shift and go to state 8
    INT_VALUE       shift and go to state 28
    FLOAT_VALUE     shift and go to state 29
    STRING_VALUE    shift and go to state 20
    (               shift and go to state 9
    UNARY           shift and go to state 30
    FOR             shift and go to state 33
    WHILE           shift and go to state 34

    expression                     shift and go to state 15
    condition                      shift and go to state 13
    statement                      shift and go to state 39
    function_calls                 shift and go to state 12
    function_declarations          shift and go to state 14
    loops                          shift and go to state 16
    variable                       shift and go to state 18
    function_declaration           shift and go to state 23
    atoms                          shift and go to state 24
    paren_expr                     shift and go to state 25
    binary_expr                    shift and go to state 26
    loop                           shift and go to state 27
    forLoop                        shift and go to state 31
    whileLoop                      shift and go to state 32

state 121

    (57) forLoop -> FOR ( expression ; condition ; expression ) { statements } .

    FOR             reduce using rule 57 (forLoop -> FOR ( expression ; condition ; expression ) { statements } .)
    WHILE           reduce using rule 57 (forLoop -> FOR ( expression ; condition ; expression ) { statements } .)
    }               reduce using rule 57 (forLoop -> FOR ( expression ; condition ; expression ) { statements } .)
    RETURN          reduce using rule 57 (forLoop -> FOR ( expression ; condition ; expression ) { statements } .)
    PRINT           reduce using rule 57 (forLoop -> FOR ( expression ; condition ; expression ) { statements } .)
    IDENTIFIER      reduce using rule 57 (forLoop -> FOR ( expression ; condition ; expression ) { statements } .)
    IF              reduce using rule 57 (forLoop -> FOR ( expression ; condition ; expression ) { statements } .)
    FUNC            reduce using rule 57 (forLoop -> FOR ( expression ; condition ; expression ) { statements } .)
    INT_VALUE       reduce using rule 57 (forLoop -> FOR ( expression ; condition ; expression ) { statements } .)
    FLOAT_VALUE     reduce using rule 57 (forLoop -> FOR ( expression ; condition ; expression ) { statements } .)
    STRING_VALUE    reduce using rule 57 (forLoop -> FOR ( expression ; condition ; expression ) { statements } .)
    (               reduce using rule 57 (forLoop -> FOR ( expression ; condition ; expression ) { statements } .)
    UNARY           reduce using rule 57 (forLoop -> FOR ( expression ; condition ; expression ) { statements } .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ( in state 21 resolved as shift
WARNING: shift/reduce conflict for UNARY in state 24 resolved as shift
WARNING: shift/reduce conflict for FOR in state 27 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 27 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 64 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 93 resolved as shift
