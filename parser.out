Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AND
    COMMENTS
    WHITESPACE

Grammar

Rule 0     S' -> program
Rule 1     program -> programStart
Rule 2     programStart -> FUNC INIT ( ) { statements }
Rule 3     statements -> statement
Rule 4     statements -> statements statement
Rule 5     statement -> function_calls
Rule 6     statement -> condition
Rule 7     statement -> function_declarations
Rule 8     statement -> expression
Rule 9     statement -> loops
Rule 10    statement -> RETURN expression
Rule 11    statement -> PRINT ( expression )
Rule 12    statement -> assignment
Rule 13    function_declarations -> function_declaration
Rule 14    function_declaration -> FUNC IDENTIFIER ( ) : datatype { function_body }
Rule 15    function_body -> statements
Rule 16    function_calls -> IDENTIFIER ( )
Rule 17    function_calls -> IDENTIFIER ( ) function_calls
Rule 18    function_calls -> IDENTIFIER ( parameters )
Rule 19    function_calls -> IDENTIFIER ( parameters ) function_calls
Rule 20    parameters -> parameterList
Rule 21    parameterList -> parameter
Rule 22    parameterList -> parameter , parameterList
Rule 23    parameter -> datatype IDENTIFIER
Rule 24    datatype -> INT
Rule 25    datatype -> FLOAT
Rule 26    datatype -> STRING
Rule 27    datatype -> ADAPT
Rule 28    datatype -> VOID
Rule 29    expression -> atoms
Rule 30    expression -> paren_expr
Rule 31    expression -> binary_expr
Rule 32    atoms -> INT_VALUE
Rule 33    atoms -> FLOAT_VALUE
Rule 34    atoms -> STRING_VALUE
Rule 35    atoms -> variable
Rule 36    variable -> IDENTIFIER
Rule 37    paren_expr -> ( expression )
Rule 38    binary_expr -> atoms ADD expression
Rule 39    binary_expr -> atoms SUB expression
Rule 40    binary_expr -> atoms MUL expression
Rule 41    binary_expr -> atoms DIV expression
Rule 42    binary_expr -> atoms OR expression
Rule 43    binary_expr -> atoms LE expression
Rule 44    binary_expr -> atoms GE expression
Rule 45    binary_expr -> atoms EQ expression
Rule 46    binary_expr -> atoms NE expression
Rule 47    binary_expr -> atoms GT expression
Rule 48    binary_expr -> atoms LT expression
Rule 49    binary_expr -> UNARY atoms
Rule 50    binary_expr -> atoms UNARY
Rule 51    assignment -> datatype IDENTIFIER EQUAL expression
Rule 52    assignment -> datatype IDENTIFIER EQUAL ACCEPT ( )
Rule 53    condition -> IF expression { statements }
Rule 54    condition -> IF expression { statements } ELSE { statements }
Rule 55    loops -> loop
Rule 56    loops -> loop loops
Rule 57    loop -> forLoop
Rule 58    loop -> whileLoop
Rule 59    forLoop -> FOR ( expression ; condition ; expression ) { statements }
Rule 60    whileLoop -> WHILE ( condition ) { statements }

Terminals, with rules where they appear

(                    : 2 11 14 16 17 18 19 37 52 59 60
)                    : 2 11 14 16 17 18 19 37 52 59 60
,                    : 22
:                    : 14
;                    : 59 59
ACCEPT               : 52
ADAPT                : 27
ADD                  : 38
AND                  : 
COMMENTS             : 
DIV                  : 41
ELSE                 : 54
EQ                   : 45
EQUAL                : 51 52
FLOAT                : 25
FLOAT_VALUE          : 33
FOR                  : 59
FUNC                 : 2 14
GE                   : 44
GT                   : 47
IDENTIFIER           : 14 16 17 18 19 23 36 51 52
IF                   : 53 54
INIT                 : 2
INT                  : 24
INT_VALUE            : 32
LE                   : 43
LT                   : 48
MUL                  : 40
NE                   : 46
OR                   : 42
PRINT                : 11
RETURN               : 10
STRING               : 26
STRING_VALUE         : 34
SUB                  : 39
UNARY                : 49 50
VOID                 : 28
WHILE                : 60
WHITESPACE           : 
error                : 
{                    : 2 14 53 54 54 59 60
}                    : 2 14 53 54 54 59 60

Nonterminals, with rules where they appear

assignment           : 12
atoms                : 29 38 39 40 41 42 43 44 45 46 47 48 49 50
binary_expr          : 31
condition            : 6 59 60
datatype             : 14 23 51 52
expression           : 8 10 11 37 38 39 40 41 42 43 44 45 46 47 48 51 53 54 59 59
forLoop              : 57
function_body        : 14
function_calls       : 5 17 19
function_declaration : 13
function_declarations : 7
loop                 : 55 56
loops                : 9 56
parameter            : 21 22
parameterList        : 20 22
parameters           : 18 19
paren_expr           : 30
program              : 0
programStart         : 1
statement            : 3 4
statements           : 2 4 15 53 54 54 59 60
variable             : 35
whileLoop            : 58

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . programStart
    (2) programStart -> . FUNC INIT ( ) { statements }

    FUNC            shift and go to state 3

    program                        shift and go to state 1
    programStart                   shift and go to state 2

state 1

    (0) S' -> program .



state 2

    (1) program -> programStart .

    $end            reduce using rule 1 (program -> programStart .)


state 3

    (2) programStart -> FUNC . INIT ( ) { statements }

    INIT            shift and go to state 4


state 4

    (2) programStart -> FUNC INIT . ( ) { statements }

    (               shift and go to state 5


state 5

    (2) programStart -> FUNC INIT ( . ) { statements }

    )               shift and go to state 6


state 6

    (2) programStart -> FUNC INIT ( ) . { statements }

    {               shift and go to state 7


state 7

    (2) programStart -> FUNC INIT ( ) { . statements }
    (3) statements -> . statement
    (4) statements -> . statements statement
    (5) statement -> . function_calls
    (6) statement -> . condition
    (7) statement -> . function_declarations
    (8) statement -> . expression
    (9) statement -> . loops
    (10) statement -> . RETURN expression
    (11) statement -> . PRINT ( expression )
    (12) statement -> . assignment
    (16) function_calls -> . IDENTIFIER ( )
    (17) function_calls -> . IDENTIFIER ( ) function_calls
    (18) function_calls -> . IDENTIFIER ( parameters )
    (19) function_calls -> . IDENTIFIER ( parameters ) function_calls
    (53) condition -> . IF expression { statements }
    (54) condition -> . IF expression { statements } ELSE { statements }
    (13) function_declarations -> . function_declaration
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (55) loops -> . loop
    (56) loops -> . loop loops
    (51) assignment -> . datatype IDENTIFIER EQUAL expression
    (52) assignment -> . datatype IDENTIFIER EQUAL ACCEPT ( )
    (14) function_declaration -> . FUNC IDENTIFIER ( ) : datatype { function_body }
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (57) loop -> . forLoop
    (58) loop -> . whileLoop
    (24) datatype -> . INT
    (25) datatype -> . FLOAT
    (26) datatype -> . STRING
    (27) datatype -> . ADAPT
    (28) datatype -> . VOID
    (36) variable -> . IDENTIFIER
    (59) forLoop -> . FOR ( expression ; condition ; expression ) { statements }
    (60) whileLoop -> . WHILE ( condition ) { statements }

    RETURN          shift and go to state 17
    PRINT           shift and go to state 18
    IDENTIFIER      shift and go to state 20
    IF              shift and go to state 21
    FUNC            shift and go to state 8
    INT_VALUE       shift and go to state 28
    FLOAT_VALUE     shift and go to state 29
    STRING_VALUE    shift and go to state 30
    (               shift and go to state 9
    UNARY           shift and go to state 32
    INT             shift and go to state 35
    FLOAT           shift and go to state 36
    STRING          shift and go to state 37
    ADAPT           shift and go to state 38
    VOID            shift and go to state 39
    FOR             shift and go to state 40
    WHILE           shift and go to state 41

    statements                     shift and go to state 10
    statement                      shift and go to state 11
    function_calls                 shift and go to state 12
    condition                      shift and go to state 13
    function_declarations          shift and go to state 14
    expression                     shift and go to state 15
    loops                          shift and go to state 16
    assignment                     shift and go to state 19
    function_declaration           shift and go to state 22
    atoms                          shift and go to state 23
    paren_expr                     shift and go to state 24
    binary_expr                    shift and go to state 25
    loop                           shift and go to state 26
    datatype                       shift and go to state 27
    variable                       shift and go to state 31
    forLoop                        shift and go to state 33
    whileLoop                      shift and go to state 34

state 8

    (14) function_declaration -> FUNC . IDENTIFIER ( ) : datatype { function_body }

    IDENTIFIER      shift and go to state 42


state 9

    (37) paren_expr -> ( . expression )
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (36) variable -> . IDENTIFIER

    INT_VALUE       shift and go to state 28
    FLOAT_VALUE     shift and go to state 29
    STRING_VALUE    shift and go to state 30
    (               shift and go to state 9
    UNARY           shift and go to state 32
    IDENTIFIER      shift and go to state 44

    expression                     shift and go to state 43
    atoms                          shift and go to state 23
    paren_expr                     shift and go to state 24
    binary_expr                    shift and go to state 25
    variable                       shift and go to state 31

state 10

    (2) programStart -> FUNC INIT ( ) { statements . }
    (4) statements -> statements . statement
    (5) statement -> . function_calls
    (6) statement -> . condition
    (7) statement -> . function_declarations
    (8) statement -> . expression
    (9) statement -> . loops
    (10) statement -> . RETURN expression
    (11) statement -> . PRINT ( expression )
    (12) statement -> . assignment
    (16) function_calls -> . IDENTIFIER ( )
    (17) function_calls -> . IDENTIFIER ( ) function_calls
    (18) function_calls -> . IDENTIFIER ( parameters )
    (19) function_calls -> . IDENTIFIER ( parameters ) function_calls
    (53) condition -> . IF expression { statements }
    (54) condition -> . IF expression { statements } ELSE { statements }
    (13) function_declarations -> . function_declaration
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (55) loops -> . loop
    (56) loops -> . loop loops
    (51) assignment -> . datatype IDENTIFIER EQUAL expression
    (52) assignment -> . datatype IDENTIFIER EQUAL ACCEPT ( )
    (14) function_declaration -> . FUNC IDENTIFIER ( ) : datatype { function_body }
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (57) loop -> . forLoop
    (58) loop -> . whileLoop
    (24) datatype -> . INT
    (25) datatype -> . FLOAT
    (26) datatype -> . STRING
    (27) datatype -> . ADAPT
    (28) datatype -> . VOID
    (36) variable -> . IDENTIFIER
    (59) forLoop -> . FOR ( expression ; condition ; expression ) { statements }
    (60) whileLoop -> . WHILE ( condition ) { statements }

    }               shift and go to state 45
    RETURN          shift and go to state 17
    PRINT           shift and go to state 18
    IDENTIFIER      shift and go to state 20
    IF              shift and go to state 21
    FUNC            shift and go to state 8
    INT_VALUE       shift and go to state 28
    FLOAT_VALUE     shift and go to state 29
    STRING_VALUE    shift and go to state 30
    (               shift and go to state 9
    UNARY           shift and go to state 32
    INT             shift and go to state 35
    FLOAT           shift and go to state 36
    STRING          shift and go to state 37
    ADAPT           shift and go to state 38
    VOID            shift and go to state 39
    FOR             shift and go to state 40
    WHILE           shift and go to state 41

    statement                      shift and go to state 46
    function_calls                 shift and go to state 12
    condition                      shift and go to state 13
    function_declarations          shift and go to state 14
    expression                     shift and go to state 15
    loops                          shift and go to state 16
    assignment                     shift and go to state 19
    function_declaration           shift and go to state 22
    atoms                          shift and go to state 23
    paren_expr                     shift and go to state 24
    binary_expr                    shift and go to state 25
    loop                           shift and go to state 26
    datatype                       shift and go to state 27
    variable                       shift and go to state 31
    forLoop                        shift and go to state 33
    whileLoop                      shift and go to state 34

state 11

    (3) statements -> statement .

    }               reduce using rule 3 (statements -> statement .)
    RETURN          reduce using rule 3 (statements -> statement .)
    PRINT           reduce using rule 3 (statements -> statement .)
    IDENTIFIER      reduce using rule 3 (statements -> statement .)
    IF              reduce using rule 3 (statements -> statement .)
    FUNC            reduce using rule 3 (statements -> statement .)
    INT_VALUE       reduce using rule 3 (statements -> statement .)
    FLOAT_VALUE     reduce using rule 3 (statements -> statement .)
    STRING_VALUE    reduce using rule 3 (statements -> statement .)
    (               reduce using rule 3 (statements -> statement .)
    UNARY           reduce using rule 3 (statements -> statement .)
    INT             reduce using rule 3 (statements -> statement .)
    FLOAT           reduce using rule 3 (statements -> statement .)
    STRING          reduce using rule 3 (statements -> statement .)
    ADAPT           reduce using rule 3 (statements -> statement .)
    VOID            reduce using rule 3 (statements -> statement .)
    FOR             reduce using rule 3 (statements -> statement .)
    WHILE           reduce using rule 3 (statements -> statement .)


state 12

    (5) statement -> function_calls .

    }               reduce using rule 5 (statement -> function_calls .)
    RETURN          reduce using rule 5 (statement -> function_calls .)
    PRINT           reduce using rule 5 (statement -> function_calls .)
    IDENTIFIER      reduce using rule 5 (statement -> function_calls .)
    IF              reduce using rule 5 (statement -> function_calls .)
    FUNC            reduce using rule 5 (statement -> function_calls .)
    INT_VALUE       reduce using rule 5 (statement -> function_calls .)
    FLOAT_VALUE     reduce using rule 5 (statement -> function_calls .)
    STRING_VALUE    reduce using rule 5 (statement -> function_calls .)
    (               reduce using rule 5 (statement -> function_calls .)
    UNARY           reduce using rule 5 (statement -> function_calls .)
    INT             reduce using rule 5 (statement -> function_calls .)
    FLOAT           reduce using rule 5 (statement -> function_calls .)
    STRING          reduce using rule 5 (statement -> function_calls .)
    ADAPT           reduce using rule 5 (statement -> function_calls .)
    VOID            reduce using rule 5 (statement -> function_calls .)
    FOR             reduce using rule 5 (statement -> function_calls .)
    WHILE           reduce using rule 5 (statement -> function_calls .)


state 13

    (6) statement -> condition .

    }               reduce using rule 6 (statement -> condition .)
    RETURN          reduce using rule 6 (statement -> condition .)
    PRINT           reduce using rule 6 (statement -> condition .)
    IDENTIFIER      reduce using rule 6 (statement -> condition .)
    IF              reduce using rule 6 (statement -> condition .)
    FUNC            reduce using rule 6 (statement -> condition .)
    INT_VALUE       reduce using rule 6 (statement -> condition .)
    FLOAT_VALUE     reduce using rule 6 (statement -> condition .)
    STRING_VALUE    reduce using rule 6 (statement -> condition .)
    (               reduce using rule 6 (statement -> condition .)
    UNARY           reduce using rule 6 (statement -> condition .)
    INT             reduce using rule 6 (statement -> condition .)
    FLOAT           reduce using rule 6 (statement -> condition .)
    STRING          reduce using rule 6 (statement -> condition .)
    ADAPT           reduce using rule 6 (statement -> condition .)
    VOID            reduce using rule 6 (statement -> condition .)
    FOR             reduce using rule 6 (statement -> condition .)
    WHILE           reduce using rule 6 (statement -> condition .)


state 14

    (7) statement -> function_declarations .

    }               reduce using rule 7 (statement -> function_declarations .)
    RETURN          reduce using rule 7 (statement -> function_declarations .)
    PRINT           reduce using rule 7 (statement -> function_declarations .)
    IDENTIFIER      reduce using rule 7 (statement -> function_declarations .)
    IF              reduce using rule 7 (statement -> function_declarations .)
    FUNC            reduce using rule 7 (statement -> function_declarations .)
    INT_VALUE       reduce using rule 7 (statement -> function_declarations .)
    FLOAT_VALUE     reduce using rule 7 (statement -> function_declarations .)
    STRING_VALUE    reduce using rule 7 (statement -> function_declarations .)
    (               reduce using rule 7 (statement -> function_declarations .)
    UNARY           reduce using rule 7 (statement -> function_declarations .)
    INT             reduce using rule 7 (statement -> function_declarations .)
    FLOAT           reduce using rule 7 (statement -> function_declarations .)
    STRING          reduce using rule 7 (statement -> function_declarations .)
    ADAPT           reduce using rule 7 (statement -> function_declarations .)
    VOID            reduce using rule 7 (statement -> function_declarations .)
    FOR             reduce using rule 7 (statement -> function_declarations .)
    WHILE           reduce using rule 7 (statement -> function_declarations .)


state 15

    (8) statement -> expression .

    }               reduce using rule 8 (statement -> expression .)
    RETURN          reduce using rule 8 (statement -> expression .)
    PRINT           reduce using rule 8 (statement -> expression .)
    IDENTIFIER      reduce using rule 8 (statement -> expression .)
    IF              reduce using rule 8 (statement -> expression .)
    FUNC            reduce using rule 8 (statement -> expression .)
    INT_VALUE       reduce using rule 8 (statement -> expression .)
    FLOAT_VALUE     reduce using rule 8 (statement -> expression .)
    STRING_VALUE    reduce using rule 8 (statement -> expression .)
    (               reduce using rule 8 (statement -> expression .)
    UNARY           reduce using rule 8 (statement -> expression .)
    INT             reduce using rule 8 (statement -> expression .)
    FLOAT           reduce using rule 8 (statement -> expression .)
    STRING          reduce using rule 8 (statement -> expression .)
    ADAPT           reduce using rule 8 (statement -> expression .)
    VOID            reduce using rule 8 (statement -> expression .)
    FOR             reduce using rule 8 (statement -> expression .)
    WHILE           reduce using rule 8 (statement -> expression .)


state 16

    (9) statement -> loops .

    }               reduce using rule 9 (statement -> loops .)
    RETURN          reduce using rule 9 (statement -> loops .)
    PRINT           reduce using rule 9 (statement -> loops .)
    IDENTIFIER      reduce using rule 9 (statement -> loops .)
    IF              reduce using rule 9 (statement -> loops .)
    FUNC            reduce using rule 9 (statement -> loops .)
    INT_VALUE       reduce using rule 9 (statement -> loops .)
    FLOAT_VALUE     reduce using rule 9 (statement -> loops .)
    STRING_VALUE    reduce using rule 9 (statement -> loops .)
    (               reduce using rule 9 (statement -> loops .)
    UNARY           reduce using rule 9 (statement -> loops .)
    INT             reduce using rule 9 (statement -> loops .)
    FLOAT           reduce using rule 9 (statement -> loops .)
    STRING          reduce using rule 9 (statement -> loops .)
    ADAPT           reduce using rule 9 (statement -> loops .)
    VOID            reduce using rule 9 (statement -> loops .)
    FOR             reduce using rule 9 (statement -> loops .)
    WHILE           reduce using rule 9 (statement -> loops .)


state 17

    (10) statement -> RETURN . expression
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (36) variable -> . IDENTIFIER

    INT_VALUE       shift and go to state 28
    FLOAT_VALUE     shift and go to state 29
    STRING_VALUE    shift and go to state 30
    (               shift and go to state 9
    UNARY           shift and go to state 32
    IDENTIFIER      shift and go to state 44

    expression                     shift and go to state 47
    atoms                          shift and go to state 23
    paren_expr                     shift and go to state 24
    binary_expr                    shift and go to state 25
    variable                       shift and go to state 31

state 18

    (11) statement -> PRINT . ( expression )

    (               shift and go to state 48


state 19

    (12) statement -> assignment .

    }               reduce using rule 12 (statement -> assignment .)
    RETURN          reduce using rule 12 (statement -> assignment .)
    PRINT           reduce using rule 12 (statement -> assignment .)
    IDENTIFIER      reduce using rule 12 (statement -> assignment .)
    IF              reduce using rule 12 (statement -> assignment .)
    FUNC            reduce using rule 12 (statement -> assignment .)
    INT_VALUE       reduce using rule 12 (statement -> assignment .)
    FLOAT_VALUE     reduce using rule 12 (statement -> assignment .)
    STRING_VALUE    reduce using rule 12 (statement -> assignment .)
    (               reduce using rule 12 (statement -> assignment .)
    UNARY           reduce using rule 12 (statement -> assignment .)
    INT             reduce using rule 12 (statement -> assignment .)
    FLOAT           reduce using rule 12 (statement -> assignment .)
    STRING          reduce using rule 12 (statement -> assignment .)
    ADAPT           reduce using rule 12 (statement -> assignment .)
    VOID            reduce using rule 12 (statement -> assignment .)
    FOR             reduce using rule 12 (statement -> assignment .)
    WHILE           reduce using rule 12 (statement -> assignment .)


state 20

    (16) function_calls -> IDENTIFIER . ( )
    (17) function_calls -> IDENTIFIER . ( ) function_calls
    (18) function_calls -> IDENTIFIER . ( parameters )
    (19) function_calls -> IDENTIFIER . ( parameters ) function_calls
    (36) variable -> IDENTIFIER .

  ! shift/reduce conflict for ( resolved as shift
    (               shift and go to state 49
    ADD             reduce using rule 36 (variable -> IDENTIFIER .)
    SUB             reduce using rule 36 (variable -> IDENTIFIER .)
    MUL             reduce using rule 36 (variable -> IDENTIFIER .)
    DIV             reduce using rule 36 (variable -> IDENTIFIER .)
    OR              reduce using rule 36 (variable -> IDENTIFIER .)
    LE              reduce using rule 36 (variable -> IDENTIFIER .)
    GE              reduce using rule 36 (variable -> IDENTIFIER .)
    EQ              reduce using rule 36 (variable -> IDENTIFIER .)
    NE              reduce using rule 36 (variable -> IDENTIFIER .)
    GT              reduce using rule 36 (variable -> IDENTIFIER .)
    LT              reduce using rule 36 (variable -> IDENTIFIER .)
    UNARY           reduce using rule 36 (variable -> IDENTIFIER .)
    }               reduce using rule 36 (variable -> IDENTIFIER .)
    RETURN          reduce using rule 36 (variable -> IDENTIFIER .)
    PRINT           reduce using rule 36 (variable -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 36 (variable -> IDENTIFIER .)
    IF              reduce using rule 36 (variable -> IDENTIFIER .)
    FUNC            reduce using rule 36 (variable -> IDENTIFIER .)
    INT_VALUE       reduce using rule 36 (variable -> IDENTIFIER .)
    FLOAT_VALUE     reduce using rule 36 (variable -> IDENTIFIER .)
    STRING_VALUE    reduce using rule 36 (variable -> IDENTIFIER .)
    INT             reduce using rule 36 (variable -> IDENTIFIER .)
    FLOAT           reduce using rule 36 (variable -> IDENTIFIER .)
    STRING          reduce using rule 36 (variable -> IDENTIFIER .)
    ADAPT           reduce using rule 36 (variable -> IDENTIFIER .)
    VOID            reduce using rule 36 (variable -> IDENTIFIER .)
    FOR             reduce using rule 36 (variable -> IDENTIFIER .)
    WHILE           reduce using rule 36 (variable -> IDENTIFIER .)

  ! (               [ reduce using rule 36 (variable -> IDENTIFIER .) ]


state 21

    (53) condition -> IF . expression { statements }
    (54) condition -> IF . expression { statements } ELSE { statements }
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (36) variable -> . IDENTIFIER

    INT_VALUE       shift and go to state 28
    FLOAT_VALUE     shift and go to state 29
    STRING_VALUE    shift and go to state 30
    (               shift and go to state 9
    UNARY           shift and go to state 32
    IDENTIFIER      shift and go to state 44

    expression                     shift and go to state 50
    atoms                          shift and go to state 23
    paren_expr                     shift and go to state 24
    binary_expr                    shift and go to state 25
    variable                       shift and go to state 31

state 22

    (13) function_declarations -> function_declaration .

    }               reduce using rule 13 (function_declarations -> function_declaration .)
    RETURN          reduce using rule 13 (function_declarations -> function_declaration .)
    PRINT           reduce using rule 13 (function_declarations -> function_declaration .)
    IDENTIFIER      reduce using rule 13 (function_declarations -> function_declaration .)
    IF              reduce using rule 13 (function_declarations -> function_declaration .)
    FUNC            reduce using rule 13 (function_declarations -> function_declaration .)
    INT_VALUE       reduce using rule 13 (function_declarations -> function_declaration .)
    FLOAT_VALUE     reduce using rule 13 (function_declarations -> function_declaration .)
    STRING_VALUE    reduce using rule 13 (function_declarations -> function_declaration .)
    (               reduce using rule 13 (function_declarations -> function_declaration .)
    UNARY           reduce using rule 13 (function_declarations -> function_declaration .)
    INT             reduce using rule 13 (function_declarations -> function_declaration .)
    FLOAT           reduce using rule 13 (function_declarations -> function_declaration .)
    STRING          reduce using rule 13 (function_declarations -> function_declaration .)
    ADAPT           reduce using rule 13 (function_declarations -> function_declaration .)
    VOID            reduce using rule 13 (function_declarations -> function_declaration .)
    FOR             reduce using rule 13 (function_declarations -> function_declaration .)
    WHILE           reduce using rule 13 (function_declarations -> function_declaration .)


state 23

    (29) expression -> atoms .
    (38) binary_expr -> atoms . ADD expression
    (39) binary_expr -> atoms . SUB expression
    (40) binary_expr -> atoms . MUL expression
    (41) binary_expr -> atoms . DIV expression
    (42) binary_expr -> atoms . OR expression
    (43) binary_expr -> atoms . LE expression
    (44) binary_expr -> atoms . GE expression
    (45) binary_expr -> atoms . EQ expression
    (46) binary_expr -> atoms . NE expression
    (47) binary_expr -> atoms . GT expression
    (48) binary_expr -> atoms . LT expression
    (50) binary_expr -> atoms . UNARY

  ! shift/reduce conflict for UNARY resolved as shift
    }               reduce using rule 29 (expression -> atoms .)
    RETURN          reduce using rule 29 (expression -> atoms .)
    PRINT           reduce using rule 29 (expression -> atoms .)
    IDENTIFIER      reduce using rule 29 (expression -> atoms .)
    IF              reduce using rule 29 (expression -> atoms .)
    FUNC            reduce using rule 29 (expression -> atoms .)
    INT_VALUE       reduce using rule 29 (expression -> atoms .)
    FLOAT_VALUE     reduce using rule 29 (expression -> atoms .)
    STRING_VALUE    reduce using rule 29 (expression -> atoms .)
    (               reduce using rule 29 (expression -> atoms .)
    INT             reduce using rule 29 (expression -> atoms .)
    FLOAT           reduce using rule 29 (expression -> atoms .)
    STRING          reduce using rule 29 (expression -> atoms .)
    ADAPT           reduce using rule 29 (expression -> atoms .)
    VOID            reduce using rule 29 (expression -> atoms .)
    FOR             reduce using rule 29 (expression -> atoms .)
    WHILE           reduce using rule 29 (expression -> atoms .)
    )               reduce using rule 29 (expression -> atoms .)
    {               reduce using rule 29 (expression -> atoms .)
    ;               reduce using rule 29 (expression -> atoms .)
    ADD             shift and go to state 51
    SUB             shift and go to state 52
    MUL             shift and go to state 53
    DIV             shift and go to state 54
    OR              shift and go to state 55
    LE              shift and go to state 56
    GE              shift and go to state 57
    EQ              shift and go to state 58
    NE              shift and go to state 59
    GT              shift and go to state 60
    LT              shift and go to state 61
    UNARY           shift and go to state 62

  ! UNARY           [ reduce using rule 29 (expression -> atoms .) ]


state 24

    (30) expression -> paren_expr .

    }               reduce using rule 30 (expression -> paren_expr .)
    RETURN          reduce using rule 30 (expression -> paren_expr .)
    PRINT           reduce using rule 30 (expression -> paren_expr .)
    IDENTIFIER      reduce using rule 30 (expression -> paren_expr .)
    IF              reduce using rule 30 (expression -> paren_expr .)
    FUNC            reduce using rule 30 (expression -> paren_expr .)
    INT_VALUE       reduce using rule 30 (expression -> paren_expr .)
    FLOAT_VALUE     reduce using rule 30 (expression -> paren_expr .)
    STRING_VALUE    reduce using rule 30 (expression -> paren_expr .)
    (               reduce using rule 30 (expression -> paren_expr .)
    UNARY           reduce using rule 30 (expression -> paren_expr .)
    INT             reduce using rule 30 (expression -> paren_expr .)
    FLOAT           reduce using rule 30 (expression -> paren_expr .)
    STRING          reduce using rule 30 (expression -> paren_expr .)
    ADAPT           reduce using rule 30 (expression -> paren_expr .)
    VOID            reduce using rule 30 (expression -> paren_expr .)
    FOR             reduce using rule 30 (expression -> paren_expr .)
    WHILE           reduce using rule 30 (expression -> paren_expr .)
    )               reduce using rule 30 (expression -> paren_expr .)
    {               reduce using rule 30 (expression -> paren_expr .)
    ;               reduce using rule 30 (expression -> paren_expr .)


state 25

    (31) expression -> binary_expr .

    }               reduce using rule 31 (expression -> binary_expr .)
    RETURN          reduce using rule 31 (expression -> binary_expr .)
    PRINT           reduce using rule 31 (expression -> binary_expr .)
    IDENTIFIER      reduce using rule 31 (expression -> binary_expr .)
    IF              reduce using rule 31 (expression -> binary_expr .)
    FUNC            reduce using rule 31 (expression -> binary_expr .)
    INT_VALUE       reduce using rule 31 (expression -> binary_expr .)
    FLOAT_VALUE     reduce using rule 31 (expression -> binary_expr .)
    STRING_VALUE    reduce using rule 31 (expression -> binary_expr .)
    (               reduce using rule 31 (expression -> binary_expr .)
    UNARY           reduce using rule 31 (expression -> binary_expr .)
    INT             reduce using rule 31 (expression -> binary_expr .)
    FLOAT           reduce using rule 31 (expression -> binary_expr .)
    STRING          reduce using rule 31 (expression -> binary_expr .)
    ADAPT           reduce using rule 31 (expression -> binary_expr .)
    VOID            reduce using rule 31 (expression -> binary_expr .)
    FOR             reduce using rule 31 (expression -> binary_expr .)
    WHILE           reduce using rule 31 (expression -> binary_expr .)
    )               reduce using rule 31 (expression -> binary_expr .)
    {               reduce using rule 31 (expression -> binary_expr .)
    ;               reduce using rule 31 (expression -> binary_expr .)


state 26

    (55) loops -> loop .
    (56) loops -> loop . loops
    (55) loops -> . loop
    (56) loops -> . loop loops
    (57) loop -> . forLoop
    (58) loop -> . whileLoop
    (59) forLoop -> . FOR ( expression ; condition ; expression ) { statements }
    (60) whileLoop -> . WHILE ( condition ) { statements }

  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
    }               reduce using rule 55 (loops -> loop .)
    RETURN          reduce using rule 55 (loops -> loop .)
    PRINT           reduce using rule 55 (loops -> loop .)
    IDENTIFIER      reduce using rule 55 (loops -> loop .)
    IF              reduce using rule 55 (loops -> loop .)
    FUNC            reduce using rule 55 (loops -> loop .)
    INT_VALUE       reduce using rule 55 (loops -> loop .)
    FLOAT_VALUE     reduce using rule 55 (loops -> loop .)
    STRING_VALUE    reduce using rule 55 (loops -> loop .)
    (               reduce using rule 55 (loops -> loop .)
    UNARY           reduce using rule 55 (loops -> loop .)
    INT             reduce using rule 55 (loops -> loop .)
    FLOAT           reduce using rule 55 (loops -> loop .)
    STRING          reduce using rule 55 (loops -> loop .)
    ADAPT           reduce using rule 55 (loops -> loop .)
    VOID            reduce using rule 55 (loops -> loop .)
    FOR             shift and go to state 40
    WHILE           shift and go to state 41

  ! FOR             [ reduce using rule 55 (loops -> loop .) ]
  ! WHILE           [ reduce using rule 55 (loops -> loop .) ]

    loop                           shift and go to state 26
    loops                          shift and go to state 63
    forLoop                        shift and go to state 33
    whileLoop                      shift and go to state 34

state 27

    (51) assignment -> datatype . IDENTIFIER EQUAL expression
    (52) assignment -> datatype . IDENTIFIER EQUAL ACCEPT ( )

    IDENTIFIER      shift and go to state 64


state 28

    (32) atoms -> INT_VALUE .

    ADD             reduce using rule 32 (atoms -> INT_VALUE .)
    SUB             reduce using rule 32 (atoms -> INT_VALUE .)
    MUL             reduce using rule 32 (atoms -> INT_VALUE .)
    DIV             reduce using rule 32 (atoms -> INT_VALUE .)
    OR              reduce using rule 32 (atoms -> INT_VALUE .)
    LE              reduce using rule 32 (atoms -> INT_VALUE .)
    GE              reduce using rule 32 (atoms -> INT_VALUE .)
    EQ              reduce using rule 32 (atoms -> INT_VALUE .)
    NE              reduce using rule 32 (atoms -> INT_VALUE .)
    GT              reduce using rule 32 (atoms -> INT_VALUE .)
    LT              reduce using rule 32 (atoms -> INT_VALUE .)
    UNARY           reduce using rule 32 (atoms -> INT_VALUE .)
    }               reduce using rule 32 (atoms -> INT_VALUE .)
    RETURN          reduce using rule 32 (atoms -> INT_VALUE .)
    PRINT           reduce using rule 32 (atoms -> INT_VALUE .)
    IDENTIFIER      reduce using rule 32 (atoms -> INT_VALUE .)
    IF              reduce using rule 32 (atoms -> INT_VALUE .)
    FUNC            reduce using rule 32 (atoms -> INT_VALUE .)
    INT_VALUE       reduce using rule 32 (atoms -> INT_VALUE .)
    FLOAT_VALUE     reduce using rule 32 (atoms -> INT_VALUE .)
    STRING_VALUE    reduce using rule 32 (atoms -> INT_VALUE .)
    (               reduce using rule 32 (atoms -> INT_VALUE .)
    INT             reduce using rule 32 (atoms -> INT_VALUE .)
    FLOAT           reduce using rule 32 (atoms -> INT_VALUE .)
    STRING          reduce using rule 32 (atoms -> INT_VALUE .)
    ADAPT           reduce using rule 32 (atoms -> INT_VALUE .)
    VOID            reduce using rule 32 (atoms -> INT_VALUE .)
    FOR             reduce using rule 32 (atoms -> INT_VALUE .)
    WHILE           reduce using rule 32 (atoms -> INT_VALUE .)
    )               reduce using rule 32 (atoms -> INT_VALUE .)
    {               reduce using rule 32 (atoms -> INT_VALUE .)
    ;               reduce using rule 32 (atoms -> INT_VALUE .)


state 29

    (33) atoms -> FLOAT_VALUE .

    ADD             reduce using rule 33 (atoms -> FLOAT_VALUE .)
    SUB             reduce using rule 33 (atoms -> FLOAT_VALUE .)
    MUL             reduce using rule 33 (atoms -> FLOAT_VALUE .)
    DIV             reduce using rule 33 (atoms -> FLOAT_VALUE .)
    OR              reduce using rule 33 (atoms -> FLOAT_VALUE .)
    LE              reduce using rule 33 (atoms -> FLOAT_VALUE .)
    GE              reduce using rule 33 (atoms -> FLOAT_VALUE .)
    EQ              reduce using rule 33 (atoms -> FLOAT_VALUE .)
    NE              reduce using rule 33 (atoms -> FLOAT_VALUE .)
    GT              reduce using rule 33 (atoms -> FLOAT_VALUE .)
    LT              reduce using rule 33 (atoms -> FLOAT_VALUE .)
    UNARY           reduce using rule 33 (atoms -> FLOAT_VALUE .)
    }               reduce using rule 33 (atoms -> FLOAT_VALUE .)
    RETURN          reduce using rule 33 (atoms -> FLOAT_VALUE .)
    PRINT           reduce using rule 33 (atoms -> FLOAT_VALUE .)
    IDENTIFIER      reduce using rule 33 (atoms -> FLOAT_VALUE .)
    IF              reduce using rule 33 (atoms -> FLOAT_VALUE .)
    FUNC            reduce using rule 33 (atoms -> FLOAT_VALUE .)
    INT_VALUE       reduce using rule 33 (atoms -> FLOAT_VALUE .)
    FLOAT_VALUE     reduce using rule 33 (atoms -> FLOAT_VALUE .)
    STRING_VALUE    reduce using rule 33 (atoms -> FLOAT_VALUE .)
    (               reduce using rule 33 (atoms -> FLOAT_VALUE .)
    INT             reduce using rule 33 (atoms -> FLOAT_VALUE .)
    FLOAT           reduce using rule 33 (atoms -> FLOAT_VALUE .)
    STRING          reduce using rule 33 (atoms -> FLOAT_VALUE .)
    ADAPT           reduce using rule 33 (atoms -> FLOAT_VALUE .)
    VOID            reduce using rule 33 (atoms -> FLOAT_VALUE .)
    FOR             reduce using rule 33 (atoms -> FLOAT_VALUE .)
    WHILE           reduce using rule 33 (atoms -> FLOAT_VALUE .)
    )               reduce using rule 33 (atoms -> FLOAT_VALUE .)
    {               reduce using rule 33 (atoms -> FLOAT_VALUE .)
    ;               reduce using rule 33 (atoms -> FLOAT_VALUE .)


state 30

    (34) atoms -> STRING_VALUE .

    ADD             reduce using rule 34 (atoms -> STRING_VALUE .)
    SUB             reduce using rule 34 (atoms -> STRING_VALUE .)
    MUL             reduce using rule 34 (atoms -> STRING_VALUE .)
    DIV             reduce using rule 34 (atoms -> STRING_VALUE .)
    OR              reduce using rule 34 (atoms -> STRING_VALUE .)
    LE              reduce using rule 34 (atoms -> STRING_VALUE .)
    GE              reduce using rule 34 (atoms -> STRING_VALUE .)
    EQ              reduce using rule 34 (atoms -> STRING_VALUE .)
    NE              reduce using rule 34 (atoms -> STRING_VALUE .)
    GT              reduce using rule 34 (atoms -> STRING_VALUE .)
    LT              reduce using rule 34 (atoms -> STRING_VALUE .)
    UNARY           reduce using rule 34 (atoms -> STRING_VALUE .)
    }               reduce using rule 34 (atoms -> STRING_VALUE .)
    RETURN          reduce using rule 34 (atoms -> STRING_VALUE .)
    PRINT           reduce using rule 34 (atoms -> STRING_VALUE .)
    IDENTIFIER      reduce using rule 34 (atoms -> STRING_VALUE .)
    IF              reduce using rule 34 (atoms -> STRING_VALUE .)
    FUNC            reduce using rule 34 (atoms -> STRING_VALUE .)
    INT_VALUE       reduce using rule 34 (atoms -> STRING_VALUE .)
    FLOAT_VALUE     reduce using rule 34 (atoms -> STRING_VALUE .)
    STRING_VALUE    reduce using rule 34 (atoms -> STRING_VALUE .)
    (               reduce using rule 34 (atoms -> STRING_VALUE .)
    INT             reduce using rule 34 (atoms -> STRING_VALUE .)
    FLOAT           reduce using rule 34 (atoms -> STRING_VALUE .)
    STRING          reduce using rule 34 (atoms -> STRING_VALUE .)
    ADAPT           reduce using rule 34 (atoms -> STRING_VALUE .)
    VOID            reduce using rule 34 (atoms -> STRING_VALUE .)
    FOR             reduce using rule 34 (atoms -> STRING_VALUE .)
    WHILE           reduce using rule 34 (atoms -> STRING_VALUE .)
    )               reduce using rule 34 (atoms -> STRING_VALUE .)
    {               reduce using rule 34 (atoms -> STRING_VALUE .)
    ;               reduce using rule 34 (atoms -> STRING_VALUE .)


state 31

    (35) atoms -> variable .

    ADD             reduce using rule 35 (atoms -> variable .)
    SUB             reduce using rule 35 (atoms -> variable .)
    MUL             reduce using rule 35 (atoms -> variable .)
    DIV             reduce using rule 35 (atoms -> variable .)
    OR              reduce using rule 35 (atoms -> variable .)
    LE              reduce using rule 35 (atoms -> variable .)
    GE              reduce using rule 35 (atoms -> variable .)
    EQ              reduce using rule 35 (atoms -> variable .)
    NE              reduce using rule 35 (atoms -> variable .)
    GT              reduce using rule 35 (atoms -> variable .)
    LT              reduce using rule 35 (atoms -> variable .)
    UNARY           reduce using rule 35 (atoms -> variable .)
    }               reduce using rule 35 (atoms -> variable .)
    RETURN          reduce using rule 35 (atoms -> variable .)
    PRINT           reduce using rule 35 (atoms -> variable .)
    IDENTIFIER      reduce using rule 35 (atoms -> variable .)
    IF              reduce using rule 35 (atoms -> variable .)
    FUNC            reduce using rule 35 (atoms -> variable .)
    INT_VALUE       reduce using rule 35 (atoms -> variable .)
    FLOAT_VALUE     reduce using rule 35 (atoms -> variable .)
    STRING_VALUE    reduce using rule 35 (atoms -> variable .)
    (               reduce using rule 35 (atoms -> variable .)
    INT             reduce using rule 35 (atoms -> variable .)
    FLOAT           reduce using rule 35 (atoms -> variable .)
    STRING          reduce using rule 35 (atoms -> variable .)
    ADAPT           reduce using rule 35 (atoms -> variable .)
    VOID            reduce using rule 35 (atoms -> variable .)
    FOR             reduce using rule 35 (atoms -> variable .)
    WHILE           reduce using rule 35 (atoms -> variable .)
    )               reduce using rule 35 (atoms -> variable .)
    {               reduce using rule 35 (atoms -> variable .)
    ;               reduce using rule 35 (atoms -> variable .)


state 32

    (49) binary_expr -> UNARY . atoms
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (36) variable -> . IDENTIFIER

    INT_VALUE       shift and go to state 28
    FLOAT_VALUE     shift and go to state 29
    STRING_VALUE    shift and go to state 30
    IDENTIFIER      shift and go to state 44

    atoms                          shift and go to state 65
    variable                       shift and go to state 31

state 33

    (57) loop -> forLoop .

    FOR             reduce using rule 57 (loop -> forLoop .)
    WHILE           reduce using rule 57 (loop -> forLoop .)
    }               reduce using rule 57 (loop -> forLoop .)
    RETURN          reduce using rule 57 (loop -> forLoop .)
    PRINT           reduce using rule 57 (loop -> forLoop .)
    IDENTIFIER      reduce using rule 57 (loop -> forLoop .)
    IF              reduce using rule 57 (loop -> forLoop .)
    FUNC            reduce using rule 57 (loop -> forLoop .)
    INT_VALUE       reduce using rule 57 (loop -> forLoop .)
    FLOAT_VALUE     reduce using rule 57 (loop -> forLoop .)
    STRING_VALUE    reduce using rule 57 (loop -> forLoop .)
    (               reduce using rule 57 (loop -> forLoop .)
    UNARY           reduce using rule 57 (loop -> forLoop .)
    INT             reduce using rule 57 (loop -> forLoop .)
    FLOAT           reduce using rule 57 (loop -> forLoop .)
    STRING          reduce using rule 57 (loop -> forLoop .)
    ADAPT           reduce using rule 57 (loop -> forLoop .)
    VOID            reduce using rule 57 (loop -> forLoop .)


state 34

    (58) loop -> whileLoop .

    FOR             reduce using rule 58 (loop -> whileLoop .)
    WHILE           reduce using rule 58 (loop -> whileLoop .)
    }               reduce using rule 58 (loop -> whileLoop .)
    RETURN          reduce using rule 58 (loop -> whileLoop .)
    PRINT           reduce using rule 58 (loop -> whileLoop .)
    IDENTIFIER      reduce using rule 58 (loop -> whileLoop .)
    IF              reduce using rule 58 (loop -> whileLoop .)
    FUNC            reduce using rule 58 (loop -> whileLoop .)
    INT_VALUE       reduce using rule 58 (loop -> whileLoop .)
    FLOAT_VALUE     reduce using rule 58 (loop -> whileLoop .)
    STRING_VALUE    reduce using rule 58 (loop -> whileLoop .)
    (               reduce using rule 58 (loop -> whileLoop .)
    UNARY           reduce using rule 58 (loop -> whileLoop .)
    INT             reduce using rule 58 (loop -> whileLoop .)
    FLOAT           reduce using rule 58 (loop -> whileLoop .)
    STRING          reduce using rule 58 (loop -> whileLoop .)
    ADAPT           reduce using rule 58 (loop -> whileLoop .)
    VOID            reduce using rule 58 (loop -> whileLoop .)


state 35

    (24) datatype -> INT .

    IDENTIFIER      reduce using rule 24 (datatype -> INT .)
    {               reduce using rule 24 (datatype -> INT .)


state 36

    (25) datatype -> FLOAT .

    IDENTIFIER      reduce using rule 25 (datatype -> FLOAT .)
    {               reduce using rule 25 (datatype -> FLOAT .)


state 37

    (26) datatype -> STRING .

    IDENTIFIER      reduce using rule 26 (datatype -> STRING .)
    {               reduce using rule 26 (datatype -> STRING .)


state 38

    (27) datatype -> ADAPT .

    IDENTIFIER      reduce using rule 27 (datatype -> ADAPT .)
    {               reduce using rule 27 (datatype -> ADAPT .)


state 39

    (28) datatype -> VOID .

    IDENTIFIER      reduce using rule 28 (datatype -> VOID .)
    {               reduce using rule 28 (datatype -> VOID .)


state 40

    (59) forLoop -> FOR . ( expression ; condition ; expression ) { statements }

    (               shift and go to state 66


state 41

    (60) whileLoop -> WHILE . ( condition ) { statements }

    (               shift and go to state 67


state 42

    (14) function_declaration -> FUNC IDENTIFIER . ( ) : datatype { function_body }

    (               shift and go to state 68


state 43

    (37) paren_expr -> ( expression . )

    )               shift and go to state 69


state 44

    (36) variable -> IDENTIFIER .

    ADD             reduce using rule 36 (variable -> IDENTIFIER .)
    SUB             reduce using rule 36 (variable -> IDENTIFIER .)
    MUL             reduce using rule 36 (variable -> IDENTIFIER .)
    DIV             reduce using rule 36 (variable -> IDENTIFIER .)
    OR              reduce using rule 36 (variable -> IDENTIFIER .)
    LE              reduce using rule 36 (variable -> IDENTIFIER .)
    GE              reduce using rule 36 (variable -> IDENTIFIER .)
    EQ              reduce using rule 36 (variable -> IDENTIFIER .)
    NE              reduce using rule 36 (variable -> IDENTIFIER .)
    GT              reduce using rule 36 (variable -> IDENTIFIER .)
    LT              reduce using rule 36 (variable -> IDENTIFIER .)
    UNARY           reduce using rule 36 (variable -> IDENTIFIER .)
    )               reduce using rule 36 (variable -> IDENTIFIER .)
    }               reduce using rule 36 (variable -> IDENTIFIER .)
    RETURN          reduce using rule 36 (variable -> IDENTIFIER .)
    PRINT           reduce using rule 36 (variable -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 36 (variable -> IDENTIFIER .)
    IF              reduce using rule 36 (variable -> IDENTIFIER .)
    FUNC            reduce using rule 36 (variable -> IDENTIFIER .)
    INT_VALUE       reduce using rule 36 (variable -> IDENTIFIER .)
    FLOAT_VALUE     reduce using rule 36 (variable -> IDENTIFIER .)
    STRING_VALUE    reduce using rule 36 (variable -> IDENTIFIER .)
    (               reduce using rule 36 (variable -> IDENTIFIER .)
    INT             reduce using rule 36 (variable -> IDENTIFIER .)
    FLOAT           reduce using rule 36 (variable -> IDENTIFIER .)
    STRING          reduce using rule 36 (variable -> IDENTIFIER .)
    ADAPT           reduce using rule 36 (variable -> IDENTIFIER .)
    VOID            reduce using rule 36 (variable -> IDENTIFIER .)
    FOR             reduce using rule 36 (variable -> IDENTIFIER .)
    WHILE           reduce using rule 36 (variable -> IDENTIFIER .)
    {               reduce using rule 36 (variable -> IDENTIFIER .)
    ;               reduce using rule 36 (variable -> IDENTIFIER .)


state 45

    (2) programStart -> FUNC INIT ( ) { statements } .

    $end            reduce using rule 2 (programStart -> FUNC INIT ( ) { statements } .)


state 46

    (4) statements -> statements statement .

    }               reduce using rule 4 (statements -> statements statement .)
    RETURN          reduce using rule 4 (statements -> statements statement .)
    PRINT           reduce using rule 4 (statements -> statements statement .)
    IDENTIFIER      reduce using rule 4 (statements -> statements statement .)
    IF              reduce using rule 4 (statements -> statements statement .)
    FUNC            reduce using rule 4 (statements -> statements statement .)
    INT_VALUE       reduce using rule 4 (statements -> statements statement .)
    FLOAT_VALUE     reduce using rule 4 (statements -> statements statement .)
    STRING_VALUE    reduce using rule 4 (statements -> statements statement .)
    (               reduce using rule 4 (statements -> statements statement .)
    UNARY           reduce using rule 4 (statements -> statements statement .)
    INT             reduce using rule 4 (statements -> statements statement .)
    FLOAT           reduce using rule 4 (statements -> statements statement .)
    STRING          reduce using rule 4 (statements -> statements statement .)
    ADAPT           reduce using rule 4 (statements -> statements statement .)
    VOID            reduce using rule 4 (statements -> statements statement .)
    FOR             reduce using rule 4 (statements -> statements statement .)
    WHILE           reduce using rule 4 (statements -> statements statement .)


state 47

    (10) statement -> RETURN expression .

    }               reduce using rule 10 (statement -> RETURN expression .)
    RETURN          reduce using rule 10 (statement -> RETURN expression .)
    PRINT           reduce using rule 10 (statement -> RETURN expression .)
    IDENTIFIER      reduce using rule 10 (statement -> RETURN expression .)
    IF              reduce using rule 10 (statement -> RETURN expression .)
    FUNC            reduce using rule 10 (statement -> RETURN expression .)
    INT_VALUE       reduce using rule 10 (statement -> RETURN expression .)
    FLOAT_VALUE     reduce using rule 10 (statement -> RETURN expression .)
    STRING_VALUE    reduce using rule 10 (statement -> RETURN expression .)
    (               reduce using rule 10 (statement -> RETURN expression .)
    UNARY           reduce using rule 10 (statement -> RETURN expression .)
    INT             reduce using rule 10 (statement -> RETURN expression .)
    FLOAT           reduce using rule 10 (statement -> RETURN expression .)
    STRING          reduce using rule 10 (statement -> RETURN expression .)
    ADAPT           reduce using rule 10 (statement -> RETURN expression .)
    VOID            reduce using rule 10 (statement -> RETURN expression .)
    FOR             reduce using rule 10 (statement -> RETURN expression .)
    WHILE           reduce using rule 10 (statement -> RETURN expression .)


state 48

    (11) statement -> PRINT ( . expression )
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (36) variable -> . IDENTIFIER

    INT_VALUE       shift and go to state 28
    FLOAT_VALUE     shift and go to state 29
    STRING_VALUE    shift and go to state 30
    (               shift and go to state 9
    UNARY           shift and go to state 32
    IDENTIFIER      shift and go to state 44

    expression                     shift and go to state 70
    atoms                          shift and go to state 23
    paren_expr                     shift and go to state 24
    binary_expr                    shift and go to state 25
    variable                       shift and go to state 31

state 49

    (16) function_calls -> IDENTIFIER ( . )
    (17) function_calls -> IDENTIFIER ( . ) function_calls
    (18) function_calls -> IDENTIFIER ( . parameters )
    (19) function_calls -> IDENTIFIER ( . parameters ) function_calls
    (20) parameters -> . parameterList
    (21) parameterList -> . parameter
    (22) parameterList -> . parameter , parameterList
    (23) parameter -> . datatype IDENTIFIER
    (24) datatype -> . INT
    (25) datatype -> . FLOAT
    (26) datatype -> . STRING
    (27) datatype -> . ADAPT
    (28) datatype -> . VOID

    )               shift and go to state 71
    INT             shift and go to state 35
    FLOAT           shift and go to state 36
    STRING          shift and go to state 37
    ADAPT           shift and go to state 38
    VOID            shift and go to state 39

    parameters                     shift and go to state 72
    parameterList                  shift and go to state 73
    parameter                      shift and go to state 74
    datatype                       shift and go to state 75

state 50

    (53) condition -> IF expression . { statements }
    (54) condition -> IF expression . { statements } ELSE { statements }

    {               shift and go to state 76


state 51

    (38) binary_expr -> atoms ADD . expression
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (36) variable -> . IDENTIFIER

    INT_VALUE       shift and go to state 28
    FLOAT_VALUE     shift and go to state 29
    STRING_VALUE    shift and go to state 30
    (               shift and go to state 9
    UNARY           shift and go to state 32
    IDENTIFIER      shift and go to state 44

    atoms                          shift and go to state 23
    expression                     shift and go to state 77
    paren_expr                     shift and go to state 24
    binary_expr                    shift and go to state 25
    variable                       shift and go to state 31

state 52

    (39) binary_expr -> atoms SUB . expression
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (36) variable -> . IDENTIFIER

    INT_VALUE       shift and go to state 28
    FLOAT_VALUE     shift and go to state 29
    STRING_VALUE    shift and go to state 30
    (               shift and go to state 9
    UNARY           shift and go to state 32
    IDENTIFIER      shift and go to state 44

    atoms                          shift and go to state 23
    expression                     shift and go to state 78
    paren_expr                     shift and go to state 24
    binary_expr                    shift and go to state 25
    variable                       shift and go to state 31

state 53

    (40) binary_expr -> atoms MUL . expression
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (36) variable -> . IDENTIFIER

    INT_VALUE       shift and go to state 28
    FLOAT_VALUE     shift and go to state 29
    STRING_VALUE    shift and go to state 30
    (               shift and go to state 9
    UNARY           shift and go to state 32
    IDENTIFIER      shift and go to state 44

    atoms                          shift and go to state 23
    expression                     shift and go to state 79
    paren_expr                     shift and go to state 24
    binary_expr                    shift and go to state 25
    variable                       shift and go to state 31

state 54

    (41) binary_expr -> atoms DIV . expression
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (36) variable -> . IDENTIFIER

    INT_VALUE       shift and go to state 28
    FLOAT_VALUE     shift and go to state 29
    STRING_VALUE    shift and go to state 30
    (               shift and go to state 9
    UNARY           shift and go to state 32
    IDENTIFIER      shift and go to state 44

    atoms                          shift and go to state 23
    expression                     shift and go to state 80
    paren_expr                     shift and go to state 24
    binary_expr                    shift and go to state 25
    variable                       shift and go to state 31

state 55

    (42) binary_expr -> atoms OR . expression
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (36) variable -> . IDENTIFIER

    INT_VALUE       shift and go to state 28
    FLOAT_VALUE     shift and go to state 29
    STRING_VALUE    shift and go to state 30
    (               shift and go to state 9
    UNARY           shift and go to state 32
    IDENTIFIER      shift and go to state 44

    atoms                          shift and go to state 23
    expression                     shift and go to state 81
    paren_expr                     shift and go to state 24
    binary_expr                    shift and go to state 25
    variable                       shift and go to state 31

state 56

    (43) binary_expr -> atoms LE . expression
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (36) variable -> . IDENTIFIER

    INT_VALUE       shift and go to state 28
    FLOAT_VALUE     shift and go to state 29
    STRING_VALUE    shift and go to state 30
    (               shift and go to state 9
    UNARY           shift and go to state 32
    IDENTIFIER      shift and go to state 44

    atoms                          shift and go to state 23
    expression                     shift and go to state 82
    paren_expr                     shift and go to state 24
    binary_expr                    shift and go to state 25
    variable                       shift and go to state 31

state 57

    (44) binary_expr -> atoms GE . expression
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (36) variable -> . IDENTIFIER

    INT_VALUE       shift and go to state 28
    FLOAT_VALUE     shift and go to state 29
    STRING_VALUE    shift and go to state 30
    (               shift and go to state 9
    UNARY           shift and go to state 32
    IDENTIFIER      shift and go to state 44

    atoms                          shift and go to state 23
    expression                     shift and go to state 83
    paren_expr                     shift and go to state 24
    binary_expr                    shift and go to state 25
    variable                       shift and go to state 31

state 58

    (45) binary_expr -> atoms EQ . expression
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (36) variable -> . IDENTIFIER

    INT_VALUE       shift and go to state 28
    FLOAT_VALUE     shift and go to state 29
    STRING_VALUE    shift and go to state 30
    (               shift and go to state 9
    UNARY           shift and go to state 32
    IDENTIFIER      shift and go to state 44

    atoms                          shift and go to state 23
    expression                     shift and go to state 84
    paren_expr                     shift and go to state 24
    binary_expr                    shift and go to state 25
    variable                       shift and go to state 31

state 59

    (46) binary_expr -> atoms NE . expression
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (36) variable -> . IDENTIFIER

    INT_VALUE       shift and go to state 28
    FLOAT_VALUE     shift and go to state 29
    STRING_VALUE    shift and go to state 30
    (               shift and go to state 9
    UNARY           shift and go to state 32
    IDENTIFIER      shift and go to state 44

    atoms                          shift and go to state 23
    expression                     shift and go to state 85
    paren_expr                     shift and go to state 24
    binary_expr                    shift and go to state 25
    variable                       shift and go to state 31

state 60

    (47) binary_expr -> atoms GT . expression
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (36) variable -> . IDENTIFIER

    INT_VALUE       shift and go to state 28
    FLOAT_VALUE     shift and go to state 29
    STRING_VALUE    shift and go to state 30
    (               shift and go to state 9
    UNARY           shift and go to state 32
    IDENTIFIER      shift and go to state 44

    atoms                          shift and go to state 23
    expression                     shift and go to state 86
    paren_expr                     shift and go to state 24
    binary_expr                    shift and go to state 25
    variable                       shift and go to state 31

state 61

    (48) binary_expr -> atoms LT . expression
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (36) variable -> . IDENTIFIER

    INT_VALUE       shift and go to state 28
    FLOAT_VALUE     shift and go to state 29
    STRING_VALUE    shift and go to state 30
    (               shift and go to state 9
    UNARY           shift and go to state 32
    IDENTIFIER      shift and go to state 44

    atoms                          shift and go to state 23
    expression                     shift and go to state 87
    paren_expr                     shift and go to state 24
    binary_expr                    shift and go to state 25
    variable                       shift and go to state 31

state 62

    (50) binary_expr -> atoms UNARY .

    }               reduce using rule 50 (binary_expr -> atoms UNARY .)
    RETURN          reduce using rule 50 (binary_expr -> atoms UNARY .)
    PRINT           reduce using rule 50 (binary_expr -> atoms UNARY .)
    IDENTIFIER      reduce using rule 50 (binary_expr -> atoms UNARY .)
    IF              reduce using rule 50 (binary_expr -> atoms UNARY .)
    FUNC            reduce using rule 50 (binary_expr -> atoms UNARY .)
    INT_VALUE       reduce using rule 50 (binary_expr -> atoms UNARY .)
    FLOAT_VALUE     reduce using rule 50 (binary_expr -> atoms UNARY .)
    STRING_VALUE    reduce using rule 50 (binary_expr -> atoms UNARY .)
    (               reduce using rule 50 (binary_expr -> atoms UNARY .)
    UNARY           reduce using rule 50 (binary_expr -> atoms UNARY .)
    INT             reduce using rule 50 (binary_expr -> atoms UNARY .)
    FLOAT           reduce using rule 50 (binary_expr -> atoms UNARY .)
    STRING          reduce using rule 50 (binary_expr -> atoms UNARY .)
    ADAPT           reduce using rule 50 (binary_expr -> atoms UNARY .)
    VOID            reduce using rule 50 (binary_expr -> atoms UNARY .)
    FOR             reduce using rule 50 (binary_expr -> atoms UNARY .)
    WHILE           reduce using rule 50 (binary_expr -> atoms UNARY .)
    )               reduce using rule 50 (binary_expr -> atoms UNARY .)
    {               reduce using rule 50 (binary_expr -> atoms UNARY .)
    ;               reduce using rule 50 (binary_expr -> atoms UNARY .)


state 63

    (56) loops -> loop loops .

    }               reduce using rule 56 (loops -> loop loops .)
    RETURN          reduce using rule 56 (loops -> loop loops .)
    PRINT           reduce using rule 56 (loops -> loop loops .)
    IDENTIFIER      reduce using rule 56 (loops -> loop loops .)
    IF              reduce using rule 56 (loops -> loop loops .)
    FUNC            reduce using rule 56 (loops -> loop loops .)
    INT_VALUE       reduce using rule 56 (loops -> loop loops .)
    FLOAT_VALUE     reduce using rule 56 (loops -> loop loops .)
    STRING_VALUE    reduce using rule 56 (loops -> loop loops .)
    (               reduce using rule 56 (loops -> loop loops .)
    UNARY           reduce using rule 56 (loops -> loop loops .)
    INT             reduce using rule 56 (loops -> loop loops .)
    FLOAT           reduce using rule 56 (loops -> loop loops .)
    STRING          reduce using rule 56 (loops -> loop loops .)
    ADAPT           reduce using rule 56 (loops -> loop loops .)
    VOID            reduce using rule 56 (loops -> loop loops .)
    FOR             reduce using rule 56 (loops -> loop loops .)
    WHILE           reduce using rule 56 (loops -> loop loops .)


state 64

    (51) assignment -> datatype IDENTIFIER . EQUAL expression
    (52) assignment -> datatype IDENTIFIER . EQUAL ACCEPT ( )

    EQUAL           shift and go to state 88


state 65

    (49) binary_expr -> UNARY atoms .

    }               reduce using rule 49 (binary_expr -> UNARY atoms .)
    RETURN          reduce using rule 49 (binary_expr -> UNARY atoms .)
    PRINT           reduce using rule 49 (binary_expr -> UNARY atoms .)
    IDENTIFIER      reduce using rule 49 (binary_expr -> UNARY atoms .)
    IF              reduce using rule 49 (binary_expr -> UNARY atoms .)
    FUNC            reduce using rule 49 (binary_expr -> UNARY atoms .)
    INT_VALUE       reduce using rule 49 (binary_expr -> UNARY atoms .)
    FLOAT_VALUE     reduce using rule 49 (binary_expr -> UNARY atoms .)
    STRING_VALUE    reduce using rule 49 (binary_expr -> UNARY atoms .)
    (               reduce using rule 49 (binary_expr -> UNARY atoms .)
    UNARY           reduce using rule 49 (binary_expr -> UNARY atoms .)
    INT             reduce using rule 49 (binary_expr -> UNARY atoms .)
    FLOAT           reduce using rule 49 (binary_expr -> UNARY atoms .)
    STRING          reduce using rule 49 (binary_expr -> UNARY atoms .)
    ADAPT           reduce using rule 49 (binary_expr -> UNARY atoms .)
    VOID            reduce using rule 49 (binary_expr -> UNARY atoms .)
    FOR             reduce using rule 49 (binary_expr -> UNARY atoms .)
    WHILE           reduce using rule 49 (binary_expr -> UNARY atoms .)
    )               reduce using rule 49 (binary_expr -> UNARY atoms .)
    {               reduce using rule 49 (binary_expr -> UNARY atoms .)
    ;               reduce using rule 49 (binary_expr -> UNARY atoms .)


state 66

    (59) forLoop -> FOR ( . expression ; condition ; expression ) { statements }
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (36) variable -> . IDENTIFIER

    INT_VALUE       shift and go to state 28
    FLOAT_VALUE     shift and go to state 29
    STRING_VALUE    shift and go to state 30
    (               shift and go to state 9
    UNARY           shift and go to state 32
    IDENTIFIER      shift and go to state 44

    expression                     shift and go to state 89
    atoms                          shift and go to state 23
    paren_expr                     shift and go to state 24
    binary_expr                    shift and go to state 25
    variable                       shift and go to state 31

state 67

    (60) whileLoop -> WHILE ( . condition ) { statements }
    (53) condition -> . IF expression { statements }
    (54) condition -> . IF expression { statements } ELSE { statements }

    IF              shift and go to state 21

    condition                      shift and go to state 90

state 68

    (14) function_declaration -> FUNC IDENTIFIER ( . ) : datatype { function_body }

    )               shift and go to state 91


state 69

    (37) paren_expr -> ( expression ) .

    }               reduce using rule 37 (paren_expr -> ( expression ) .)
    RETURN          reduce using rule 37 (paren_expr -> ( expression ) .)
    PRINT           reduce using rule 37 (paren_expr -> ( expression ) .)
    IDENTIFIER      reduce using rule 37 (paren_expr -> ( expression ) .)
    IF              reduce using rule 37 (paren_expr -> ( expression ) .)
    FUNC            reduce using rule 37 (paren_expr -> ( expression ) .)
    INT_VALUE       reduce using rule 37 (paren_expr -> ( expression ) .)
    FLOAT_VALUE     reduce using rule 37 (paren_expr -> ( expression ) .)
    STRING_VALUE    reduce using rule 37 (paren_expr -> ( expression ) .)
    (               reduce using rule 37 (paren_expr -> ( expression ) .)
    UNARY           reduce using rule 37 (paren_expr -> ( expression ) .)
    INT             reduce using rule 37 (paren_expr -> ( expression ) .)
    FLOAT           reduce using rule 37 (paren_expr -> ( expression ) .)
    STRING          reduce using rule 37 (paren_expr -> ( expression ) .)
    ADAPT           reduce using rule 37 (paren_expr -> ( expression ) .)
    VOID            reduce using rule 37 (paren_expr -> ( expression ) .)
    FOR             reduce using rule 37 (paren_expr -> ( expression ) .)
    WHILE           reduce using rule 37 (paren_expr -> ( expression ) .)
    )               reduce using rule 37 (paren_expr -> ( expression ) .)
    {               reduce using rule 37 (paren_expr -> ( expression ) .)
    ;               reduce using rule 37 (paren_expr -> ( expression ) .)


state 70

    (11) statement -> PRINT ( expression . )

    )               shift and go to state 92


state 71

    (16) function_calls -> IDENTIFIER ( ) .
    (17) function_calls -> IDENTIFIER ( ) . function_calls
    (16) function_calls -> . IDENTIFIER ( )
    (17) function_calls -> . IDENTIFIER ( ) function_calls
    (18) function_calls -> . IDENTIFIER ( parameters )
    (19) function_calls -> . IDENTIFIER ( parameters ) function_calls

  ! shift/reduce conflict for IDENTIFIER resolved as shift
    }               reduce using rule 16 (function_calls -> IDENTIFIER ( ) .)
    RETURN          reduce using rule 16 (function_calls -> IDENTIFIER ( ) .)
    PRINT           reduce using rule 16 (function_calls -> IDENTIFIER ( ) .)
    IF              reduce using rule 16 (function_calls -> IDENTIFIER ( ) .)
    FUNC            reduce using rule 16 (function_calls -> IDENTIFIER ( ) .)
    INT_VALUE       reduce using rule 16 (function_calls -> IDENTIFIER ( ) .)
    FLOAT_VALUE     reduce using rule 16 (function_calls -> IDENTIFIER ( ) .)
    STRING_VALUE    reduce using rule 16 (function_calls -> IDENTIFIER ( ) .)
    (               reduce using rule 16 (function_calls -> IDENTIFIER ( ) .)
    UNARY           reduce using rule 16 (function_calls -> IDENTIFIER ( ) .)
    INT             reduce using rule 16 (function_calls -> IDENTIFIER ( ) .)
    FLOAT           reduce using rule 16 (function_calls -> IDENTIFIER ( ) .)
    STRING          reduce using rule 16 (function_calls -> IDENTIFIER ( ) .)
    ADAPT           reduce using rule 16 (function_calls -> IDENTIFIER ( ) .)
    VOID            reduce using rule 16 (function_calls -> IDENTIFIER ( ) .)
    FOR             reduce using rule 16 (function_calls -> IDENTIFIER ( ) .)
    WHILE           reduce using rule 16 (function_calls -> IDENTIFIER ( ) .)
    IDENTIFIER      shift and go to state 93

  ! IDENTIFIER      [ reduce using rule 16 (function_calls -> IDENTIFIER ( ) .) ]

    function_calls                 shift and go to state 94

state 72

    (18) function_calls -> IDENTIFIER ( parameters . )
    (19) function_calls -> IDENTIFIER ( parameters . ) function_calls

    )               shift and go to state 95


state 73

    (20) parameters -> parameterList .

    )               reduce using rule 20 (parameters -> parameterList .)


state 74

    (21) parameterList -> parameter .
    (22) parameterList -> parameter . , parameterList

    )               reduce using rule 21 (parameterList -> parameter .)
    ,               shift and go to state 96


state 75

    (23) parameter -> datatype . IDENTIFIER

    IDENTIFIER      shift and go to state 97


state 76

    (53) condition -> IF expression { . statements }
    (54) condition -> IF expression { . statements } ELSE { statements }
    (3) statements -> . statement
    (4) statements -> . statements statement
    (5) statement -> . function_calls
    (6) statement -> . condition
    (7) statement -> . function_declarations
    (8) statement -> . expression
    (9) statement -> . loops
    (10) statement -> . RETURN expression
    (11) statement -> . PRINT ( expression )
    (12) statement -> . assignment
    (16) function_calls -> . IDENTIFIER ( )
    (17) function_calls -> . IDENTIFIER ( ) function_calls
    (18) function_calls -> . IDENTIFIER ( parameters )
    (19) function_calls -> . IDENTIFIER ( parameters ) function_calls
    (53) condition -> . IF expression { statements }
    (54) condition -> . IF expression { statements } ELSE { statements }
    (13) function_declarations -> . function_declaration
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (55) loops -> . loop
    (56) loops -> . loop loops
    (51) assignment -> . datatype IDENTIFIER EQUAL expression
    (52) assignment -> . datatype IDENTIFIER EQUAL ACCEPT ( )
    (14) function_declaration -> . FUNC IDENTIFIER ( ) : datatype { function_body }
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (57) loop -> . forLoop
    (58) loop -> . whileLoop
    (24) datatype -> . INT
    (25) datatype -> . FLOAT
    (26) datatype -> . STRING
    (27) datatype -> . ADAPT
    (28) datatype -> . VOID
    (36) variable -> . IDENTIFIER
    (59) forLoop -> . FOR ( expression ; condition ; expression ) { statements }
    (60) whileLoop -> . WHILE ( condition ) { statements }

    RETURN          shift and go to state 17
    PRINT           shift and go to state 18
    IDENTIFIER      shift and go to state 20
    IF              shift and go to state 21
    FUNC            shift and go to state 8
    INT_VALUE       shift and go to state 28
    FLOAT_VALUE     shift and go to state 29
    STRING_VALUE    shift and go to state 30
    (               shift and go to state 9
    UNARY           shift and go to state 32
    INT             shift and go to state 35
    FLOAT           shift and go to state 36
    STRING          shift and go to state 37
    ADAPT           shift and go to state 38
    VOID            shift and go to state 39
    FOR             shift and go to state 40
    WHILE           shift and go to state 41

    expression                     shift and go to state 15
    statements                     shift and go to state 98
    statement                      shift and go to state 11
    function_calls                 shift and go to state 12
    condition                      shift and go to state 13
    function_declarations          shift and go to state 14
    loops                          shift and go to state 16
    assignment                     shift and go to state 19
    function_declaration           shift and go to state 22
    atoms                          shift and go to state 23
    paren_expr                     shift and go to state 24
    binary_expr                    shift and go to state 25
    loop                           shift and go to state 26
    datatype                       shift and go to state 27
    variable                       shift and go to state 31
    forLoop                        shift and go to state 33
    whileLoop                      shift and go to state 34

state 77

    (38) binary_expr -> atoms ADD expression .

    }               reduce using rule 38 (binary_expr -> atoms ADD expression .)
    RETURN          reduce using rule 38 (binary_expr -> atoms ADD expression .)
    PRINT           reduce using rule 38 (binary_expr -> atoms ADD expression .)
    IDENTIFIER      reduce using rule 38 (binary_expr -> atoms ADD expression .)
    IF              reduce using rule 38 (binary_expr -> atoms ADD expression .)
    FUNC            reduce using rule 38 (binary_expr -> atoms ADD expression .)
    INT_VALUE       reduce using rule 38 (binary_expr -> atoms ADD expression .)
    FLOAT_VALUE     reduce using rule 38 (binary_expr -> atoms ADD expression .)
    STRING_VALUE    reduce using rule 38 (binary_expr -> atoms ADD expression .)
    (               reduce using rule 38 (binary_expr -> atoms ADD expression .)
    UNARY           reduce using rule 38 (binary_expr -> atoms ADD expression .)
    INT             reduce using rule 38 (binary_expr -> atoms ADD expression .)
    FLOAT           reduce using rule 38 (binary_expr -> atoms ADD expression .)
    STRING          reduce using rule 38 (binary_expr -> atoms ADD expression .)
    ADAPT           reduce using rule 38 (binary_expr -> atoms ADD expression .)
    VOID            reduce using rule 38 (binary_expr -> atoms ADD expression .)
    FOR             reduce using rule 38 (binary_expr -> atoms ADD expression .)
    WHILE           reduce using rule 38 (binary_expr -> atoms ADD expression .)
    )               reduce using rule 38 (binary_expr -> atoms ADD expression .)
    {               reduce using rule 38 (binary_expr -> atoms ADD expression .)
    ;               reduce using rule 38 (binary_expr -> atoms ADD expression .)


state 78

    (39) binary_expr -> atoms SUB expression .

    }               reduce using rule 39 (binary_expr -> atoms SUB expression .)
    RETURN          reduce using rule 39 (binary_expr -> atoms SUB expression .)
    PRINT           reduce using rule 39 (binary_expr -> atoms SUB expression .)
    IDENTIFIER      reduce using rule 39 (binary_expr -> atoms SUB expression .)
    IF              reduce using rule 39 (binary_expr -> atoms SUB expression .)
    FUNC            reduce using rule 39 (binary_expr -> atoms SUB expression .)
    INT_VALUE       reduce using rule 39 (binary_expr -> atoms SUB expression .)
    FLOAT_VALUE     reduce using rule 39 (binary_expr -> atoms SUB expression .)
    STRING_VALUE    reduce using rule 39 (binary_expr -> atoms SUB expression .)
    (               reduce using rule 39 (binary_expr -> atoms SUB expression .)
    UNARY           reduce using rule 39 (binary_expr -> atoms SUB expression .)
    INT             reduce using rule 39 (binary_expr -> atoms SUB expression .)
    FLOAT           reduce using rule 39 (binary_expr -> atoms SUB expression .)
    STRING          reduce using rule 39 (binary_expr -> atoms SUB expression .)
    ADAPT           reduce using rule 39 (binary_expr -> atoms SUB expression .)
    VOID            reduce using rule 39 (binary_expr -> atoms SUB expression .)
    FOR             reduce using rule 39 (binary_expr -> atoms SUB expression .)
    WHILE           reduce using rule 39 (binary_expr -> atoms SUB expression .)
    )               reduce using rule 39 (binary_expr -> atoms SUB expression .)
    {               reduce using rule 39 (binary_expr -> atoms SUB expression .)
    ;               reduce using rule 39 (binary_expr -> atoms SUB expression .)


state 79

    (40) binary_expr -> atoms MUL expression .

    }               reduce using rule 40 (binary_expr -> atoms MUL expression .)
    RETURN          reduce using rule 40 (binary_expr -> atoms MUL expression .)
    PRINT           reduce using rule 40 (binary_expr -> atoms MUL expression .)
    IDENTIFIER      reduce using rule 40 (binary_expr -> atoms MUL expression .)
    IF              reduce using rule 40 (binary_expr -> atoms MUL expression .)
    FUNC            reduce using rule 40 (binary_expr -> atoms MUL expression .)
    INT_VALUE       reduce using rule 40 (binary_expr -> atoms MUL expression .)
    FLOAT_VALUE     reduce using rule 40 (binary_expr -> atoms MUL expression .)
    STRING_VALUE    reduce using rule 40 (binary_expr -> atoms MUL expression .)
    (               reduce using rule 40 (binary_expr -> atoms MUL expression .)
    UNARY           reduce using rule 40 (binary_expr -> atoms MUL expression .)
    INT             reduce using rule 40 (binary_expr -> atoms MUL expression .)
    FLOAT           reduce using rule 40 (binary_expr -> atoms MUL expression .)
    STRING          reduce using rule 40 (binary_expr -> atoms MUL expression .)
    ADAPT           reduce using rule 40 (binary_expr -> atoms MUL expression .)
    VOID            reduce using rule 40 (binary_expr -> atoms MUL expression .)
    FOR             reduce using rule 40 (binary_expr -> atoms MUL expression .)
    WHILE           reduce using rule 40 (binary_expr -> atoms MUL expression .)
    )               reduce using rule 40 (binary_expr -> atoms MUL expression .)
    {               reduce using rule 40 (binary_expr -> atoms MUL expression .)
    ;               reduce using rule 40 (binary_expr -> atoms MUL expression .)


state 80

    (41) binary_expr -> atoms DIV expression .

    }               reduce using rule 41 (binary_expr -> atoms DIV expression .)
    RETURN          reduce using rule 41 (binary_expr -> atoms DIV expression .)
    PRINT           reduce using rule 41 (binary_expr -> atoms DIV expression .)
    IDENTIFIER      reduce using rule 41 (binary_expr -> atoms DIV expression .)
    IF              reduce using rule 41 (binary_expr -> atoms DIV expression .)
    FUNC            reduce using rule 41 (binary_expr -> atoms DIV expression .)
    INT_VALUE       reduce using rule 41 (binary_expr -> atoms DIV expression .)
    FLOAT_VALUE     reduce using rule 41 (binary_expr -> atoms DIV expression .)
    STRING_VALUE    reduce using rule 41 (binary_expr -> atoms DIV expression .)
    (               reduce using rule 41 (binary_expr -> atoms DIV expression .)
    UNARY           reduce using rule 41 (binary_expr -> atoms DIV expression .)
    INT             reduce using rule 41 (binary_expr -> atoms DIV expression .)
    FLOAT           reduce using rule 41 (binary_expr -> atoms DIV expression .)
    STRING          reduce using rule 41 (binary_expr -> atoms DIV expression .)
    ADAPT           reduce using rule 41 (binary_expr -> atoms DIV expression .)
    VOID            reduce using rule 41 (binary_expr -> atoms DIV expression .)
    FOR             reduce using rule 41 (binary_expr -> atoms DIV expression .)
    WHILE           reduce using rule 41 (binary_expr -> atoms DIV expression .)
    )               reduce using rule 41 (binary_expr -> atoms DIV expression .)
    {               reduce using rule 41 (binary_expr -> atoms DIV expression .)
    ;               reduce using rule 41 (binary_expr -> atoms DIV expression .)


state 81

    (42) binary_expr -> atoms OR expression .

    }               reduce using rule 42 (binary_expr -> atoms OR expression .)
    RETURN          reduce using rule 42 (binary_expr -> atoms OR expression .)
    PRINT           reduce using rule 42 (binary_expr -> atoms OR expression .)
    IDENTIFIER      reduce using rule 42 (binary_expr -> atoms OR expression .)
    IF              reduce using rule 42 (binary_expr -> atoms OR expression .)
    FUNC            reduce using rule 42 (binary_expr -> atoms OR expression .)
    INT_VALUE       reduce using rule 42 (binary_expr -> atoms OR expression .)
    FLOAT_VALUE     reduce using rule 42 (binary_expr -> atoms OR expression .)
    STRING_VALUE    reduce using rule 42 (binary_expr -> atoms OR expression .)
    (               reduce using rule 42 (binary_expr -> atoms OR expression .)
    UNARY           reduce using rule 42 (binary_expr -> atoms OR expression .)
    INT             reduce using rule 42 (binary_expr -> atoms OR expression .)
    FLOAT           reduce using rule 42 (binary_expr -> atoms OR expression .)
    STRING          reduce using rule 42 (binary_expr -> atoms OR expression .)
    ADAPT           reduce using rule 42 (binary_expr -> atoms OR expression .)
    VOID            reduce using rule 42 (binary_expr -> atoms OR expression .)
    FOR             reduce using rule 42 (binary_expr -> atoms OR expression .)
    WHILE           reduce using rule 42 (binary_expr -> atoms OR expression .)
    )               reduce using rule 42 (binary_expr -> atoms OR expression .)
    {               reduce using rule 42 (binary_expr -> atoms OR expression .)
    ;               reduce using rule 42 (binary_expr -> atoms OR expression .)


state 82

    (43) binary_expr -> atoms LE expression .

    }               reduce using rule 43 (binary_expr -> atoms LE expression .)
    RETURN          reduce using rule 43 (binary_expr -> atoms LE expression .)
    PRINT           reduce using rule 43 (binary_expr -> atoms LE expression .)
    IDENTIFIER      reduce using rule 43 (binary_expr -> atoms LE expression .)
    IF              reduce using rule 43 (binary_expr -> atoms LE expression .)
    FUNC            reduce using rule 43 (binary_expr -> atoms LE expression .)
    INT_VALUE       reduce using rule 43 (binary_expr -> atoms LE expression .)
    FLOAT_VALUE     reduce using rule 43 (binary_expr -> atoms LE expression .)
    STRING_VALUE    reduce using rule 43 (binary_expr -> atoms LE expression .)
    (               reduce using rule 43 (binary_expr -> atoms LE expression .)
    UNARY           reduce using rule 43 (binary_expr -> atoms LE expression .)
    INT             reduce using rule 43 (binary_expr -> atoms LE expression .)
    FLOAT           reduce using rule 43 (binary_expr -> atoms LE expression .)
    STRING          reduce using rule 43 (binary_expr -> atoms LE expression .)
    ADAPT           reduce using rule 43 (binary_expr -> atoms LE expression .)
    VOID            reduce using rule 43 (binary_expr -> atoms LE expression .)
    FOR             reduce using rule 43 (binary_expr -> atoms LE expression .)
    WHILE           reduce using rule 43 (binary_expr -> atoms LE expression .)
    )               reduce using rule 43 (binary_expr -> atoms LE expression .)
    {               reduce using rule 43 (binary_expr -> atoms LE expression .)
    ;               reduce using rule 43 (binary_expr -> atoms LE expression .)


state 83

    (44) binary_expr -> atoms GE expression .

    }               reduce using rule 44 (binary_expr -> atoms GE expression .)
    RETURN          reduce using rule 44 (binary_expr -> atoms GE expression .)
    PRINT           reduce using rule 44 (binary_expr -> atoms GE expression .)
    IDENTIFIER      reduce using rule 44 (binary_expr -> atoms GE expression .)
    IF              reduce using rule 44 (binary_expr -> atoms GE expression .)
    FUNC            reduce using rule 44 (binary_expr -> atoms GE expression .)
    INT_VALUE       reduce using rule 44 (binary_expr -> atoms GE expression .)
    FLOAT_VALUE     reduce using rule 44 (binary_expr -> atoms GE expression .)
    STRING_VALUE    reduce using rule 44 (binary_expr -> atoms GE expression .)
    (               reduce using rule 44 (binary_expr -> atoms GE expression .)
    UNARY           reduce using rule 44 (binary_expr -> atoms GE expression .)
    INT             reduce using rule 44 (binary_expr -> atoms GE expression .)
    FLOAT           reduce using rule 44 (binary_expr -> atoms GE expression .)
    STRING          reduce using rule 44 (binary_expr -> atoms GE expression .)
    ADAPT           reduce using rule 44 (binary_expr -> atoms GE expression .)
    VOID            reduce using rule 44 (binary_expr -> atoms GE expression .)
    FOR             reduce using rule 44 (binary_expr -> atoms GE expression .)
    WHILE           reduce using rule 44 (binary_expr -> atoms GE expression .)
    )               reduce using rule 44 (binary_expr -> atoms GE expression .)
    {               reduce using rule 44 (binary_expr -> atoms GE expression .)
    ;               reduce using rule 44 (binary_expr -> atoms GE expression .)


state 84

    (45) binary_expr -> atoms EQ expression .

    }               reduce using rule 45 (binary_expr -> atoms EQ expression .)
    RETURN          reduce using rule 45 (binary_expr -> atoms EQ expression .)
    PRINT           reduce using rule 45 (binary_expr -> atoms EQ expression .)
    IDENTIFIER      reduce using rule 45 (binary_expr -> atoms EQ expression .)
    IF              reduce using rule 45 (binary_expr -> atoms EQ expression .)
    FUNC            reduce using rule 45 (binary_expr -> atoms EQ expression .)
    INT_VALUE       reduce using rule 45 (binary_expr -> atoms EQ expression .)
    FLOAT_VALUE     reduce using rule 45 (binary_expr -> atoms EQ expression .)
    STRING_VALUE    reduce using rule 45 (binary_expr -> atoms EQ expression .)
    (               reduce using rule 45 (binary_expr -> atoms EQ expression .)
    UNARY           reduce using rule 45 (binary_expr -> atoms EQ expression .)
    INT             reduce using rule 45 (binary_expr -> atoms EQ expression .)
    FLOAT           reduce using rule 45 (binary_expr -> atoms EQ expression .)
    STRING          reduce using rule 45 (binary_expr -> atoms EQ expression .)
    ADAPT           reduce using rule 45 (binary_expr -> atoms EQ expression .)
    VOID            reduce using rule 45 (binary_expr -> atoms EQ expression .)
    FOR             reduce using rule 45 (binary_expr -> atoms EQ expression .)
    WHILE           reduce using rule 45 (binary_expr -> atoms EQ expression .)
    )               reduce using rule 45 (binary_expr -> atoms EQ expression .)
    {               reduce using rule 45 (binary_expr -> atoms EQ expression .)
    ;               reduce using rule 45 (binary_expr -> atoms EQ expression .)


state 85

    (46) binary_expr -> atoms NE expression .

    }               reduce using rule 46 (binary_expr -> atoms NE expression .)
    RETURN          reduce using rule 46 (binary_expr -> atoms NE expression .)
    PRINT           reduce using rule 46 (binary_expr -> atoms NE expression .)
    IDENTIFIER      reduce using rule 46 (binary_expr -> atoms NE expression .)
    IF              reduce using rule 46 (binary_expr -> atoms NE expression .)
    FUNC            reduce using rule 46 (binary_expr -> atoms NE expression .)
    INT_VALUE       reduce using rule 46 (binary_expr -> atoms NE expression .)
    FLOAT_VALUE     reduce using rule 46 (binary_expr -> atoms NE expression .)
    STRING_VALUE    reduce using rule 46 (binary_expr -> atoms NE expression .)
    (               reduce using rule 46 (binary_expr -> atoms NE expression .)
    UNARY           reduce using rule 46 (binary_expr -> atoms NE expression .)
    INT             reduce using rule 46 (binary_expr -> atoms NE expression .)
    FLOAT           reduce using rule 46 (binary_expr -> atoms NE expression .)
    STRING          reduce using rule 46 (binary_expr -> atoms NE expression .)
    ADAPT           reduce using rule 46 (binary_expr -> atoms NE expression .)
    VOID            reduce using rule 46 (binary_expr -> atoms NE expression .)
    FOR             reduce using rule 46 (binary_expr -> atoms NE expression .)
    WHILE           reduce using rule 46 (binary_expr -> atoms NE expression .)
    )               reduce using rule 46 (binary_expr -> atoms NE expression .)
    {               reduce using rule 46 (binary_expr -> atoms NE expression .)
    ;               reduce using rule 46 (binary_expr -> atoms NE expression .)


state 86

    (47) binary_expr -> atoms GT expression .

    }               reduce using rule 47 (binary_expr -> atoms GT expression .)
    RETURN          reduce using rule 47 (binary_expr -> atoms GT expression .)
    PRINT           reduce using rule 47 (binary_expr -> atoms GT expression .)
    IDENTIFIER      reduce using rule 47 (binary_expr -> atoms GT expression .)
    IF              reduce using rule 47 (binary_expr -> atoms GT expression .)
    FUNC            reduce using rule 47 (binary_expr -> atoms GT expression .)
    INT_VALUE       reduce using rule 47 (binary_expr -> atoms GT expression .)
    FLOAT_VALUE     reduce using rule 47 (binary_expr -> atoms GT expression .)
    STRING_VALUE    reduce using rule 47 (binary_expr -> atoms GT expression .)
    (               reduce using rule 47 (binary_expr -> atoms GT expression .)
    UNARY           reduce using rule 47 (binary_expr -> atoms GT expression .)
    INT             reduce using rule 47 (binary_expr -> atoms GT expression .)
    FLOAT           reduce using rule 47 (binary_expr -> atoms GT expression .)
    STRING          reduce using rule 47 (binary_expr -> atoms GT expression .)
    ADAPT           reduce using rule 47 (binary_expr -> atoms GT expression .)
    VOID            reduce using rule 47 (binary_expr -> atoms GT expression .)
    FOR             reduce using rule 47 (binary_expr -> atoms GT expression .)
    WHILE           reduce using rule 47 (binary_expr -> atoms GT expression .)
    )               reduce using rule 47 (binary_expr -> atoms GT expression .)
    {               reduce using rule 47 (binary_expr -> atoms GT expression .)
    ;               reduce using rule 47 (binary_expr -> atoms GT expression .)


state 87

    (48) binary_expr -> atoms LT expression .

    }               reduce using rule 48 (binary_expr -> atoms LT expression .)
    RETURN          reduce using rule 48 (binary_expr -> atoms LT expression .)
    PRINT           reduce using rule 48 (binary_expr -> atoms LT expression .)
    IDENTIFIER      reduce using rule 48 (binary_expr -> atoms LT expression .)
    IF              reduce using rule 48 (binary_expr -> atoms LT expression .)
    FUNC            reduce using rule 48 (binary_expr -> atoms LT expression .)
    INT_VALUE       reduce using rule 48 (binary_expr -> atoms LT expression .)
    FLOAT_VALUE     reduce using rule 48 (binary_expr -> atoms LT expression .)
    STRING_VALUE    reduce using rule 48 (binary_expr -> atoms LT expression .)
    (               reduce using rule 48 (binary_expr -> atoms LT expression .)
    UNARY           reduce using rule 48 (binary_expr -> atoms LT expression .)
    INT             reduce using rule 48 (binary_expr -> atoms LT expression .)
    FLOAT           reduce using rule 48 (binary_expr -> atoms LT expression .)
    STRING          reduce using rule 48 (binary_expr -> atoms LT expression .)
    ADAPT           reduce using rule 48 (binary_expr -> atoms LT expression .)
    VOID            reduce using rule 48 (binary_expr -> atoms LT expression .)
    FOR             reduce using rule 48 (binary_expr -> atoms LT expression .)
    WHILE           reduce using rule 48 (binary_expr -> atoms LT expression .)
    )               reduce using rule 48 (binary_expr -> atoms LT expression .)
    {               reduce using rule 48 (binary_expr -> atoms LT expression .)
    ;               reduce using rule 48 (binary_expr -> atoms LT expression .)


state 88

    (51) assignment -> datatype IDENTIFIER EQUAL . expression
    (52) assignment -> datatype IDENTIFIER EQUAL . ACCEPT ( )
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (36) variable -> . IDENTIFIER

    ACCEPT          shift and go to state 100
    INT_VALUE       shift and go to state 28
    FLOAT_VALUE     shift and go to state 29
    STRING_VALUE    shift and go to state 30
    (               shift and go to state 9
    UNARY           shift and go to state 32
    IDENTIFIER      shift and go to state 44

    expression                     shift and go to state 99
    atoms                          shift and go to state 23
    paren_expr                     shift and go to state 24
    binary_expr                    shift and go to state 25
    variable                       shift and go to state 31

state 89

    (59) forLoop -> FOR ( expression . ; condition ; expression ) { statements }

    ;               shift and go to state 101


state 90

    (60) whileLoop -> WHILE ( condition . ) { statements }

    )               shift and go to state 102


state 91

    (14) function_declaration -> FUNC IDENTIFIER ( ) . : datatype { function_body }

    :               shift and go to state 103


state 92

    (11) statement -> PRINT ( expression ) .

    }               reduce using rule 11 (statement -> PRINT ( expression ) .)
    RETURN          reduce using rule 11 (statement -> PRINT ( expression ) .)
    PRINT           reduce using rule 11 (statement -> PRINT ( expression ) .)
    IDENTIFIER      reduce using rule 11 (statement -> PRINT ( expression ) .)
    IF              reduce using rule 11 (statement -> PRINT ( expression ) .)
    FUNC            reduce using rule 11 (statement -> PRINT ( expression ) .)
    INT_VALUE       reduce using rule 11 (statement -> PRINT ( expression ) .)
    FLOAT_VALUE     reduce using rule 11 (statement -> PRINT ( expression ) .)
    STRING_VALUE    reduce using rule 11 (statement -> PRINT ( expression ) .)
    (               reduce using rule 11 (statement -> PRINT ( expression ) .)
    UNARY           reduce using rule 11 (statement -> PRINT ( expression ) .)
    INT             reduce using rule 11 (statement -> PRINT ( expression ) .)
    FLOAT           reduce using rule 11 (statement -> PRINT ( expression ) .)
    STRING          reduce using rule 11 (statement -> PRINT ( expression ) .)
    ADAPT           reduce using rule 11 (statement -> PRINT ( expression ) .)
    VOID            reduce using rule 11 (statement -> PRINT ( expression ) .)
    FOR             reduce using rule 11 (statement -> PRINT ( expression ) .)
    WHILE           reduce using rule 11 (statement -> PRINT ( expression ) .)


state 93

    (16) function_calls -> IDENTIFIER . ( )
    (17) function_calls -> IDENTIFIER . ( ) function_calls
    (18) function_calls -> IDENTIFIER . ( parameters )
    (19) function_calls -> IDENTIFIER . ( parameters ) function_calls

    (               shift and go to state 49


state 94

    (17) function_calls -> IDENTIFIER ( ) function_calls .

    }               reduce using rule 17 (function_calls -> IDENTIFIER ( ) function_calls .)
    RETURN          reduce using rule 17 (function_calls -> IDENTIFIER ( ) function_calls .)
    PRINT           reduce using rule 17 (function_calls -> IDENTIFIER ( ) function_calls .)
    IDENTIFIER      reduce using rule 17 (function_calls -> IDENTIFIER ( ) function_calls .)
    IF              reduce using rule 17 (function_calls -> IDENTIFIER ( ) function_calls .)
    FUNC            reduce using rule 17 (function_calls -> IDENTIFIER ( ) function_calls .)
    INT_VALUE       reduce using rule 17 (function_calls -> IDENTIFIER ( ) function_calls .)
    FLOAT_VALUE     reduce using rule 17 (function_calls -> IDENTIFIER ( ) function_calls .)
    STRING_VALUE    reduce using rule 17 (function_calls -> IDENTIFIER ( ) function_calls .)
    (               reduce using rule 17 (function_calls -> IDENTIFIER ( ) function_calls .)
    UNARY           reduce using rule 17 (function_calls -> IDENTIFIER ( ) function_calls .)
    INT             reduce using rule 17 (function_calls -> IDENTIFIER ( ) function_calls .)
    FLOAT           reduce using rule 17 (function_calls -> IDENTIFIER ( ) function_calls .)
    STRING          reduce using rule 17 (function_calls -> IDENTIFIER ( ) function_calls .)
    ADAPT           reduce using rule 17 (function_calls -> IDENTIFIER ( ) function_calls .)
    VOID            reduce using rule 17 (function_calls -> IDENTIFIER ( ) function_calls .)
    FOR             reduce using rule 17 (function_calls -> IDENTIFIER ( ) function_calls .)
    WHILE           reduce using rule 17 (function_calls -> IDENTIFIER ( ) function_calls .)


state 95

    (18) function_calls -> IDENTIFIER ( parameters ) .
    (19) function_calls -> IDENTIFIER ( parameters ) . function_calls
    (16) function_calls -> . IDENTIFIER ( )
    (17) function_calls -> . IDENTIFIER ( ) function_calls
    (18) function_calls -> . IDENTIFIER ( parameters )
    (19) function_calls -> . IDENTIFIER ( parameters ) function_calls

  ! shift/reduce conflict for IDENTIFIER resolved as shift
    }               reduce using rule 18 (function_calls -> IDENTIFIER ( parameters ) .)
    RETURN          reduce using rule 18 (function_calls -> IDENTIFIER ( parameters ) .)
    PRINT           reduce using rule 18 (function_calls -> IDENTIFIER ( parameters ) .)
    IF              reduce using rule 18 (function_calls -> IDENTIFIER ( parameters ) .)
    FUNC            reduce using rule 18 (function_calls -> IDENTIFIER ( parameters ) .)
    INT_VALUE       reduce using rule 18 (function_calls -> IDENTIFIER ( parameters ) .)
    FLOAT_VALUE     reduce using rule 18 (function_calls -> IDENTIFIER ( parameters ) .)
    STRING_VALUE    reduce using rule 18 (function_calls -> IDENTIFIER ( parameters ) .)
    (               reduce using rule 18 (function_calls -> IDENTIFIER ( parameters ) .)
    UNARY           reduce using rule 18 (function_calls -> IDENTIFIER ( parameters ) .)
    INT             reduce using rule 18 (function_calls -> IDENTIFIER ( parameters ) .)
    FLOAT           reduce using rule 18 (function_calls -> IDENTIFIER ( parameters ) .)
    STRING          reduce using rule 18 (function_calls -> IDENTIFIER ( parameters ) .)
    ADAPT           reduce using rule 18 (function_calls -> IDENTIFIER ( parameters ) .)
    VOID            reduce using rule 18 (function_calls -> IDENTIFIER ( parameters ) .)
    FOR             reduce using rule 18 (function_calls -> IDENTIFIER ( parameters ) .)
    WHILE           reduce using rule 18 (function_calls -> IDENTIFIER ( parameters ) .)
    IDENTIFIER      shift and go to state 93

  ! IDENTIFIER      [ reduce using rule 18 (function_calls -> IDENTIFIER ( parameters ) .) ]

    function_calls                 shift and go to state 104

state 96

    (22) parameterList -> parameter , . parameterList
    (21) parameterList -> . parameter
    (22) parameterList -> . parameter , parameterList
    (23) parameter -> . datatype IDENTIFIER
    (24) datatype -> . INT
    (25) datatype -> . FLOAT
    (26) datatype -> . STRING
    (27) datatype -> . ADAPT
    (28) datatype -> . VOID

    INT             shift and go to state 35
    FLOAT           shift and go to state 36
    STRING          shift and go to state 37
    ADAPT           shift and go to state 38
    VOID            shift and go to state 39

    parameter                      shift and go to state 74
    parameterList                  shift and go to state 105
    datatype                       shift and go to state 75

state 97

    (23) parameter -> datatype IDENTIFIER .

    ,               reduce using rule 23 (parameter -> datatype IDENTIFIER .)
    )               reduce using rule 23 (parameter -> datatype IDENTIFIER .)


state 98

    (53) condition -> IF expression { statements . }
    (54) condition -> IF expression { statements . } ELSE { statements }
    (4) statements -> statements . statement
    (5) statement -> . function_calls
    (6) statement -> . condition
    (7) statement -> . function_declarations
    (8) statement -> . expression
    (9) statement -> . loops
    (10) statement -> . RETURN expression
    (11) statement -> . PRINT ( expression )
    (12) statement -> . assignment
    (16) function_calls -> . IDENTIFIER ( )
    (17) function_calls -> . IDENTIFIER ( ) function_calls
    (18) function_calls -> . IDENTIFIER ( parameters )
    (19) function_calls -> . IDENTIFIER ( parameters ) function_calls
    (53) condition -> . IF expression { statements }
    (54) condition -> . IF expression { statements } ELSE { statements }
    (13) function_declarations -> . function_declaration
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (55) loops -> . loop
    (56) loops -> . loop loops
    (51) assignment -> . datatype IDENTIFIER EQUAL expression
    (52) assignment -> . datatype IDENTIFIER EQUAL ACCEPT ( )
    (14) function_declaration -> . FUNC IDENTIFIER ( ) : datatype { function_body }
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (57) loop -> . forLoop
    (58) loop -> . whileLoop
    (24) datatype -> . INT
    (25) datatype -> . FLOAT
    (26) datatype -> . STRING
    (27) datatype -> . ADAPT
    (28) datatype -> . VOID
    (36) variable -> . IDENTIFIER
    (59) forLoop -> . FOR ( expression ; condition ; expression ) { statements }
    (60) whileLoop -> . WHILE ( condition ) { statements }

    }               shift and go to state 106
    RETURN          shift and go to state 17
    PRINT           shift and go to state 18
    IDENTIFIER      shift and go to state 20
    IF              shift and go to state 21
    FUNC            shift and go to state 8
    INT_VALUE       shift and go to state 28
    FLOAT_VALUE     shift and go to state 29
    STRING_VALUE    shift and go to state 30
    (               shift and go to state 9
    UNARY           shift and go to state 32
    INT             shift and go to state 35
    FLOAT           shift and go to state 36
    STRING          shift and go to state 37
    ADAPT           shift and go to state 38
    VOID            shift and go to state 39
    FOR             shift and go to state 40
    WHILE           shift and go to state 41

    expression                     shift and go to state 15
    statement                      shift and go to state 46
    function_calls                 shift and go to state 12
    condition                      shift and go to state 13
    function_declarations          shift and go to state 14
    loops                          shift and go to state 16
    assignment                     shift and go to state 19
    function_declaration           shift and go to state 22
    atoms                          shift and go to state 23
    paren_expr                     shift and go to state 24
    binary_expr                    shift and go to state 25
    loop                           shift and go to state 26
    datatype                       shift and go to state 27
    variable                       shift and go to state 31
    forLoop                        shift and go to state 33
    whileLoop                      shift and go to state 34

state 99

    (51) assignment -> datatype IDENTIFIER EQUAL expression .

    }               reduce using rule 51 (assignment -> datatype IDENTIFIER EQUAL expression .)
    RETURN          reduce using rule 51 (assignment -> datatype IDENTIFIER EQUAL expression .)
    PRINT           reduce using rule 51 (assignment -> datatype IDENTIFIER EQUAL expression .)
    IDENTIFIER      reduce using rule 51 (assignment -> datatype IDENTIFIER EQUAL expression .)
    IF              reduce using rule 51 (assignment -> datatype IDENTIFIER EQUAL expression .)
    FUNC            reduce using rule 51 (assignment -> datatype IDENTIFIER EQUAL expression .)
    INT_VALUE       reduce using rule 51 (assignment -> datatype IDENTIFIER EQUAL expression .)
    FLOAT_VALUE     reduce using rule 51 (assignment -> datatype IDENTIFIER EQUAL expression .)
    STRING_VALUE    reduce using rule 51 (assignment -> datatype IDENTIFIER EQUAL expression .)
    (               reduce using rule 51 (assignment -> datatype IDENTIFIER EQUAL expression .)
    UNARY           reduce using rule 51 (assignment -> datatype IDENTIFIER EQUAL expression .)
    INT             reduce using rule 51 (assignment -> datatype IDENTIFIER EQUAL expression .)
    FLOAT           reduce using rule 51 (assignment -> datatype IDENTIFIER EQUAL expression .)
    STRING          reduce using rule 51 (assignment -> datatype IDENTIFIER EQUAL expression .)
    ADAPT           reduce using rule 51 (assignment -> datatype IDENTIFIER EQUAL expression .)
    VOID            reduce using rule 51 (assignment -> datatype IDENTIFIER EQUAL expression .)
    FOR             reduce using rule 51 (assignment -> datatype IDENTIFIER EQUAL expression .)
    WHILE           reduce using rule 51 (assignment -> datatype IDENTIFIER EQUAL expression .)


state 100

    (52) assignment -> datatype IDENTIFIER EQUAL ACCEPT . ( )

    (               shift and go to state 107


state 101

    (59) forLoop -> FOR ( expression ; . condition ; expression ) { statements }
    (53) condition -> . IF expression { statements }
    (54) condition -> . IF expression { statements } ELSE { statements }

    IF              shift and go to state 21

    condition                      shift and go to state 108

state 102

    (60) whileLoop -> WHILE ( condition ) . { statements }

    {               shift and go to state 109


state 103

    (14) function_declaration -> FUNC IDENTIFIER ( ) : . datatype { function_body }
    (24) datatype -> . INT
    (25) datatype -> . FLOAT
    (26) datatype -> . STRING
    (27) datatype -> . ADAPT
    (28) datatype -> . VOID

    INT             shift and go to state 35
    FLOAT           shift and go to state 36
    STRING          shift and go to state 37
    ADAPT           shift and go to state 38
    VOID            shift and go to state 39

    datatype                       shift and go to state 110

state 104

    (19) function_calls -> IDENTIFIER ( parameters ) function_calls .

    }               reduce using rule 19 (function_calls -> IDENTIFIER ( parameters ) function_calls .)
    RETURN          reduce using rule 19 (function_calls -> IDENTIFIER ( parameters ) function_calls .)
    PRINT           reduce using rule 19 (function_calls -> IDENTIFIER ( parameters ) function_calls .)
    IDENTIFIER      reduce using rule 19 (function_calls -> IDENTIFIER ( parameters ) function_calls .)
    IF              reduce using rule 19 (function_calls -> IDENTIFIER ( parameters ) function_calls .)
    FUNC            reduce using rule 19 (function_calls -> IDENTIFIER ( parameters ) function_calls .)
    INT_VALUE       reduce using rule 19 (function_calls -> IDENTIFIER ( parameters ) function_calls .)
    FLOAT_VALUE     reduce using rule 19 (function_calls -> IDENTIFIER ( parameters ) function_calls .)
    STRING_VALUE    reduce using rule 19 (function_calls -> IDENTIFIER ( parameters ) function_calls .)
    (               reduce using rule 19 (function_calls -> IDENTIFIER ( parameters ) function_calls .)
    UNARY           reduce using rule 19 (function_calls -> IDENTIFIER ( parameters ) function_calls .)
    INT             reduce using rule 19 (function_calls -> IDENTIFIER ( parameters ) function_calls .)
    FLOAT           reduce using rule 19 (function_calls -> IDENTIFIER ( parameters ) function_calls .)
    STRING          reduce using rule 19 (function_calls -> IDENTIFIER ( parameters ) function_calls .)
    ADAPT           reduce using rule 19 (function_calls -> IDENTIFIER ( parameters ) function_calls .)
    VOID            reduce using rule 19 (function_calls -> IDENTIFIER ( parameters ) function_calls .)
    FOR             reduce using rule 19 (function_calls -> IDENTIFIER ( parameters ) function_calls .)
    WHILE           reduce using rule 19 (function_calls -> IDENTIFIER ( parameters ) function_calls .)


state 105

    (22) parameterList -> parameter , parameterList .

    )               reduce using rule 22 (parameterList -> parameter , parameterList .)


state 106

    (53) condition -> IF expression { statements } .
    (54) condition -> IF expression { statements } . ELSE { statements }

    }               reduce using rule 53 (condition -> IF expression { statements } .)
    RETURN          reduce using rule 53 (condition -> IF expression { statements } .)
    PRINT           reduce using rule 53 (condition -> IF expression { statements } .)
    IDENTIFIER      reduce using rule 53 (condition -> IF expression { statements } .)
    IF              reduce using rule 53 (condition -> IF expression { statements } .)
    FUNC            reduce using rule 53 (condition -> IF expression { statements } .)
    INT_VALUE       reduce using rule 53 (condition -> IF expression { statements } .)
    FLOAT_VALUE     reduce using rule 53 (condition -> IF expression { statements } .)
    STRING_VALUE    reduce using rule 53 (condition -> IF expression { statements } .)
    (               reduce using rule 53 (condition -> IF expression { statements } .)
    UNARY           reduce using rule 53 (condition -> IF expression { statements } .)
    INT             reduce using rule 53 (condition -> IF expression { statements } .)
    FLOAT           reduce using rule 53 (condition -> IF expression { statements } .)
    STRING          reduce using rule 53 (condition -> IF expression { statements } .)
    ADAPT           reduce using rule 53 (condition -> IF expression { statements } .)
    VOID            reduce using rule 53 (condition -> IF expression { statements } .)
    FOR             reduce using rule 53 (condition -> IF expression { statements } .)
    WHILE           reduce using rule 53 (condition -> IF expression { statements } .)
    )               reduce using rule 53 (condition -> IF expression { statements } .)
    ;               reduce using rule 53 (condition -> IF expression { statements } .)
    ELSE            shift and go to state 111


state 107

    (52) assignment -> datatype IDENTIFIER EQUAL ACCEPT ( . )

    )               shift and go to state 112


state 108

    (59) forLoop -> FOR ( expression ; condition . ; expression ) { statements }

    ;               shift and go to state 113


state 109

    (60) whileLoop -> WHILE ( condition ) { . statements }
    (3) statements -> . statement
    (4) statements -> . statements statement
    (5) statement -> . function_calls
    (6) statement -> . condition
    (7) statement -> . function_declarations
    (8) statement -> . expression
    (9) statement -> . loops
    (10) statement -> . RETURN expression
    (11) statement -> . PRINT ( expression )
    (12) statement -> . assignment
    (16) function_calls -> . IDENTIFIER ( )
    (17) function_calls -> . IDENTIFIER ( ) function_calls
    (18) function_calls -> . IDENTIFIER ( parameters )
    (19) function_calls -> . IDENTIFIER ( parameters ) function_calls
    (53) condition -> . IF expression { statements }
    (54) condition -> . IF expression { statements } ELSE { statements }
    (13) function_declarations -> . function_declaration
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (55) loops -> . loop
    (56) loops -> . loop loops
    (51) assignment -> . datatype IDENTIFIER EQUAL expression
    (52) assignment -> . datatype IDENTIFIER EQUAL ACCEPT ( )
    (14) function_declaration -> . FUNC IDENTIFIER ( ) : datatype { function_body }
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (57) loop -> . forLoop
    (58) loop -> . whileLoop
    (24) datatype -> . INT
    (25) datatype -> . FLOAT
    (26) datatype -> . STRING
    (27) datatype -> . ADAPT
    (28) datatype -> . VOID
    (36) variable -> . IDENTIFIER
    (59) forLoop -> . FOR ( expression ; condition ; expression ) { statements }
    (60) whileLoop -> . WHILE ( condition ) { statements }

    RETURN          shift and go to state 17
    PRINT           shift and go to state 18
    IDENTIFIER      shift and go to state 20
    IF              shift and go to state 21
    FUNC            shift and go to state 8
    INT_VALUE       shift and go to state 28
    FLOAT_VALUE     shift and go to state 29
    STRING_VALUE    shift and go to state 30
    (               shift and go to state 9
    UNARY           shift and go to state 32
    INT             shift and go to state 35
    FLOAT           shift and go to state 36
    STRING          shift and go to state 37
    ADAPT           shift and go to state 38
    VOID            shift and go to state 39
    FOR             shift and go to state 40
    WHILE           shift and go to state 41

    condition                      shift and go to state 13
    statements                     shift and go to state 114
    statement                      shift and go to state 11
    function_calls                 shift and go to state 12
    function_declarations          shift and go to state 14
    expression                     shift and go to state 15
    loops                          shift and go to state 16
    assignment                     shift and go to state 19
    function_declaration           shift and go to state 22
    atoms                          shift and go to state 23
    paren_expr                     shift and go to state 24
    binary_expr                    shift and go to state 25
    loop                           shift and go to state 26
    datatype                       shift and go to state 27
    variable                       shift and go to state 31
    forLoop                        shift and go to state 33
    whileLoop                      shift and go to state 34

state 110

    (14) function_declaration -> FUNC IDENTIFIER ( ) : datatype . { function_body }

    {               shift and go to state 115


state 111

    (54) condition -> IF expression { statements } ELSE . { statements }

    {               shift and go to state 116


state 112

    (52) assignment -> datatype IDENTIFIER EQUAL ACCEPT ( ) .

    }               reduce using rule 52 (assignment -> datatype IDENTIFIER EQUAL ACCEPT ( ) .)
    RETURN          reduce using rule 52 (assignment -> datatype IDENTIFIER EQUAL ACCEPT ( ) .)
    PRINT           reduce using rule 52 (assignment -> datatype IDENTIFIER EQUAL ACCEPT ( ) .)
    IDENTIFIER      reduce using rule 52 (assignment -> datatype IDENTIFIER EQUAL ACCEPT ( ) .)
    IF              reduce using rule 52 (assignment -> datatype IDENTIFIER EQUAL ACCEPT ( ) .)
    FUNC            reduce using rule 52 (assignment -> datatype IDENTIFIER EQUAL ACCEPT ( ) .)
    INT_VALUE       reduce using rule 52 (assignment -> datatype IDENTIFIER EQUAL ACCEPT ( ) .)
    FLOAT_VALUE     reduce using rule 52 (assignment -> datatype IDENTIFIER EQUAL ACCEPT ( ) .)
    STRING_VALUE    reduce using rule 52 (assignment -> datatype IDENTIFIER EQUAL ACCEPT ( ) .)
    (               reduce using rule 52 (assignment -> datatype IDENTIFIER EQUAL ACCEPT ( ) .)
    UNARY           reduce using rule 52 (assignment -> datatype IDENTIFIER EQUAL ACCEPT ( ) .)
    INT             reduce using rule 52 (assignment -> datatype IDENTIFIER EQUAL ACCEPT ( ) .)
    FLOAT           reduce using rule 52 (assignment -> datatype IDENTIFIER EQUAL ACCEPT ( ) .)
    STRING          reduce using rule 52 (assignment -> datatype IDENTIFIER EQUAL ACCEPT ( ) .)
    ADAPT           reduce using rule 52 (assignment -> datatype IDENTIFIER EQUAL ACCEPT ( ) .)
    VOID            reduce using rule 52 (assignment -> datatype IDENTIFIER EQUAL ACCEPT ( ) .)
    FOR             reduce using rule 52 (assignment -> datatype IDENTIFIER EQUAL ACCEPT ( ) .)
    WHILE           reduce using rule 52 (assignment -> datatype IDENTIFIER EQUAL ACCEPT ( ) .)


state 113

    (59) forLoop -> FOR ( expression ; condition ; . expression ) { statements }
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (36) variable -> . IDENTIFIER

    INT_VALUE       shift and go to state 28
    FLOAT_VALUE     shift and go to state 29
    STRING_VALUE    shift and go to state 30
    (               shift and go to state 9
    UNARY           shift and go to state 32
    IDENTIFIER      shift and go to state 44

    expression                     shift and go to state 117
    atoms                          shift and go to state 23
    paren_expr                     shift and go to state 24
    binary_expr                    shift and go to state 25
    variable                       shift and go to state 31

state 114

    (60) whileLoop -> WHILE ( condition ) { statements . }
    (4) statements -> statements . statement
    (5) statement -> . function_calls
    (6) statement -> . condition
    (7) statement -> . function_declarations
    (8) statement -> . expression
    (9) statement -> . loops
    (10) statement -> . RETURN expression
    (11) statement -> . PRINT ( expression )
    (12) statement -> . assignment
    (16) function_calls -> . IDENTIFIER ( )
    (17) function_calls -> . IDENTIFIER ( ) function_calls
    (18) function_calls -> . IDENTIFIER ( parameters )
    (19) function_calls -> . IDENTIFIER ( parameters ) function_calls
    (53) condition -> . IF expression { statements }
    (54) condition -> . IF expression { statements } ELSE { statements }
    (13) function_declarations -> . function_declaration
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (55) loops -> . loop
    (56) loops -> . loop loops
    (51) assignment -> . datatype IDENTIFIER EQUAL expression
    (52) assignment -> . datatype IDENTIFIER EQUAL ACCEPT ( )
    (14) function_declaration -> . FUNC IDENTIFIER ( ) : datatype { function_body }
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (57) loop -> . forLoop
    (58) loop -> . whileLoop
    (24) datatype -> . INT
    (25) datatype -> . FLOAT
    (26) datatype -> . STRING
    (27) datatype -> . ADAPT
    (28) datatype -> . VOID
    (36) variable -> . IDENTIFIER
    (59) forLoop -> . FOR ( expression ; condition ; expression ) { statements }
    (60) whileLoop -> . WHILE ( condition ) { statements }

    }               shift and go to state 118
    RETURN          shift and go to state 17
    PRINT           shift and go to state 18
    IDENTIFIER      shift and go to state 20
    IF              shift and go to state 21
    FUNC            shift and go to state 8
    INT_VALUE       shift and go to state 28
    FLOAT_VALUE     shift and go to state 29
    STRING_VALUE    shift and go to state 30
    (               shift and go to state 9
    UNARY           shift and go to state 32
    INT             shift and go to state 35
    FLOAT           shift and go to state 36
    STRING          shift and go to state 37
    ADAPT           shift and go to state 38
    VOID            shift and go to state 39
    FOR             shift and go to state 40
    WHILE           shift and go to state 41

    condition                      shift and go to state 13
    statement                      shift and go to state 46
    function_calls                 shift and go to state 12
    function_declarations          shift and go to state 14
    expression                     shift and go to state 15
    loops                          shift and go to state 16
    assignment                     shift and go to state 19
    function_declaration           shift and go to state 22
    atoms                          shift and go to state 23
    paren_expr                     shift and go to state 24
    binary_expr                    shift and go to state 25
    loop                           shift and go to state 26
    datatype                       shift and go to state 27
    variable                       shift and go to state 31
    forLoop                        shift and go to state 33
    whileLoop                      shift and go to state 34

state 115

    (14) function_declaration -> FUNC IDENTIFIER ( ) : datatype { . function_body }
    (15) function_body -> . statements
    (3) statements -> . statement
    (4) statements -> . statements statement
    (5) statement -> . function_calls
    (6) statement -> . condition
    (7) statement -> . function_declarations
    (8) statement -> . expression
    (9) statement -> . loops
    (10) statement -> . RETURN expression
    (11) statement -> . PRINT ( expression )
    (12) statement -> . assignment
    (16) function_calls -> . IDENTIFIER ( )
    (17) function_calls -> . IDENTIFIER ( ) function_calls
    (18) function_calls -> . IDENTIFIER ( parameters )
    (19) function_calls -> . IDENTIFIER ( parameters ) function_calls
    (53) condition -> . IF expression { statements }
    (54) condition -> . IF expression { statements } ELSE { statements }
    (13) function_declarations -> . function_declaration
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (55) loops -> . loop
    (56) loops -> . loop loops
    (51) assignment -> . datatype IDENTIFIER EQUAL expression
    (52) assignment -> . datatype IDENTIFIER EQUAL ACCEPT ( )
    (14) function_declaration -> . FUNC IDENTIFIER ( ) : datatype { function_body }
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (57) loop -> . forLoop
    (58) loop -> . whileLoop
    (24) datatype -> . INT
    (25) datatype -> . FLOAT
    (26) datatype -> . STRING
    (27) datatype -> . ADAPT
    (28) datatype -> . VOID
    (36) variable -> . IDENTIFIER
    (59) forLoop -> . FOR ( expression ; condition ; expression ) { statements }
    (60) whileLoop -> . WHILE ( condition ) { statements }

    RETURN          shift and go to state 17
    PRINT           shift and go to state 18
    IDENTIFIER      shift and go to state 20
    IF              shift and go to state 21
    FUNC            shift and go to state 8
    INT_VALUE       shift and go to state 28
    FLOAT_VALUE     shift and go to state 29
    STRING_VALUE    shift and go to state 30
    (               shift and go to state 9
    UNARY           shift and go to state 32
    INT             shift and go to state 35
    FLOAT           shift and go to state 36
    STRING          shift and go to state 37
    ADAPT           shift and go to state 38
    VOID            shift and go to state 39
    FOR             shift and go to state 40
    WHILE           shift and go to state 41

    datatype                       shift and go to state 27
    function_body                  shift and go to state 119
    statements                     shift and go to state 120
    statement                      shift and go to state 11
    function_calls                 shift and go to state 12
    condition                      shift and go to state 13
    function_declarations          shift and go to state 14
    expression                     shift and go to state 15
    loops                          shift and go to state 16
    assignment                     shift and go to state 19
    function_declaration           shift and go to state 22
    atoms                          shift and go to state 23
    paren_expr                     shift and go to state 24
    binary_expr                    shift and go to state 25
    loop                           shift and go to state 26
    variable                       shift and go to state 31
    forLoop                        shift and go to state 33
    whileLoop                      shift and go to state 34

state 116

    (54) condition -> IF expression { statements } ELSE { . statements }
    (3) statements -> . statement
    (4) statements -> . statements statement
    (5) statement -> . function_calls
    (6) statement -> . condition
    (7) statement -> . function_declarations
    (8) statement -> . expression
    (9) statement -> . loops
    (10) statement -> . RETURN expression
    (11) statement -> . PRINT ( expression )
    (12) statement -> . assignment
    (16) function_calls -> . IDENTIFIER ( )
    (17) function_calls -> . IDENTIFIER ( ) function_calls
    (18) function_calls -> . IDENTIFIER ( parameters )
    (19) function_calls -> . IDENTIFIER ( parameters ) function_calls
    (53) condition -> . IF expression { statements }
    (54) condition -> . IF expression { statements } ELSE { statements }
    (13) function_declarations -> . function_declaration
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (55) loops -> . loop
    (56) loops -> . loop loops
    (51) assignment -> . datatype IDENTIFIER EQUAL expression
    (52) assignment -> . datatype IDENTIFIER EQUAL ACCEPT ( )
    (14) function_declaration -> . FUNC IDENTIFIER ( ) : datatype { function_body }
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (57) loop -> . forLoop
    (58) loop -> . whileLoop
    (24) datatype -> . INT
    (25) datatype -> . FLOAT
    (26) datatype -> . STRING
    (27) datatype -> . ADAPT
    (28) datatype -> . VOID
    (36) variable -> . IDENTIFIER
    (59) forLoop -> . FOR ( expression ; condition ; expression ) { statements }
    (60) whileLoop -> . WHILE ( condition ) { statements }

    RETURN          shift and go to state 17
    PRINT           shift and go to state 18
    IDENTIFIER      shift and go to state 20
    IF              shift and go to state 21
    FUNC            shift and go to state 8
    INT_VALUE       shift and go to state 28
    FLOAT_VALUE     shift and go to state 29
    STRING_VALUE    shift and go to state 30
    (               shift and go to state 9
    UNARY           shift and go to state 32
    INT             shift and go to state 35
    FLOAT           shift and go to state 36
    STRING          shift and go to state 37
    ADAPT           shift and go to state 38
    VOID            shift and go to state 39
    FOR             shift and go to state 40
    WHILE           shift and go to state 41

    expression                     shift and go to state 15
    statements                     shift and go to state 121
    statement                      shift and go to state 11
    function_calls                 shift and go to state 12
    condition                      shift and go to state 13
    function_declarations          shift and go to state 14
    loops                          shift and go to state 16
    assignment                     shift and go to state 19
    function_declaration           shift and go to state 22
    atoms                          shift and go to state 23
    paren_expr                     shift and go to state 24
    binary_expr                    shift and go to state 25
    loop                           shift and go to state 26
    datatype                       shift and go to state 27
    variable                       shift and go to state 31
    forLoop                        shift and go to state 33
    whileLoop                      shift and go to state 34

state 117

    (59) forLoop -> FOR ( expression ; condition ; expression . ) { statements }

    )               shift and go to state 122


state 118

    (60) whileLoop -> WHILE ( condition ) { statements } .

    FOR             reduce using rule 60 (whileLoop -> WHILE ( condition ) { statements } .)
    WHILE           reduce using rule 60 (whileLoop -> WHILE ( condition ) { statements } .)
    }               reduce using rule 60 (whileLoop -> WHILE ( condition ) { statements } .)
    RETURN          reduce using rule 60 (whileLoop -> WHILE ( condition ) { statements } .)
    PRINT           reduce using rule 60 (whileLoop -> WHILE ( condition ) { statements } .)
    IDENTIFIER      reduce using rule 60 (whileLoop -> WHILE ( condition ) { statements } .)
    IF              reduce using rule 60 (whileLoop -> WHILE ( condition ) { statements } .)
    FUNC            reduce using rule 60 (whileLoop -> WHILE ( condition ) { statements } .)
    INT_VALUE       reduce using rule 60 (whileLoop -> WHILE ( condition ) { statements } .)
    FLOAT_VALUE     reduce using rule 60 (whileLoop -> WHILE ( condition ) { statements } .)
    STRING_VALUE    reduce using rule 60 (whileLoop -> WHILE ( condition ) { statements } .)
    (               reduce using rule 60 (whileLoop -> WHILE ( condition ) { statements } .)
    UNARY           reduce using rule 60 (whileLoop -> WHILE ( condition ) { statements } .)
    INT             reduce using rule 60 (whileLoop -> WHILE ( condition ) { statements } .)
    FLOAT           reduce using rule 60 (whileLoop -> WHILE ( condition ) { statements } .)
    STRING          reduce using rule 60 (whileLoop -> WHILE ( condition ) { statements } .)
    ADAPT           reduce using rule 60 (whileLoop -> WHILE ( condition ) { statements } .)
    VOID            reduce using rule 60 (whileLoop -> WHILE ( condition ) { statements } .)


state 119

    (14) function_declaration -> FUNC IDENTIFIER ( ) : datatype { function_body . }

    }               shift and go to state 123


state 120

    (15) function_body -> statements .
    (4) statements -> statements . statement
    (5) statement -> . function_calls
    (6) statement -> . condition
    (7) statement -> . function_declarations
    (8) statement -> . expression
    (9) statement -> . loops
    (10) statement -> . RETURN expression
    (11) statement -> . PRINT ( expression )
    (12) statement -> . assignment
    (16) function_calls -> . IDENTIFIER ( )
    (17) function_calls -> . IDENTIFIER ( ) function_calls
    (18) function_calls -> . IDENTIFIER ( parameters )
    (19) function_calls -> . IDENTIFIER ( parameters ) function_calls
    (53) condition -> . IF expression { statements }
    (54) condition -> . IF expression { statements } ELSE { statements }
    (13) function_declarations -> . function_declaration
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (55) loops -> . loop
    (56) loops -> . loop loops
    (51) assignment -> . datatype IDENTIFIER EQUAL expression
    (52) assignment -> . datatype IDENTIFIER EQUAL ACCEPT ( )
    (14) function_declaration -> . FUNC IDENTIFIER ( ) : datatype { function_body }
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (57) loop -> . forLoop
    (58) loop -> . whileLoop
    (24) datatype -> . INT
    (25) datatype -> . FLOAT
    (26) datatype -> . STRING
    (27) datatype -> . ADAPT
    (28) datatype -> . VOID
    (36) variable -> . IDENTIFIER
    (59) forLoop -> . FOR ( expression ; condition ; expression ) { statements }
    (60) whileLoop -> . WHILE ( condition ) { statements }

    }               reduce using rule 15 (function_body -> statements .)
    RETURN          shift and go to state 17
    PRINT           shift and go to state 18
    IDENTIFIER      shift and go to state 20
    IF              shift and go to state 21
    FUNC            shift and go to state 8
    INT_VALUE       shift and go to state 28
    FLOAT_VALUE     shift and go to state 29
    STRING_VALUE    shift and go to state 30
    (               shift and go to state 9
    UNARY           shift and go to state 32
    INT             shift and go to state 35
    FLOAT           shift and go to state 36
    STRING          shift and go to state 37
    ADAPT           shift and go to state 38
    VOID            shift and go to state 39
    FOR             shift and go to state 40
    WHILE           shift and go to state 41

    statement                      shift and go to state 46
    function_calls                 shift and go to state 12
    condition                      shift and go to state 13
    function_declarations          shift and go to state 14
    expression                     shift and go to state 15
    loops                          shift and go to state 16
    assignment                     shift and go to state 19
    function_declaration           shift and go to state 22
    atoms                          shift and go to state 23
    paren_expr                     shift and go to state 24
    binary_expr                    shift and go to state 25
    loop                           shift and go to state 26
    datatype                       shift and go to state 27
    variable                       shift and go to state 31
    forLoop                        shift and go to state 33
    whileLoop                      shift and go to state 34

state 121

    (54) condition -> IF expression { statements } ELSE { statements . }
    (4) statements -> statements . statement
    (5) statement -> . function_calls
    (6) statement -> . condition
    (7) statement -> . function_declarations
    (8) statement -> . expression
    (9) statement -> . loops
    (10) statement -> . RETURN expression
    (11) statement -> . PRINT ( expression )
    (12) statement -> . assignment
    (16) function_calls -> . IDENTIFIER ( )
    (17) function_calls -> . IDENTIFIER ( ) function_calls
    (18) function_calls -> . IDENTIFIER ( parameters )
    (19) function_calls -> . IDENTIFIER ( parameters ) function_calls
    (53) condition -> . IF expression { statements }
    (54) condition -> . IF expression { statements } ELSE { statements }
    (13) function_declarations -> . function_declaration
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (55) loops -> . loop
    (56) loops -> . loop loops
    (51) assignment -> . datatype IDENTIFIER EQUAL expression
    (52) assignment -> . datatype IDENTIFIER EQUAL ACCEPT ( )
    (14) function_declaration -> . FUNC IDENTIFIER ( ) : datatype { function_body }
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (57) loop -> . forLoop
    (58) loop -> . whileLoop
    (24) datatype -> . INT
    (25) datatype -> . FLOAT
    (26) datatype -> . STRING
    (27) datatype -> . ADAPT
    (28) datatype -> . VOID
    (36) variable -> . IDENTIFIER
    (59) forLoop -> . FOR ( expression ; condition ; expression ) { statements }
    (60) whileLoop -> . WHILE ( condition ) { statements }

    }               shift and go to state 124
    RETURN          shift and go to state 17
    PRINT           shift and go to state 18
    IDENTIFIER      shift and go to state 20
    IF              shift and go to state 21
    FUNC            shift and go to state 8
    INT_VALUE       shift and go to state 28
    FLOAT_VALUE     shift and go to state 29
    STRING_VALUE    shift and go to state 30
    (               shift and go to state 9
    UNARY           shift and go to state 32
    INT             shift and go to state 35
    FLOAT           shift and go to state 36
    STRING          shift and go to state 37
    ADAPT           shift and go to state 38
    VOID            shift and go to state 39
    FOR             shift and go to state 40
    WHILE           shift and go to state 41

    expression                     shift and go to state 15
    statement                      shift and go to state 46
    function_calls                 shift and go to state 12
    condition                      shift and go to state 13
    function_declarations          shift and go to state 14
    loops                          shift and go to state 16
    assignment                     shift and go to state 19
    function_declaration           shift and go to state 22
    atoms                          shift and go to state 23
    paren_expr                     shift and go to state 24
    binary_expr                    shift and go to state 25
    loop                           shift and go to state 26
    datatype                       shift and go to state 27
    variable                       shift and go to state 31
    forLoop                        shift and go to state 33
    whileLoop                      shift and go to state 34

state 122

    (59) forLoop -> FOR ( expression ; condition ; expression ) . { statements }

    {               shift and go to state 125


state 123

    (14) function_declaration -> FUNC IDENTIFIER ( ) : datatype { function_body } .

    }               reduce using rule 14 (function_declaration -> FUNC IDENTIFIER ( ) : datatype { function_body } .)
    RETURN          reduce using rule 14 (function_declaration -> FUNC IDENTIFIER ( ) : datatype { function_body } .)
    PRINT           reduce using rule 14 (function_declaration -> FUNC IDENTIFIER ( ) : datatype { function_body } .)
    IDENTIFIER      reduce using rule 14 (function_declaration -> FUNC IDENTIFIER ( ) : datatype { function_body } .)
    IF              reduce using rule 14 (function_declaration -> FUNC IDENTIFIER ( ) : datatype { function_body } .)
    FUNC            reduce using rule 14 (function_declaration -> FUNC IDENTIFIER ( ) : datatype { function_body } .)
    INT_VALUE       reduce using rule 14 (function_declaration -> FUNC IDENTIFIER ( ) : datatype { function_body } .)
    FLOAT_VALUE     reduce using rule 14 (function_declaration -> FUNC IDENTIFIER ( ) : datatype { function_body } .)
    STRING_VALUE    reduce using rule 14 (function_declaration -> FUNC IDENTIFIER ( ) : datatype { function_body } .)
    (               reduce using rule 14 (function_declaration -> FUNC IDENTIFIER ( ) : datatype { function_body } .)
    UNARY           reduce using rule 14 (function_declaration -> FUNC IDENTIFIER ( ) : datatype { function_body } .)
    INT             reduce using rule 14 (function_declaration -> FUNC IDENTIFIER ( ) : datatype { function_body } .)
    FLOAT           reduce using rule 14 (function_declaration -> FUNC IDENTIFIER ( ) : datatype { function_body } .)
    STRING          reduce using rule 14 (function_declaration -> FUNC IDENTIFIER ( ) : datatype { function_body } .)
    ADAPT           reduce using rule 14 (function_declaration -> FUNC IDENTIFIER ( ) : datatype { function_body } .)
    VOID            reduce using rule 14 (function_declaration -> FUNC IDENTIFIER ( ) : datatype { function_body } .)
    FOR             reduce using rule 14 (function_declaration -> FUNC IDENTIFIER ( ) : datatype { function_body } .)
    WHILE           reduce using rule 14 (function_declaration -> FUNC IDENTIFIER ( ) : datatype { function_body } .)


state 124

    (54) condition -> IF expression { statements } ELSE { statements } .

    }               reduce using rule 54 (condition -> IF expression { statements } ELSE { statements } .)
    RETURN          reduce using rule 54 (condition -> IF expression { statements } ELSE { statements } .)
    PRINT           reduce using rule 54 (condition -> IF expression { statements } ELSE { statements } .)
    IDENTIFIER      reduce using rule 54 (condition -> IF expression { statements } ELSE { statements } .)
    IF              reduce using rule 54 (condition -> IF expression { statements } ELSE { statements } .)
    FUNC            reduce using rule 54 (condition -> IF expression { statements } ELSE { statements } .)
    INT_VALUE       reduce using rule 54 (condition -> IF expression { statements } ELSE { statements } .)
    FLOAT_VALUE     reduce using rule 54 (condition -> IF expression { statements } ELSE { statements } .)
    STRING_VALUE    reduce using rule 54 (condition -> IF expression { statements } ELSE { statements } .)
    (               reduce using rule 54 (condition -> IF expression { statements } ELSE { statements } .)
    UNARY           reduce using rule 54 (condition -> IF expression { statements } ELSE { statements } .)
    INT             reduce using rule 54 (condition -> IF expression { statements } ELSE { statements } .)
    FLOAT           reduce using rule 54 (condition -> IF expression { statements } ELSE { statements } .)
    STRING          reduce using rule 54 (condition -> IF expression { statements } ELSE { statements } .)
    ADAPT           reduce using rule 54 (condition -> IF expression { statements } ELSE { statements } .)
    VOID            reduce using rule 54 (condition -> IF expression { statements } ELSE { statements } .)
    FOR             reduce using rule 54 (condition -> IF expression { statements } ELSE { statements } .)
    WHILE           reduce using rule 54 (condition -> IF expression { statements } ELSE { statements } .)
    )               reduce using rule 54 (condition -> IF expression { statements } ELSE { statements } .)
    ;               reduce using rule 54 (condition -> IF expression { statements } ELSE { statements } .)


state 125

    (59) forLoop -> FOR ( expression ; condition ; expression ) { . statements }
    (3) statements -> . statement
    (4) statements -> . statements statement
    (5) statement -> . function_calls
    (6) statement -> . condition
    (7) statement -> . function_declarations
    (8) statement -> . expression
    (9) statement -> . loops
    (10) statement -> . RETURN expression
    (11) statement -> . PRINT ( expression )
    (12) statement -> . assignment
    (16) function_calls -> . IDENTIFIER ( )
    (17) function_calls -> . IDENTIFIER ( ) function_calls
    (18) function_calls -> . IDENTIFIER ( parameters )
    (19) function_calls -> . IDENTIFIER ( parameters ) function_calls
    (53) condition -> . IF expression { statements }
    (54) condition -> . IF expression { statements } ELSE { statements }
    (13) function_declarations -> . function_declaration
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (55) loops -> . loop
    (56) loops -> . loop loops
    (51) assignment -> . datatype IDENTIFIER EQUAL expression
    (52) assignment -> . datatype IDENTIFIER EQUAL ACCEPT ( )
    (14) function_declaration -> . FUNC IDENTIFIER ( ) : datatype { function_body }
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (57) loop -> . forLoop
    (58) loop -> . whileLoop
    (24) datatype -> . INT
    (25) datatype -> . FLOAT
    (26) datatype -> . STRING
    (27) datatype -> . ADAPT
    (28) datatype -> . VOID
    (36) variable -> . IDENTIFIER
    (59) forLoop -> . FOR ( expression ; condition ; expression ) { statements }
    (60) whileLoop -> . WHILE ( condition ) { statements }

    RETURN          shift and go to state 17
    PRINT           shift and go to state 18
    IDENTIFIER      shift and go to state 20
    IF              shift and go to state 21
    FUNC            shift and go to state 8
    INT_VALUE       shift and go to state 28
    FLOAT_VALUE     shift and go to state 29
    STRING_VALUE    shift and go to state 30
    (               shift and go to state 9
    UNARY           shift and go to state 32
    INT             shift and go to state 35
    FLOAT           shift and go to state 36
    STRING          shift and go to state 37
    ADAPT           shift and go to state 38
    VOID            shift and go to state 39
    FOR             shift and go to state 40
    WHILE           shift and go to state 41

    expression                     shift and go to state 15
    condition                      shift and go to state 13
    statements                     shift and go to state 126
    statement                      shift and go to state 11
    function_calls                 shift and go to state 12
    function_declarations          shift and go to state 14
    loops                          shift and go to state 16
    assignment                     shift and go to state 19
    function_declaration           shift and go to state 22
    atoms                          shift and go to state 23
    paren_expr                     shift and go to state 24
    binary_expr                    shift and go to state 25
    loop                           shift and go to state 26
    datatype                       shift and go to state 27
    variable                       shift and go to state 31
    forLoop                        shift and go to state 33
    whileLoop                      shift and go to state 34

state 126

    (59) forLoop -> FOR ( expression ; condition ; expression ) { statements . }
    (4) statements -> statements . statement
    (5) statement -> . function_calls
    (6) statement -> . condition
    (7) statement -> . function_declarations
    (8) statement -> . expression
    (9) statement -> . loops
    (10) statement -> . RETURN expression
    (11) statement -> . PRINT ( expression )
    (12) statement -> . assignment
    (16) function_calls -> . IDENTIFIER ( )
    (17) function_calls -> . IDENTIFIER ( ) function_calls
    (18) function_calls -> . IDENTIFIER ( parameters )
    (19) function_calls -> . IDENTIFIER ( parameters ) function_calls
    (53) condition -> . IF expression { statements }
    (54) condition -> . IF expression { statements } ELSE { statements }
    (13) function_declarations -> . function_declaration
    (29) expression -> . atoms
    (30) expression -> . paren_expr
    (31) expression -> . binary_expr
    (55) loops -> . loop
    (56) loops -> . loop loops
    (51) assignment -> . datatype IDENTIFIER EQUAL expression
    (52) assignment -> . datatype IDENTIFIER EQUAL ACCEPT ( )
    (14) function_declaration -> . FUNC IDENTIFIER ( ) : datatype { function_body }
    (32) atoms -> . INT_VALUE
    (33) atoms -> . FLOAT_VALUE
    (34) atoms -> . STRING_VALUE
    (35) atoms -> . variable
    (37) paren_expr -> . ( expression )
    (38) binary_expr -> . atoms ADD expression
    (39) binary_expr -> . atoms SUB expression
    (40) binary_expr -> . atoms MUL expression
    (41) binary_expr -> . atoms DIV expression
    (42) binary_expr -> . atoms OR expression
    (43) binary_expr -> . atoms LE expression
    (44) binary_expr -> . atoms GE expression
    (45) binary_expr -> . atoms EQ expression
    (46) binary_expr -> . atoms NE expression
    (47) binary_expr -> . atoms GT expression
    (48) binary_expr -> . atoms LT expression
    (49) binary_expr -> . UNARY atoms
    (50) binary_expr -> . atoms UNARY
    (57) loop -> . forLoop
    (58) loop -> . whileLoop
    (24) datatype -> . INT
    (25) datatype -> . FLOAT
    (26) datatype -> . STRING
    (27) datatype -> . ADAPT
    (28) datatype -> . VOID
    (36) variable -> . IDENTIFIER
    (59) forLoop -> . FOR ( expression ; condition ; expression ) { statements }
    (60) whileLoop -> . WHILE ( condition ) { statements }

    }               shift and go to state 127
    RETURN          shift and go to state 17
    PRINT           shift and go to state 18
    IDENTIFIER      shift and go to state 20
    IF              shift and go to state 21
    FUNC            shift and go to state 8
    INT_VALUE       shift and go to state 28
    FLOAT_VALUE     shift and go to state 29
    STRING_VALUE    shift and go to state 30
    (               shift and go to state 9
    UNARY           shift and go to state 32
    INT             shift and go to state 35
    FLOAT           shift and go to state 36
    STRING          shift and go to state 37
    ADAPT           shift and go to state 38
    VOID            shift and go to state 39
    FOR             shift and go to state 40
    WHILE           shift and go to state 41

    expression                     shift and go to state 15
    condition                      shift and go to state 13
    statement                      shift and go to state 46
    function_calls                 shift and go to state 12
    function_declarations          shift and go to state 14
    loops                          shift and go to state 16
    assignment                     shift and go to state 19
    function_declaration           shift and go to state 22
    atoms                          shift and go to state 23
    paren_expr                     shift and go to state 24
    binary_expr                    shift and go to state 25
    loop                           shift and go to state 26
    datatype                       shift and go to state 27
    variable                       shift and go to state 31
    forLoop                        shift and go to state 33
    whileLoop                      shift and go to state 34

state 127

    (59) forLoop -> FOR ( expression ; condition ; expression ) { statements } .

    FOR             reduce using rule 59 (forLoop -> FOR ( expression ; condition ; expression ) { statements } .)
    WHILE           reduce using rule 59 (forLoop -> FOR ( expression ; condition ; expression ) { statements } .)
    }               reduce using rule 59 (forLoop -> FOR ( expression ; condition ; expression ) { statements } .)
    RETURN          reduce using rule 59 (forLoop -> FOR ( expression ; condition ; expression ) { statements } .)
    PRINT           reduce using rule 59 (forLoop -> FOR ( expression ; condition ; expression ) { statements } .)
    IDENTIFIER      reduce using rule 59 (forLoop -> FOR ( expression ; condition ; expression ) { statements } .)
    IF              reduce using rule 59 (forLoop -> FOR ( expression ; condition ; expression ) { statements } .)
    FUNC            reduce using rule 59 (forLoop -> FOR ( expression ; condition ; expression ) { statements } .)
    INT_VALUE       reduce using rule 59 (forLoop -> FOR ( expression ; condition ; expression ) { statements } .)
    FLOAT_VALUE     reduce using rule 59 (forLoop -> FOR ( expression ; condition ; expression ) { statements } .)
    STRING_VALUE    reduce using rule 59 (forLoop -> FOR ( expression ; condition ; expression ) { statements } .)
    (               reduce using rule 59 (forLoop -> FOR ( expression ; condition ; expression ) { statements } .)
    UNARY           reduce using rule 59 (forLoop -> FOR ( expression ; condition ; expression ) { statements } .)
    INT             reduce using rule 59 (forLoop -> FOR ( expression ; condition ; expression ) { statements } .)
    FLOAT           reduce using rule 59 (forLoop -> FOR ( expression ; condition ; expression ) { statements } .)
    STRING          reduce using rule 59 (forLoop -> FOR ( expression ; condition ; expression ) { statements } .)
    ADAPT           reduce using rule 59 (forLoop -> FOR ( expression ; condition ; expression ) { statements } .)
    VOID            reduce using rule 59 (forLoop -> FOR ( expression ; condition ; expression ) { statements } .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ( in state 20 resolved as shift
WARNING: shift/reduce conflict for UNARY in state 23 resolved as shift
WARNING: shift/reduce conflict for FOR in state 26 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 26 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 71 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 95 resolved as shift
